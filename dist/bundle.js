/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@pixi/colord/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/@pixi/colord/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Colord: () => (/* binding */ j),
/* harmony export */   colord: () => (/* binding */ w),
/* harmony export */   extend: () => (/* binding */ k),
/* harmony export */   getFormat: () => (/* binding */ I),
/* harmony export */   random: () => (/* binding */ E)
/* harmony export */ });
var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));// removed by dead control flow
{ var t, n, e; }},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};// removed by dead control flow
{ var t, n, e, u; }},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;// removed by dead control flow
{ var r, t, e, u, a, i; }},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";// removed by dead control flow
{ var r, t, n, e, u; }},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";// removed by dead control flow
{ var r, t, n, e, u; }},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};// removed by dead control flow
{ var r; }},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});// removed by dead control flow
{ var r; }},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);// removed by dead control flow
{ var t; }},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};


/***/ }),

/***/ "./node_modules/@pixi/colord/plugins/names.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/colord/plugins/names.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/conventions.js":
/*!********************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/conventions.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
 *
 * Works with anything that has a `length` property and index access properties, including NodeList.
 *
 * @template {unknown} T
 * @param {Array<T> | ({length:number, [number]: T})} list
 * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
 * 				allows injecting a custom implementation in tests
 * @returns {T | undefined}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
 */
function find(list, predicate, ac) {
	if (ac === undefined) {
		ac = Array.prototype;
	}
	if (list && typeof ac.find === 'function') {
		return ac.find.call(list, predicate);
	}
	for (var i = 0; i < list.length; i++) {
		if (Object.prototype.hasOwnProperty.call(list, i)) {
			var item = list[i];
			if (predicate.call(undefined, item, i, list)) {
				return item;
			}
		}
	}
}

/**
 * "Shallow freezes" an object to render it immutable.
 * Uses `Object.freeze` if available,
 * otherwise the immutability is only in the type.
 *
 * Is used to create "enum like" objects.
 *
 * @template T
 * @param {T} object the object to freeze
 * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
 * 				allows to inject custom object constructor for tests
 * @returns {Readonly<T>}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 */
function freeze(object, oc) {
	if (oc === undefined) {
		oc = Object
	}
	return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object
}

/**
 * Since we can not rely on `Object.assign` we provide a simplified version
 * that is sufficient for our needs.
 *
 * @param {Object} target
 * @param {Object | null | undefined} source
 *
 * @returns {Object} target
 * @throws TypeError if target is not an object
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
 */
function assign(target, source) {
	if (target === null || typeof target !== 'object') {
		throw new TypeError('target is not an object')
	}
	for (var key in source) {
		if (Object.prototype.hasOwnProperty.call(source, key)) {
			target[key] = source[key]
		}
	}
	return target
}

/**
 * All mime types that are allowed as input to `DOMParser.parseFromString`
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
 * @see DOMParser.prototype.parseFromString
 */
var MIME_TYPE = freeze({
	/**
	 * `text/html`, the only mime type that triggers treating an XML document as HTML.
	 *
	 * @see DOMParser.SupportedType.isHTML
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
	 */
	HTML: 'text/html',

	/**
	 * Helper method to check a mime type if it indicates an HTML document
	 *
	 * @param {string} [value]
	 * @returns {boolean}
	 *
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
	isHTML: function (value) {
		return value === MIME_TYPE.HTML
	},

	/**
	 * `application/xml`, the standard mime type for XML documents.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
	 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_APPLICATION: 'application/xml',

	/**
	 * `text/html`, an alias for `application/xml`.
	 *
	 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
	 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_TEXT: 'text/xml',

	/**
	 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
	 * but is parsed as an XML document.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
	 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
	 */
	XML_XHTML_APPLICATION: 'application/xhtml+xml',

	/**
	 * `image/svg+xml`,
	 *
	 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
	 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
	 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
	 */
	XML_SVG_IMAGE: 'image/svg+xml',
})

/**
 * Namespaces that are used in this code base.
 *
 * @see http://www.w3.org/TR/REC-xml-names
 */
var NAMESPACE = freeze({
	/**
	 * The XHTML namespace.
	 *
	 * @see http://www.w3.org/1999/xhtml
	 */
	HTML: 'http://www.w3.org/1999/xhtml',

	/**
	 * Checks if `uri` equals `NAMESPACE.HTML`.
	 *
	 * @param {string} [uri]
	 *
	 * @see NAMESPACE.HTML
	 */
	isHTML: function (uri) {
		return uri === NAMESPACE.HTML
	},

	/**
	 * The SVG namespace.
	 *
	 * @see http://www.w3.org/2000/svg
	 */
	SVG: 'http://www.w3.org/2000/svg',

	/**
	 * The `xml:` namespace.
	 *
	 * @see http://www.w3.org/XML/1998/namespace
	 */
	XML: 'http://www.w3.org/XML/1998/namespace',

	/**
	 * The `xmlns:` namespace
	 *
	 * @see https://www.w3.org/2000/xmlns/
	 */
	XMLNS: 'http://www.w3.org/2000/xmlns/',
})

exports.assign = assign;
exports.find = find;
exports.freeze = freeze;
exports.MIME_TYPE = MIME_TYPE;
exports.NAMESPACE = NAMESPACE;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom-parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom-parser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var conventions = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js");
var dom = __webpack_require__(/*! ./dom */ "./node_modules/@xmldom/xmldom/lib/dom.js")
var entities = __webpack_require__(/*! ./entities */ "./node_modules/@xmldom/xmldom/lib/entities.js");
var sax = __webpack_require__(/*! ./sax */ "./node_modules/@xmldom/xmldom/lib/sax.js");

var DOMImplementation = dom.DOMImplementation;

var NAMESPACE = conventions.NAMESPACE;

var ParseError = sax.ParseError;
var XMLReader = sax.XMLReader;

/**
 * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
 *
 * > XML parsed entities are often stored in computer files which,
 * > for editing convenience, are organized into lines.
 * > These lines are typically separated by some combination
 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
 * >
 * > To simplify the tasks of applications, the XML processor must behave
 * > as if it normalized all line breaks in external parsed entities (including the document entity)
 * > on input, before parsing, by translating all of the following to a single #xA character:
 * >
 * > 1. the two-character sequence #xD #xA
 * > 2. the two-character sequence #xD #x85
 * > 3. the single character #x85
 * > 4. the single character #x2028
 * > 5. any #xD character that is not immediately followed by #xA or #x85.
 *
 * @param {string} input
 * @returns {string}
 */
function normalizeLineEndings(input) {
	return input
		.replace(/\r[\n\u0085]/g, '\n')
		.replace(/[\r\u0085\u2028]/g, '\n')
}

/**
 * @typedef Locator
 * @property {number} [columnNumber]
 * @property {number} [lineNumber]
 */

/**
 * @typedef DOMParserOptions
 * @property {DOMHandler} [domBuilder]
 * @property {Function} [errorHandler]
 * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
 * 						defaults to `normalizeLineEndings`
 * @property {Locator} [locator]
 * @property {Record<string, string>} [xmlns]
 *
 * @see normalizeLineEndings
 */

/**
 * The DOMParser interface provides the ability to parse XML or HTML source code
 * from a string into a DOM `Document`.
 *
 * _xmldom is different from the spec in that it allows an `options` parameter,
 * to override the default behavior._
 *
 * @param {DOMParserOptions} [options]
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
 */
function DOMParser(options){
	this.options = options ||{locator:{}};
}

DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var isHTML = /\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;
  	var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}

	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(isHTML){
		defaultNSMap[''] = NAMESPACE.HTML;
	}
	defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
	var normalize = options.normalizeLineEndings || normalizeLineEndings;
	if (source && typeof source === 'string') {
		sax.parse(
			normalize(source),
			defaultNSMap,
			entityMap
		)
	} else {
		sax.errorHandler.error('invalid doc source')
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler
 *
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;

		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},

	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},

	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
					this.doc.doctype = dt;
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		throw new ParseError(error, this.locator);
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

exports.__DOMHandler = DOMHandler;
exports.normalizeLineEndings = normalizeLineEndings;
exports.DOMParser = DOMParser;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var conventions = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js");

var find = conventions.find;
var NAMESPACE = conventions.NAMESPACE;

/**
 * A prerequisite for `[].filter`, to drop elements that are empty
 * @param {string} input
 * @returns {boolean}
 */
function notEmptyString (input) {
	return input !== ''
}
/**
 * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
 * @see https://infra.spec.whatwg.org/#ascii-whitespace
 *
 * @param {string} input
 * @returns {string[]} (can be empty)
 */
function splitOnASCIIWhitespace(input) {
	// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
	return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : []
}

/**
 * Adds element as a key to current if it is not already present.
 *
 * @param {Record<string, boolean | undefined>} current
 * @param {string} element
 * @returns {Record<string, boolean | undefined>}
 */
function orderedSetReducer (current, element) {
	if (!current.hasOwnProperty(element)) {
		current[element] = true;
	}
	return current;
}

/**
 * @see https://infra.spec.whatwg.org/#ordered-set
 * @param {string} input
 * @returns {string[]}
 */
function toOrderedSet(input) {
	if (!input) return [];
	var list = splitOnASCIIWhitespace(input);
	return Object.keys(list.reduce(orderedSetReducer, {}))
}

/**
 * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
 * which we can not rely on being available.
 *
 * @param {any[]} list
 * @returns {function(any): boolean}
 */
function arrayIncludes (list) {
	return function(element) {
		return list && list.indexOf(element) !== -1;
	}
}

function copy(src,dest){
	for(var p in src){
		if (Object.prototype.hasOwnProperty.call(src, p)) {
			dest[p] = src[p];
		}
	}
}

/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknown Class:"+Class)
		}
		pt.constructor = Class
	}
}

// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);

/**
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 */
function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)

/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0,
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
	 */
	item: function(index) {
		return index >= 0 && index < this.length ? this[index] : null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	},
	/**
	 * @private
	 * @param {function (Node):boolean} predicate
	 * @returns {Node[]}
	 */
	filter: function (predicate) {
		return Array.prototype.filter.call(this, predicate);
	},
	/**
	 * @private
	 * @param {Node} item
	 * @returns {number}
	 */
	indexOf: function (item) {
		return Array.prototype.indexOf.call(this, item);
	},
};

function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if (list._inc !== inc) {
		var ls = list._refresh(list._node);
		__set__(list,'length',ls.length);
		if (!list.$$length || ls.length < list.$$length) {
			for (var i = ls.length; i in list; i++) {
				if (Object.prototype.hasOwnProperty.call(list, i)) {
					delete list[i];
				}
			}
		}
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i] || null;
}

_extends(LiveNodeList,NodeList);

/**
 * Objects implementing the NamedNodeMap interface are used
 * to represent collections of nodes that can be accessed by name.
 * Note that NamedNodeMap does not inherit from NodeList;
 * NamedNodeMaps are not maintained in any particular order.
 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
 * and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw new DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;


	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};

/**
 * The DOMImplementation interface represents an object providing methods
 * which are not dependent on any particular document.
 * Such an object is returned by the `Document.implementation` property.
 *
 * __The individual methods describe the differences compared to the specs.__
 *
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
 */
function DOMImplementation() {
}

DOMImplementation.prototype = {
	/**
	 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
	 * The different implementations fairly diverged in what kind of features were reported.
	 * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
	 *
	 * @deprecated It is deprecated and modern browsers return true in all cases.
	 *
	 * @param {string} feature
	 * @param {string} [version]
	 * @returns {boolean} always true
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
	 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
	 */
	hasFeature: function(feature, version) {
			return true;
	},
	/**
	 * Creates an XML Document object of the specified type with its document element.
	 *
	 * __It behaves slightly different from the description in the living standard__:
	 * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
	 * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 * - this implementation is not validating names or qualified names
	 *   (when parsing XML strings, the SAX parser takes care of that)
	 *
	 * @param {string|null} namespaceURI
	 * @param {string} qualifiedName
	 * @param {DocumentType=null} doctype
	 * @returns {Document}
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
	 *
	 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
	 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
	 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
	 */
	createDocument: function(namespaceURI,  qualifiedName, doctype){
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype || null;
		if (doctype){
			doc.appendChild(doctype);
		}
		if (qualifiedName){
			var root = doc.createElementNS(namespaceURI, qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	/**
	 * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
	 *
	 * __This behavior is slightly different from the in the specs__:
	 * - this implementation is not validating names or qualified names
	 *   (when parsing XML strings, the SAX parser takes care of that)
	 *
	 * @param {string} qualifiedName
	 * @param {string} [publicId]
	 * @param {string} [systemId]
	 * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
	 * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
	 *
	 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
	 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
	 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
	 */
	createDocumentType: function(qualifiedName, publicId, systemId){
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId || '';
		node.systemId = systemId || '';

		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises
		_insertBefore(this, newChild,oldChild, assertPreReplacementValidityInDocument);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
	/**
	 * Look up the prefix associated to the given namespace URI, starting from this node.
	 * **The default namespace declarations are ignored by this method.**
	 * See Namespace Prefix Lookup for details on the algorithm used by this method.
	 *
	 * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
	 *
	 * @param {string | null} namespaceURI
	 * @returns {string | null}
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
	 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
	 * @see https://github.com/xmldom/xmldom/issues/322
	 */
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
						if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
							return n;
						}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(Object.prototype.hasOwnProperty.call(map, prefix)){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
	this.ownerDocument = this;
}

function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns === NAMESPACE.XMLNS){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}

function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns === NAMESPACE.XMLNS){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}

/**
 * Updates `el.childNodes`, updating the indexed items and it's `length`.
 * Passing `newChild` means it will be appended.
 * Otherwise it's assumed that an item has been removed,
 * and `el.firstNode` and it's `.nextSibling` are used
 * to walk the current list of child nodes.
 *
 * @param {Document} doc
 * @param {Node} el
 * @param {Node} [newChild]
 * @private
 */
function _onUpdateChild (doc, el, newChild) {
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if (newChild) {
			cs[cs.length++] = newChild;
		} else {
			var child = el.firstChild;
			var i = 0;
			while (child) {
				cs[i++] = child;
				child = child.nextSibling;
			}
			cs.length = i;
			delete cs[cs.length];
		}
	}
}

/**
 * Removes the connections between `parentNode` and `child`
 * and any existing `child.previousSibling` or `child.nextSibling`.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 *
 * @param {Node} parentNode
 * @param {Node} child
 * @returns {Node} the child that was removed.
 * @private
 */
function _removeChild (parentNode, child) {
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if (previous) {
		previous.nextSibling = next;
	} else {
		parentNode.firstChild = next;
	}
	if (next) {
		next.previousSibling = previous;
	} else {
		parentNode.lastChild = previous;
	}
	child.parentNode = null;
	child.previousSibling = null;
	child.nextSibling = null;
	_onUpdateChild(parentNode.ownerDocument, parentNode);
	return child;
}

/**
 * Returns `true` if `node` can be a parent for insertion.
 * @param {Node} node
 * @returns {boolean}
 */
function hasValidParentNodeType(node) {
	return (
		node &&
		(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)
	);
}

/**
 * Returns `true` if `node` can be inserted according to it's `nodeType`.
 * @param {Node} node
 * @returns {boolean}
 */
function hasInsertableNodeType(node) {
	return (
		node &&
		(isElementNode(node) ||
			isTextNode(node) ||
			isDocTypeNode(node) ||
			node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
			node.nodeType === Node.COMMENT_NODE ||
			node.nodeType === Node.PROCESSING_INSTRUCTION_NODE)
	);
}

/**
 * Returns true if `node` is a DOCTYPE node
 * @param {Node} node
 * @returns {boolean}
 */
function isDocTypeNode(node) {
	return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
}

/**
 * Returns true if the node is an element
 * @param {Node} node
 * @returns {boolean}
 */
function isElementNode(node) {
	return node && node.nodeType === Node.ELEMENT_NODE;
}
/**
 * Returns true if `node` is a text node
 * @param {Node} node
 * @returns {boolean}
 */
function isTextNode(node) {
	return node && node.nodeType === Node.TEXT_NODE;
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Document} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementInsertionPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];
	if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Node} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementReplacementPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];

	function hasElementChildThatIsNotChild(node) {
		return isElementNode(node) && node !== child;
	}

	if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * @private
 * Steps 1-5 of the checks before inserting and before replacing a child are the same.
 *
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidity1to5(parent, node, child) {
	// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
	if (!hasValidParentNodeType(parent)) {
		throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
	}
	// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
	// not implemented!
	// 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
	if (child && child.parentNode !== parent) {
		throw new DOMException(NOT_FOUND_ERR, 'child not in parent');
	}
	if (
		// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
		!hasInsertableNodeType(node) ||
		// 5. If either `node` is a Text node and `parent` is a document,
		// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
		// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
		// or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
		(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
	) {
		throw new DOMException(
			HIERARCHY_REQUEST_ERR,
			'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
		);
	}
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If node has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child,
		// `child` is a doctype, or `child` is non-null and a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child, `child` is a doctype,
		// or `child` is non-null and a doctype is following `child`.
		if (!isElementInsertionPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		// `parent` has a doctype child,
		if (find(parentChildNodes, isDocTypeNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// `child` is non-null and an element is preceding `child`,
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
		// or `child` is null and `parent` has an element child.
		if (!child && parentElementChild) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
		}
	}
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreReplacementValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If `node` has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child that is not `child` or a doctype is following `child`.
		if (!isElementReplacementPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		function hasDoctypeChildThatIsNotChild(node) {
			return isDocTypeNode(node) && node !== child;
		}

		// `parent` has a doctype child that is not `child`,
		if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// or an element is preceding `child`.
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
	}
}

/**
 * @private
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function _insertBefore(parent, node, child, _inDocumentAssertion) {
	// To ensure pre-insertion validity of a node into a parent before a child, run these steps:
	assertPreInsertionValidity1to5(parent, node, child);

	// If parent is a document, and any of the statements below, switched on the interface node implements,
	// are true, then throw a "HierarchyRequestError" DOMException.
	if (parent.nodeType === Node.DOCUMENT_NODE) {
		(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
	}

	var cp = node.parentNode;
	if(cp){
		cp.removeChild(node);//remove and update
	}
	if(node.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = node.firstChild;
		if (newFirst == null) {
			return node;
		}
		var newLast = node.lastChild;
	}else{
		newFirst = newLast = node;
	}
	var pre = child ? child.previousSibling : parent.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = child;


	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parent.firstChild = newFirst;
	}
	if(child == null){
		parent.lastChild = newLast;
	}else{
		child.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parent;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parent.ownerDocument||parent, parent);
	//console.log(parent.lastChild.nextSibling == null)
	if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
		node.firstChild = node.lastChild = null;
	}
	return node;
}

/**
 * Appends `newChild` to `parentNode`.
 * If `newChild` is already connected to a `parentNode` it is first removed from it.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 * @param {Node} parentNode
 * @param {Node} newChild
 * @returns {Node}
 * @private
 */
function _appendSingleChild (parentNode, newChild) {
	if (newChild.parentNode) {
		newChild.parentNode.removeChild(newChild);
	}
	newChild.parentNode = parentNode;
	newChild.previousSibling = parentNode.lastChild;
	newChild.nextSibling = null;
	if (newChild.previousSibling) {
		newChild.previousSibling.nextSibling = newChild;
	} else {
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
	return newChild;
}

Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	/**
	 * The DocumentType node of the document.
	 *
	 * @readonly
	 * @type DocumentType
	 */
	doctype :  null,
	documentElement :  null,
	_inc : 1,

	insertBefore :  function(newChild, refChild){//raises
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		_insertBefore(this, newChild, refChild);
		newChild.ownerDocument = this;
		if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
			this.documentElement = newChild;
		}

		return newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	replaceChild: function (newChild, oldChild) {
		//raises
		_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
		newChild.ownerDocument = this;
		if (oldChild) {
			this.removeChild(oldChild);
		}
		if (isElementNode(newChild)) {
			this.documentElement = newChild;
		}
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},

	/**
	 * The `getElementsByClassName` method of `Document` interface returns an array-like object
	 * of all child elements which have **all** of the given class name(s).
	 *
	 * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
	 *
	 *
	 * Warning: This is a live LiveNodeList.
	 * Changes in the DOM will reflect in the array as the changes occur.
	 * If an element selected by this array no longer qualifies for the selector,
	 * it will automatically be removed. Be aware of this for iteration purposes.
	 *
	 * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
	 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
	 */
	getElementsByClassName: function(classNames) {
		var classNamesSet = toOrderedSet(classNames)
		return new LiveNodeList(this, function(base) {
			var ls = [];
			if (classNamesSet.length > 0) {
				_visitNode(base.documentElement, function(node) {
					if(node !== base && node.nodeType === ELEMENT_NODE) {
						var nodeClassNames = node.getAttribute('class')
						// can be null if the attribute does not exist
						if (nodeClassNames) {
							// before splitting and iterating just compare them for the most common case
							var matches = classNames === nodeClassNames;
							if (!matches) {
								var nodeClassNamesSet = toOrderedSet(nodeClassNames)
								matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet))
							}
							if(matches) {
								ls.push(node);
							}
						}
					}
				});
			}
			return ls;
		});
	},

	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.localName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.nodeName = node.target = target;
		node.nodeValue = node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},

	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},

	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},

	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;

		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);

	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9 && this.documentElement || this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;

	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}

function needNamespaceDefine(node, isHTML, visibleNamespaces) {
	var prefix = node.prefix || '';
	var uri = node.namespaceURI;
	// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
	// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
	// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
	// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
	// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
	// > [...] Furthermore, the attribute value [...] must not be an empty string.
	// so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
	if (!uri) {
		return false;
	}
	if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
		return false;
	}

	var i = visibleNamespaces.length
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		if (ns.prefix === prefix) {
			return ns.namespace !== uri;
		}
	}
	return true;
}
/**
 * Well-formed constraint: No < in Attribute Values
 * > The replacement text of any entity referred to directly or indirectly
 * > in an attribute value must not contain a <.
 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
 * @see https://www.w3.org/TR/xml11/#NT-AttValue
 *
 * Literal whitespace other than space that appear in attribute values
 * are serialized as their entity references, so they will be preserved.
 * (In contrast to whitespace literals in the input which are normalized to spaces)
 * @see https://www.w3.org/TR/xml11/#AVNormalize
 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
 */
function addSerializedAttribute(buf, qualifiedName, value) {
	buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"')
}

function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if (!visibleNamespaces) {
		visibleNamespaces = [];
	}

	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}

	switch(node.nodeType){
	case ELEMENT_NODE:
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;

		isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML

		var prefixedNodeName = nodeName
		if (!isHTML && !node.prefix && node.namespaceURI) {
			var defaultNS
			// lookup current default ns from `xmlns` attribute
			for (var ai = 0; ai < attrs.length; ai++) {
				if (attrs.item(ai).name === 'xmlns') {
					defaultNS = attrs.item(ai).value
					break
				}
			}
			if (!defaultNS) {
				// lookup current default ns in visibleNamespaces
				for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
					var namespace = visibleNamespaces[nsi]
					if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
						defaultNS = namespace.namespace
						break
					}
				}
			}
			if (defaultNS !== node.namespaceURI) {
				for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
					var namespace = visibleNamespaces[nsi]
					if (namespace.namespace === node.namespaceURI) {
						if (namespace.prefix) {
							prefixedNodeName = namespace.prefix + ':' + nodeName
						}
						break
					}
				}
			}
		}

		buf.push('<', prefixedNodeName);

		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}

		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}

		// add namespace for current node
		if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}

		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
					child = child.nextSibling;
				}
			}
			buf.push('</',prefixedNodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return addSerializedAttribute(buf, node.name, node.value);
	case TEXT_NODE:
		/**
		 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
		 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
		 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
		 * `&amp;` and `&lt;` respectively.
		 * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
		 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
		 * when that string is not marking the end of a CDATA section.
		 *
		 * In the content of elements, character data is any string of characters
		 * which does not contain the start-delimiter of any markup
		 * and does not include the CDATA-section-close delimiter, `]]>`.
		 *
		 * @see https://www.w3.org/TR/xml/#NT-CharData
		 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
		 */
		return buf.push(node.data
			.replace(/[<&>]/g,_xmlEncoder)
		);
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC ', pubid);
			if (sysid && sysid!='.') {
				buf.push(' ', sysid);
			}
			buf.push('>');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM ', sysid, '>');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for (var n in node) {
		if (Object.prototype.hasOwnProperty.call(node, n)) {
			var v = node[n];
			if (typeof v != "object") {
				if (v != node2[n]) {
					node2[n] = v;
				}
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});

		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},

			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;

				default:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})

		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}

		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DocumentType = DocumentType;
	exports.DOMException = DOMException;
	exports.DOMImplementation = DOMImplementation;
	exports.Element = Element;
	exports.Node = Node;
	exports.NodeList = NodeList;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/entities.js":
/*!*****************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/entities.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var freeze = (__webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js").freeze);

/**
 * The entities that are predefined in every XML document.
 *
 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
 */
exports.XML_ENTITIES = freeze({
	amp: '&',
	apos: "'",
	gt: '>',
	lt: '<',
	quot: '"',
});

/**
 * A map of all entities that are detected in an HTML document.
 * They contain all entries from `XML_ENTITIES`.
 *
 * @see XML_ENTITIES
 * @see DOMParser.parseFromString
 * @see DOMImplementation.prototype.createHTMLDocument
 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
 * @see https://html.spec.whatwg.org/entities.json JSON
 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
 */
exports.HTML_ENTITIES = freeze({
	Aacute: '\u00C1',
	aacute: '\u00E1',
	Abreve: '\u0102',
	abreve: '\u0103',
	ac: '\u223E',
	acd: '\u223F',
	acE: '\u223E\u0333',
	Acirc: '\u00C2',
	acirc: '\u00E2',
	acute: '\u00B4',
	Acy: '\u0410',
	acy: '\u0430',
	AElig: '\u00C6',
	aelig: '\u00E6',
	af: '\u2061',
	Afr: '\uD835\uDD04',
	afr: '\uD835\uDD1E',
	Agrave: '\u00C0',
	agrave: '\u00E0',
	alefsym: '\u2135',
	aleph: '\u2135',
	Alpha: '\u0391',
	alpha: '\u03B1',
	Amacr: '\u0100',
	amacr: '\u0101',
	amalg: '\u2A3F',
	AMP: '\u0026',
	amp: '\u0026',
	And: '\u2A53',
	and: '\u2227',
	andand: '\u2A55',
	andd: '\u2A5C',
	andslope: '\u2A58',
	andv: '\u2A5A',
	ang: '\u2220',
	ange: '\u29A4',
	angle: '\u2220',
	angmsd: '\u2221',
	angmsdaa: '\u29A8',
	angmsdab: '\u29A9',
	angmsdac: '\u29AA',
	angmsdad: '\u29AB',
	angmsdae: '\u29AC',
	angmsdaf: '\u29AD',
	angmsdag: '\u29AE',
	angmsdah: '\u29AF',
	angrt: '\u221F',
	angrtvb: '\u22BE',
	angrtvbd: '\u299D',
	angsph: '\u2222',
	angst: '\u00C5',
	angzarr: '\u237C',
	Aogon: '\u0104',
	aogon: '\u0105',
	Aopf: '\uD835\uDD38',
	aopf: '\uD835\uDD52',
	ap: '\u2248',
	apacir: '\u2A6F',
	apE: '\u2A70',
	ape: '\u224A',
	apid: '\u224B',
	apos: '\u0027',
	ApplyFunction: '\u2061',
	approx: '\u2248',
	approxeq: '\u224A',
	Aring: '\u00C5',
	aring: '\u00E5',
	Ascr: '\uD835\uDC9C',
	ascr: '\uD835\uDCB6',
	Assign: '\u2254',
	ast: '\u002A',
	asymp: '\u2248',
	asympeq: '\u224D',
	Atilde: '\u00C3',
	atilde: '\u00E3',
	Auml: '\u00C4',
	auml: '\u00E4',
	awconint: '\u2233',
	awint: '\u2A11',
	backcong: '\u224C',
	backepsilon: '\u03F6',
	backprime: '\u2035',
	backsim: '\u223D',
	backsimeq: '\u22CD',
	Backslash: '\u2216',
	Barv: '\u2AE7',
	barvee: '\u22BD',
	Barwed: '\u2306',
	barwed: '\u2305',
	barwedge: '\u2305',
	bbrk: '\u23B5',
	bbrktbrk: '\u23B6',
	bcong: '\u224C',
	Bcy: '\u0411',
	bcy: '\u0431',
	bdquo: '\u201E',
	becaus: '\u2235',
	Because: '\u2235',
	because: '\u2235',
	bemptyv: '\u29B0',
	bepsi: '\u03F6',
	bernou: '\u212C',
	Bernoullis: '\u212C',
	Beta: '\u0392',
	beta: '\u03B2',
	beth: '\u2136',
	between: '\u226C',
	Bfr: '\uD835\uDD05',
	bfr: '\uD835\uDD1F',
	bigcap: '\u22C2',
	bigcirc: '\u25EF',
	bigcup: '\u22C3',
	bigodot: '\u2A00',
	bigoplus: '\u2A01',
	bigotimes: '\u2A02',
	bigsqcup: '\u2A06',
	bigstar: '\u2605',
	bigtriangledown: '\u25BD',
	bigtriangleup: '\u25B3',
	biguplus: '\u2A04',
	bigvee: '\u22C1',
	bigwedge: '\u22C0',
	bkarow: '\u290D',
	blacklozenge: '\u29EB',
	blacksquare: '\u25AA',
	blacktriangle: '\u25B4',
	blacktriangledown: '\u25BE',
	blacktriangleleft: '\u25C2',
	blacktriangleright: '\u25B8',
	blank: '\u2423',
	blk12: '\u2592',
	blk14: '\u2591',
	blk34: '\u2593',
	block: '\u2588',
	bne: '\u003D\u20E5',
	bnequiv: '\u2261\u20E5',
	bNot: '\u2AED',
	bnot: '\u2310',
	Bopf: '\uD835\uDD39',
	bopf: '\uD835\uDD53',
	bot: '\u22A5',
	bottom: '\u22A5',
	bowtie: '\u22C8',
	boxbox: '\u29C9',
	boxDL: '\u2557',
	boxDl: '\u2556',
	boxdL: '\u2555',
	boxdl: '\u2510',
	boxDR: '\u2554',
	boxDr: '\u2553',
	boxdR: '\u2552',
	boxdr: '\u250C',
	boxH: '\u2550',
	boxh: '\u2500',
	boxHD: '\u2566',
	boxHd: '\u2564',
	boxhD: '\u2565',
	boxhd: '\u252C',
	boxHU: '\u2569',
	boxHu: '\u2567',
	boxhU: '\u2568',
	boxhu: '\u2534',
	boxminus: '\u229F',
	boxplus: '\u229E',
	boxtimes: '\u22A0',
	boxUL: '\u255D',
	boxUl: '\u255C',
	boxuL: '\u255B',
	boxul: '\u2518',
	boxUR: '\u255A',
	boxUr: '\u2559',
	boxuR: '\u2558',
	boxur: '\u2514',
	boxV: '\u2551',
	boxv: '\u2502',
	boxVH: '\u256C',
	boxVh: '\u256B',
	boxvH: '\u256A',
	boxvh: '\u253C',
	boxVL: '\u2563',
	boxVl: '\u2562',
	boxvL: '\u2561',
	boxvl: '\u2524',
	boxVR: '\u2560',
	boxVr: '\u255F',
	boxvR: '\u255E',
	boxvr: '\u251C',
	bprime: '\u2035',
	Breve: '\u02D8',
	breve: '\u02D8',
	brvbar: '\u00A6',
	Bscr: '\u212C',
	bscr: '\uD835\uDCB7',
	bsemi: '\u204F',
	bsim: '\u223D',
	bsime: '\u22CD',
	bsol: '\u005C',
	bsolb: '\u29C5',
	bsolhsub: '\u27C8',
	bull: '\u2022',
	bullet: '\u2022',
	bump: '\u224E',
	bumpE: '\u2AAE',
	bumpe: '\u224F',
	Bumpeq: '\u224E',
	bumpeq: '\u224F',
	Cacute: '\u0106',
	cacute: '\u0107',
	Cap: '\u22D2',
	cap: '\u2229',
	capand: '\u2A44',
	capbrcup: '\u2A49',
	capcap: '\u2A4B',
	capcup: '\u2A47',
	capdot: '\u2A40',
	CapitalDifferentialD: '\u2145',
	caps: '\u2229\uFE00',
	caret: '\u2041',
	caron: '\u02C7',
	Cayleys: '\u212D',
	ccaps: '\u2A4D',
	Ccaron: '\u010C',
	ccaron: '\u010D',
	Ccedil: '\u00C7',
	ccedil: '\u00E7',
	Ccirc: '\u0108',
	ccirc: '\u0109',
	Cconint: '\u2230',
	ccups: '\u2A4C',
	ccupssm: '\u2A50',
	Cdot: '\u010A',
	cdot: '\u010B',
	cedil: '\u00B8',
	Cedilla: '\u00B8',
	cemptyv: '\u29B2',
	cent: '\u00A2',
	CenterDot: '\u00B7',
	centerdot: '\u00B7',
	Cfr: '\u212D',
	cfr: '\uD835\uDD20',
	CHcy: '\u0427',
	chcy: '\u0447',
	check: '\u2713',
	checkmark: '\u2713',
	Chi: '\u03A7',
	chi: '\u03C7',
	cir: '\u25CB',
	circ: '\u02C6',
	circeq: '\u2257',
	circlearrowleft: '\u21BA',
	circlearrowright: '\u21BB',
	circledast: '\u229B',
	circledcirc: '\u229A',
	circleddash: '\u229D',
	CircleDot: '\u2299',
	circledR: '\u00AE',
	circledS: '\u24C8',
	CircleMinus: '\u2296',
	CirclePlus: '\u2295',
	CircleTimes: '\u2297',
	cirE: '\u29C3',
	cire: '\u2257',
	cirfnint: '\u2A10',
	cirmid: '\u2AEF',
	cirscir: '\u29C2',
	ClockwiseContourIntegral: '\u2232',
	CloseCurlyDoubleQuote: '\u201D',
	CloseCurlyQuote: '\u2019',
	clubs: '\u2663',
	clubsuit: '\u2663',
	Colon: '\u2237',
	colon: '\u003A',
	Colone: '\u2A74',
	colone: '\u2254',
	coloneq: '\u2254',
	comma: '\u002C',
	commat: '\u0040',
	comp: '\u2201',
	compfn: '\u2218',
	complement: '\u2201',
	complexes: '\u2102',
	cong: '\u2245',
	congdot: '\u2A6D',
	Congruent: '\u2261',
	Conint: '\u222F',
	conint: '\u222E',
	ContourIntegral: '\u222E',
	Copf: '\u2102',
	copf: '\uD835\uDD54',
	coprod: '\u2210',
	Coproduct: '\u2210',
	COPY: '\u00A9',
	copy: '\u00A9',
	copysr: '\u2117',
	CounterClockwiseContourIntegral: '\u2233',
	crarr: '\u21B5',
	Cross: '\u2A2F',
	cross: '\u2717',
	Cscr: '\uD835\uDC9E',
	cscr: '\uD835\uDCB8',
	csub: '\u2ACF',
	csube: '\u2AD1',
	csup: '\u2AD0',
	csupe: '\u2AD2',
	ctdot: '\u22EF',
	cudarrl: '\u2938',
	cudarrr: '\u2935',
	cuepr: '\u22DE',
	cuesc: '\u22DF',
	cularr: '\u21B6',
	cularrp: '\u293D',
	Cup: '\u22D3',
	cup: '\u222A',
	cupbrcap: '\u2A48',
	CupCap: '\u224D',
	cupcap: '\u2A46',
	cupcup: '\u2A4A',
	cupdot: '\u228D',
	cupor: '\u2A45',
	cups: '\u222A\uFE00',
	curarr: '\u21B7',
	curarrm: '\u293C',
	curlyeqprec: '\u22DE',
	curlyeqsucc: '\u22DF',
	curlyvee: '\u22CE',
	curlywedge: '\u22CF',
	curren: '\u00A4',
	curvearrowleft: '\u21B6',
	curvearrowright: '\u21B7',
	cuvee: '\u22CE',
	cuwed: '\u22CF',
	cwconint: '\u2232',
	cwint: '\u2231',
	cylcty: '\u232D',
	Dagger: '\u2021',
	dagger: '\u2020',
	daleth: '\u2138',
	Darr: '\u21A1',
	dArr: '\u21D3',
	darr: '\u2193',
	dash: '\u2010',
	Dashv: '\u2AE4',
	dashv: '\u22A3',
	dbkarow: '\u290F',
	dblac: '\u02DD',
	Dcaron: '\u010E',
	dcaron: '\u010F',
	Dcy: '\u0414',
	dcy: '\u0434',
	DD: '\u2145',
	dd: '\u2146',
	ddagger: '\u2021',
	ddarr: '\u21CA',
	DDotrahd: '\u2911',
	ddotseq: '\u2A77',
	deg: '\u00B0',
	Del: '\u2207',
	Delta: '\u0394',
	delta: '\u03B4',
	demptyv: '\u29B1',
	dfisht: '\u297F',
	Dfr: '\uD835\uDD07',
	dfr: '\uD835\uDD21',
	dHar: '\u2965',
	dharl: '\u21C3',
	dharr: '\u21C2',
	DiacriticalAcute: '\u00B4',
	DiacriticalDot: '\u02D9',
	DiacriticalDoubleAcute: '\u02DD',
	DiacriticalGrave: '\u0060',
	DiacriticalTilde: '\u02DC',
	diam: '\u22C4',
	Diamond: '\u22C4',
	diamond: '\u22C4',
	diamondsuit: '\u2666',
	diams: '\u2666',
	die: '\u00A8',
	DifferentialD: '\u2146',
	digamma: '\u03DD',
	disin: '\u22F2',
	div: '\u00F7',
	divide: '\u00F7',
	divideontimes: '\u22C7',
	divonx: '\u22C7',
	DJcy: '\u0402',
	djcy: '\u0452',
	dlcorn: '\u231E',
	dlcrop: '\u230D',
	dollar: '\u0024',
	Dopf: '\uD835\uDD3B',
	dopf: '\uD835\uDD55',
	Dot: '\u00A8',
	dot: '\u02D9',
	DotDot: '\u20DC',
	doteq: '\u2250',
	doteqdot: '\u2251',
	DotEqual: '\u2250',
	dotminus: '\u2238',
	dotplus: '\u2214',
	dotsquare: '\u22A1',
	doublebarwedge: '\u2306',
	DoubleContourIntegral: '\u222F',
	DoubleDot: '\u00A8',
	DoubleDownArrow: '\u21D3',
	DoubleLeftArrow: '\u21D0',
	DoubleLeftRightArrow: '\u21D4',
	DoubleLeftTee: '\u2AE4',
	DoubleLongLeftArrow: '\u27F8',
	DoubleLongLeftRightArrow: '\u27FA',
	DoubleLongRightArrow: '\u27F9',
	DoubleRightArrow: '\u21D2',
	DoubleRightTee: '\u22A8',
	DoubleUpArrow: '\u21D1',
	DoubleUpDownArrow: '\u21D5',
	DoubleVerticalBar: '\u2225',
	DownArrow: '\u2193',
	Downarrow: '\u21D3',
	downarrow: '\u2193',
	DownArrowBar: '\u2913',
	DownArrowUpArrow: '\u21F5',
	DownBreve: '\u0311',
	downdownarrows: '\u21CA',
	downharpoonleft: '\u21C3',
	downharpoonright: '\u21C2',
	DownLeftRightVector: '\u2950',
	DownLeftTeeVector: '\u295E',
	DownLeftVector: '\u21BD',
	DownLeftVectorBar: '\u2956',
	DownRightTeeVector: '\u295F',
	DownRightVector: '\u21C1',
	DownRightVectorBar: '\u2957',
	DownTee: '\u22A4',
	DownTeeArrow: '\u21A7',
	drbkarow: '\u2910',
	drcorn: '\u231F',
	drcrop: '\u230C',
	Dscr: '\uD835\uDC9F',
	dscr: '\uD835\uDCB9',
	DScy: '\u0405',
	dscy: '\u0455',
	dsol: '\u29F6',
	Dstrok: '\u0110',
	dstrok: '\u0111',
	dtdot: '\u22F1',
	dtri: '\u25BF',
	dtrif: '\u25BE',
	duarr: '\u21F5',
	duhar: '\u296F',
	dwangle: '\u29A6',
	DZcy: '\u040F',
	dzcy: '\u045F',
	dzigrarr: '\u27FF',
	Eacute: '\u00C9',
	eacute: '\u00E9',
	easter: '\u2A6E',
	Ecaron: '\u011A',
	ecaron: '\u011B',
	ecir: '\u2256',
	Ecirc: '\u00CA',
	ecirc: '\u00EA',
	ecolon: '\u2255',
	Ecy: '\u042D',
	ecy: '\u044D',
	eDDot: '\u2A77',
	Edot: '\u0116',
	eDot: '\u2251',
	edot: '\u0117',
	ee: '\u2147',
	efDot: '\u2252',
	Efr: '\uD835\uDD08',
	efr: '\uD835\uDD22',
	eg: '\u2A9A',
	Egrave: '\u00C8',
	egrave: '\u00E8',
	egs: '\u2A96',
	egsdot: '\u2A98',
	el: '\u2A99',
	Element: '\u2208',
	elinters: '\u23E7',
	ell: '\u2113',
	els: '\u2A95',
	elsdot: '\u2A97',
	Emacr: '\u0112',
	emacr: '\u0113',
	empty: '\u2205',
	emptyset: '\u2205',
	EmptySmallSquare: '\u25FB',
	emptyv: '\u2205',
	EmptyVerySmallSquare: '\u25AB',
	emsp: '\u2003',
	emsp13: '\u2004',
	emsp14: '\u2005',
	ENG: '\u014A',
	eng: '\u014B',
	ensp: '\u2002',
	Eogon: '\u0118',
	eogon: '\u0119',
	Eopf: '\uD835\uDD3C',
	eopf: '\uD835\uDD56',
	epar: '\u22D5',
	eparsl: '\u29E3',
	eplus: '\u2A71',
	epsi: '\u03B5',
	Epsilon: '\u0395',
	epsilon: '\u03B5',
	epsiv: '\u03F5',
	eqcirc: '\u2256',
	eqcolon: '\u2255',
	eqsim: '\u2242',
	eqslantgtr: '\u2A96',
	eqslantless: '\u2A95',
	Equal: '\u2A75',
	equals: '\u003D',
	EqualTilde: '\u2242',
	equest: '\u225F',
	Equilibrium: '\u21CC',
	equiv: '\u2261',
	equivDD: '\u2A78',
	eqvparsl: '\u29E5',
	erarr: '\u2971',
	erDot: '\u2253',
	Escr: '\u2130',
	escr: '\u212F',
	esdot: '\u2250',
	Esim: '\u2A73',
	esim: '\u2242',
	Eta: '\u0397',
	eta: '\u03B7',
	ETH: '\u00D0',
	eth: '\u00F0',
	Euml: '\u00CB',
	euml: '\u00EB',
	euro: '\u20AC',
	excl: '\u0021',
	exist: '\u2203',
	Exists: '\u2203',
	expectation: '\u2130',
	ExponentialE: '\u2147',
	exponentiale: '\u2147',
	fallingdotseq: '\u2252',
	Fcy: '\u0424',
	fcy: '\u0444',
	female: '\u2640',
	ffilig: '\uFB03',
	fflig: '\uFB00',
	ffllig: '\uFB04',
	Ffr: '\uD835\uDD09',
	ffr: '\uD835\uDD23',
	filig: '\uFB01',
	FilledSmallSquare: '\u25FC',
	FilledVerySmallSquare: '\u25AA',
	fjlig: '\u0066\u006A',
	flat: '\u266D',
	fllig: '\uFB02',
	fltns: '\u25B1',
	fnof: '\u0192',
	Fopf: '\uD835\uDD3D',
	fopf: '\uD835\uDD57',
	ForAll: '\u2200',
	forall: '\u2200',
	fork: '\u22D4',
	forkv: '\u2AD9',
	Fouriertrf: '\u2131',
	fpartint: '\u2A0D',
	frac12: '\u00BD',
	frac13: '\u2153',
	frac14: '\u00BC',
	frac15: '\u2155',
	frac16: '\u2159',
	frac18: '\u215B',
	frac23: '\u2154',
	frac25: '\u2156',
	frac34: '\u00BE',
	frac35: '\u2157',
	frac38: '\u215C',
	frac45: '\u2158',
	frac56: '\u215A',
	frac58: '\u215D',
	frac78: '\u215E',
	frasl: '\u2044',
	frown: '\u2322',
	Fscr: '\u2131',
	fscr: '\uD835\uDCBB',
	gacute: '\u01F5',
	Gamma: '\u0393',
	gamma: '\u03B3',
	Gammad: '\u03DC',
	gammad: '\u03DD',
	gap: '\u2A86',
	Gbreve: '\u011E',
	gbreve: '\u011F',
	Gcedil: '\u0122',
	Gcirc: '\u011C',
	gcirc: '\u011D',
	Gcy: '\u0413',
	gcy: '\u0433',
	Gdot: '\u0120',
	gdot: '\u0121',
	gE: '\u2267',
	ge: '\u2265',
	gEl: '\u2A8C',
	gel: '\u22DB',
	geq: '\u2265',
	geqq: '\u2267',
	geqslant: '\u2A7E',
	ges: '\u2A7E',
	gescc: '\u2AA9',
	gesdot: '\u2A80',
	gesdoto: '\u2A82',
	gesdotol: '\u2A84',
	gesl: '\u22DB\uFE00',
	gesles: '\u2A94',
	Gfr: '\uD835\uDD0A',
	gfr: '\uD835\uDD24',
	Gg: '\u22D9',
	gg: '\u226B',
	ggg: '\u22D9',
	gimel: '\u2137',
	GJcy: '\u0403',
	gjcy: '\u0453',
	gl: '\u2277',
	gla: '\u2AA5',
	glE: '\u2A92',
	glj: '\u2AA4',
	gnap: '\u2A8A',
	gnapprox: '\u2A8A',
	gnE: '\u2269',
	gne: '\u2A88',
	gneq: '\u2A88',
	gneqq: '\u2269',
	gnsim: '\u22E7',
	Gopf: '\uD835\uDD3E',
	gopf: '\uD835\uDD58',
	grave: '\u0060',
	GreaterEqual: '\u2265',
	GreaterEqualLess: '\u22DB',
	GreaterFullEqual: '\u2267',
	GreaterGreater: '\u2AA2',
	GreaterLess: '\u2277',
	GreaterSlantEqual: '\u2A7E',
	GreaterTilde: '\u2273',
	Gscr: '\uD835\uDCA2',
	gscr: '\u210A',
	gsim: '\u2273',
	gsime: '\u2A8E',
	gsiml: '\u2A90',
	Gt: '\u226B',
	GT: '\u003E',
	gt: '\u003E',
	gtcc: '\u2AA7',
	gtcir: '\u2A7A',
	gtdot: '\u22D7',
	gtlPar: '\u2995',
	gtquest: '\u2A7C',
	gtrapprox: '\u2A86',
	gtrarr: '\u2978',
	gtrdot: '\u22D7',
	gtreqless: '\u22DB',
	gtreqqless: '\u2A8C',
	gtrless: '\u2277',
	gtrsim: '\u2273',
	gvertneqq: '\u2269\uFE00',
	gvnE: '\u2269\uFE00',
	Hacek: '\u02C7',
	hairsp: '\u200A',
	half: '\u00BD',
	hamilt: '\u210B',
	HARDcy: '\u042A',
	hardcy: '\u044A',
	hArr: '\u21D4',
	harr: '\u2194',
	harrcir: '\u2948',
	harrw: '\u21AD',
	Hat: '\u005E',
	hbar: '\u210F',
	Hcirc: '\u0124',
	hcirc: '\u0125',
	hearts: '\u2665',
	heartsuit: '\u2665',
	hellip: '\u2026',
	hercon: '\u22B9',
	Hfr: '\u210C',
	hfr: '\uD835\uDD25',
	HilbertSpace: '\u210B',
	hksearow: '\u2925',
	hkswarow: '\u2926',
	hoarr: '\u21FF',
	homtht: '\u223B',
	hookleftarrow: '\u21A9',
	hookrightarrow: '\u21AA',
	Hopf: '\u210D',
	hopf: '\uD835\uDD59',
	horbar: '\u2015',
	HorizontalLine: '\u2500',
	Hscr: '\u210B',
	hscr: '\uD835\uDCBD',
	hslash: '\u210F',
	Hstrok: '\u0126',
	hstrok: '\u0127',
	HumpDownHump: '\u224E',
	HumpEqual: '\u224F',
	hybull: '\u2043',
	hyphen: '\u2010',
	Iacute: '\u00CD',
	iacute: '\u00ED',
	ic: '\u2063',
	Icirc: '\u00CE',
	icirc: '\u00EE',
	Icy: '\u0418',
	icy: '\u0438',
	Idot: '\u0130',
	IEcy: '\u0415',
	iecy: '\u0435',
	iexcl: '\u00A1',
	iff: '\u21D4',
	Ifr: '\u2111',
	ifr: '\uD835\uDD26',
	Igrave: '\u00CC',
	igrave: '\u00EC',
	ii: '\u2148',
	iiiint: '\u2A0C',
	iiint: '\u222D',
	iinfin: '\u29DC',
	iiota: '\u2129',
	IJlig: '\u0132',
	ijlig: '\u0133',
	Im: '\u2111',
	Imacr: '\u012A',
	imacr: '\u012B',
	image: '\u2111',
	ImaginaryI: '\u2148',
	imagline: '\u2110',
	imagpart: '\u2111',
	imath: '\u0131',
	imof: '\u22B7',
	imped: '\u01B5',
	Implies: '\u21D2',
	in: '\u2208',
	incare: '\u2105',
	infin: '\u221E',
	infintie: '\u29DD',
	inodot: '\u0131',
	Int: '\u222C',
	int: '\u222B',
	intcal: '\u22BA',
	integers: '\u2124',
	Integral: '\u222B',
	intercal: '\u22BA',
	Intersection: '\u22C2',
	intlarhk: '\u2A17',
	intprod: '\u2A3C',
	InvisibleComma: '\u2063',
	InvisibleTimes: '\u2062',
	IOcy: '\u0401',
	iocy: '\u0451',
	Iogon: '\u012E',
	iogon: '\u012F',
	Iopf: '\uD835\uDD40',
	iopf: '\uD835\uDD5A',
	Iota: '\u0399',
	iota: '\u03B9',
	iprod: '\u2A3C',
	iquest: '\u00BF',
	Iscr: '\u2110',
	iscr: '\uD835\uDCBE',
	isin: '\u2208',
	isindot: '\u22F5',
	isinE: '\u22F9',
	isins: '\u22F4',
	isinsv: '\u22F3',
	isinv: '\u2208',
	it: '\u2062',
	Itilde: '\u0128',
	itilde: '\u0129',
	Iukcy: '\u0406',
	iukcy: '\u0456',
	Iuml: '\u00CF',
	iuml: '\u00EF',
	Jcirc: '\u0134',
	jcirc: '\u0135',
	Jcy: '\u0419',
	jcy: '\u0439',
	Jfr: '\uD835\uDD0D',
	jfr: '\uD835\uDD27',
	jmath: '\u0237',
	Jopf: '\uD835\uDD41',
	jopf: '\uD835\uDD5B',
	Jscr: '\uD835\uDCA5',
	jscr: '\uD835\uDCBF',
	Jsercy: '\u0408',
	jsercy: '\u0458',
	Jukcy: '\u0404',
	jukcy: '\u0454',
	Kappa: '\u039A',
	kappa: '\u03BA',
	kappav: '\u03F0',
	Kcedil: '\u0136',
	kcedil: '\u0137',
	Kcy: '\u041A',
	kcy: '\u043A',
	Kfr: '\uD835\uDD0E',
	kfr: '\uD835\uDD28',
	kgreen: '\u0138',
	KHcy: '\u0425',
	khcy: '\u0445',
	KJcy: '\u040C',
	kjcy: '\u045C',
	Kopf: '\uD835\uDD42',
	kopf: '\uD835\uDD5C',
	Kscr: '\uD835\uDCA6',
	kscr: '\uD835\uDCC0',
	lAarr: '\u21DA',
	Lacute: '\u0139',
	lacute: '\u013A',
	laemptyv: '\u29B4',
	lagran: '\u2112',
	Lambda: '\u039B',
	lambda: '\u03BB',
	Lang: '\u27EA',
	lang: '\u27E8',
	langd: '\u2991',
	langle: '\u27E8',
	lap: '\u2A85',
	Laplacetrf: '\u2112',
	laquo: '\u00AB',
	Larr: '\u219E',
	lArr: '\u21D0',
	larr: '\u2190',
	larrb: '\u21E4',
	larrbfs: '\u291F',
	larrfs: '\u291D',
	larrhk: '\u21A9',
	larrlp: '\u21AB',
	larrpl: '\u2939',
	larrsim: '\u2973',
	larrtl: '\u21A2',
	lat: '\u2AAB',
	lAtail: '\u291B',
	latail: '\u2919',
	late: '\u2AAD',
	lates: '\u2AAD\uFE00',
	lBarr: '\u290E',
	lbarr: '\u290C',
	lbbrk: '\u2772',
	lbrace: '\u007B',
	lbrack: '\u005B',
	lbrke: '\u298B',
	lbrksld: '\u298F',
	lbrkslu: '\u298D',
	Lcaron: '\u013D',
	lcaron: '\u013E',
	Lcedil: '\u013B',
	lcedil: '\u013C',
	lceil: '\u2308',
	lcub: '\u007B',
	Lcy: '\u041B',
	lcy: '\u043B',
	ldca: '\u2936',
	ldquo: '\u201C',
	ldquor: '\u201E',
	ldrdhar: '\u2967',
	ldrushar: '\u294B',
	ldsh: '\u21B2',
	lE: '\u2266',
	le: '\u2264',
	LeftAngleBracket: '\u27E8',
	LeftArrow: '\u2190',
	Leftarrow: '\u21D0',
	leftarrow: '\u2190',
	LeftArrowBar: '\u21E4',
	LeftArrowRightArrow: '\u21C6',
	leftarrowtail: '\u21A2',
	LeftCeiling: '\u2308',
	LeftDoubleBracket: '\u27E6',
	LeftDownTeeVector: '\u2961',
	LeftDownVector: '\u21C3',
	LeftDownVectorBar: '\u2959',
	LeftFloor: '\u230A',
	leftharpoondown: '\u21BD',
	leftharpoonup: '\u21BC',
	leftleftarrows: '\u21C7',
	LeftRightArrow: '\u2194',
	Leftrightarrow: '\u21D4',
	leftrightarrow: '\u2194',
	leftrightarrows: '\u21C6',
	leftrightharpoons: '\u21CB',
	leftrightsquigarrow: '\u21AD',
	LeftRightVector: '\u294E',
	LeftTee: '\u22A3',
	LeftTeeArrow: '\u21A4',
	LeftTeeVector: '\u295A',
	leftthreetimes: '\u22CB',
	LeftTriangle: '\u22B2',
	LeftTriangleBar: '\u29CF',
	LeftTriangleEqual: '\u22B4',
	LeftUpDownVector: '\u2951',
	LeftUpTeeVector: '\u2960',
	LeftUpVector: '\u21BF',
	LeftUpVectorBar: '\u2958',
	LeftVector: '\u21BC',
	LeftVectorBar: '\u2952',
	lEg: '\u2A8B',
	leg: '\u22DA',
	leq: '\u2264',
	leqq: '\u2266',
	leqslant: '\u2A7D',
	les: '\u2A7D',
	lescc: '\u2AA8',
	lesdot: '\u2A7F',
	lesdoto: '\u2A81',
	lesdotor: '\u2A83',
	lesg: '\u22DA\uFE00',
	lesges: '\u2A93',
	lessapprox: '\u2A85',
	lessdot: '\u22D6',
	lesseqgtr: '\u22DA',
	lesseqqgtr: '\u2A8B',
	LessEqualGreater: '\u22DA',
	LessFullEqual: '\u2266',
	LessGreater: '\u2276',
	lessgtr: '\u2276',
	LessLess: '\u2AA1',
	lesssim: '\u2272',
	LessSlantEqual: '\u2A7D',
	LessTilde: '\u2272',
	lfisht: '\u297C',
	lfloor: '\u230A',
	Lfr: '\uD835\uDD0F',
	lfr: '\uD835\uDD29',
	lg: '\u2276',
	lgE: '\u2A91',
	lHar: '\u2962',
	lhard: '\u21BD',
	lharu: '\u21BC',
	lharul: '\u296A',
	lhblk: '\u2584',
	LJcy: '\u0409',
	ljcy: '\u0459',
	Ll: '\u22D8',
	ll: '\u226A',
	llarr: '\u21C7',
	llcorner: '\u231E',
	Lleftarrow: '\u21DA',
	llhard: '\u296B',
	lltri: '\u25FA',
	Lmidot: '\u013F',
	lmidot: '\u0140',
	lmoust: '\u23B0',
	lmoustache: '\u23B0',
	lnap: '\u2A89',
	lnapprox: '\u2A89',
	lnE: '\u2268',
	lne: '\u2A87',
	lneq: '\u2A87',
	lneqq: '\u2268',
	lnsim: '\u22E6',
	loang: '\u27EC',
	loarr: '\u21FD',
	lobrk: '\u27E6',
	LongLeftArrow: '\u27F5',
	Longleftarrow: '\u27F8',
	longleftarrow: '\u27F5',
	LongLeftRightArrow: '\u27F7',
	Longleftrightarrow: '\u27FA',
	longleftrightarrow: '\u27F7',
	longmapsto: '\u27FC',
	LongRightArrow: '\u27F6',
	Longrightarrow: '\u27F9',
	longrightarrow: '\u27F6',
	looparrowleft: '\u21AB',
	looparrowright: '\u21AC',
	lopar: '\u2985',
	Lopf: '\uD835\uDD43',
	lopf: '\uD835\uDD5D',
	loplus: '\u2A2D',
	lotimes: '\u2A34',
	lowast: '\u2217',
	lowbar: '\u005F',
	LowerLeftArrow: '\u2199',
	LowerRightArrow: '\u2198',
	loz: '\u25CA',
	lozenge: '\u25CA',
	lozf: '\u29EB',
	lpar: '\u0028',
	lparlt: '\u2993',
	lrarr: '\u21C6',
	lrcorner: '\u231F',
	lrhar: '\u21CB',
	lrhard: '\u296D',
	lrm: '\u200E',
	lrtri: '\u22BF',
	lsaquo: '\u2039',
	Lscr: '\u2112',
	lscr: '\uD835\uDCC1',
	Lsh: '\u21B0',
	lsh: '\u21B0',
	lsim: '\u2272',
	lsime: '\u2A8D',
	lsimg: '\u2A8F',
	lsqb: '\u005B',
	lsquo: '\u2018',
	lsquor: '\u201A',
	Lstrok: '\u0141',
	lstrok: '\u0142',
	Lt: '\u226A',
	LT: '\u003C',
	lt: '\u003C',
	ltcc: '\u2AA6',
	ltcir: '\u2A79',
	ltdot: '\u22D6',
	lthree: '\u22CB',
	ltimes: '\u22C9',
	ltlarr: '\u2976',
	ltquest: '\u2A7B',
	ltri: '\u25C3',
	ltrie: '\u22B4',
	ltrif: '\u25C2',
	ltrPar: '\u2996',
	lurdshar: '\u294A',
	luruhar: '\u2966',
	lvertneqq: '\u2268\uFE00',
	lvnE: '\u2268\uFE00',
	macr: '\u00AF',
	male: '\u2642',
	malt: '\u2720',
	maltese: '\u2720',
	Map: '\u2905',
	map: '\u21A6',
	mapsto: '\u21A6',
	mapstodown: '\u21A7',
	mapstoleft: '\u21A4',
	mapstoup: '\u21A5',
	marker: '\u25AE',
	mcomma: '\u2A29',
	Mcy: '\u041C',
	mcy: '\u043C',
	mdash: '\u2014',
	mDDot: '\u223A',
	measuredangle: '\u2221',
	MediumSpace: '\u205F',
	Mellintrf: '\u2133',
	Mfr: '\uD835\uDD10',
	mfr: '\uD835\uDD2A',
	mho: '\u2127',
	micro: '\u00B5',
	mid: '\u2223',
	midast: '\u002A',
	midcir: '\u2AF0',
	middot: '\u00B7',
	minus: '\u2212',
	minusb: '\u229F',
	minusd: '\u2238',
	minusdu: '\u2A2A',
	MinusPlus: '\u2213',
	mlcp: '\u2ADB',
	mldr: '\u2026',
	mnplus: '\u2213',
	models: '\u22A7',
	Mopf: '\uD835\uDD44',
	mopf: '\uD835\uDD5E',
	mp: '\u2213',
	Mscr: '\u2133',
	mscr: '\uD835\uDCC2',
	mstpos: '\u223E',
	Mu: '\u039C',
	mu: '\u03BC',
	multimap: '\u22B8',
	mumap: '\u22B8',
	nabla: '\u2207',
	Nacute: '\u0143',
	nacute: '\u0144',
	nang: '\u2220\u20D2',
	nap: '\u2249',
	napE: '\u2A70\u0338',
	napid: '\u224B\u0338',
	napos: '\u0149',
	napprox: '\u2249',
	natur: '\u266E',
	natural: '\u266E',
	naturals: '\u2115',
	nbsp: '\u00A0',
	nbump: '\u224E\u0338',
	nbumpe: '\u224F\u0338',
	ncap: '\u2A43',
	Ncaron: '\u0147',
	ncaron: '\u0148',
	Ncedil: '\u0145',
	ncedil: '\u0146',
	ncong: '\u2247',
	ncongdot: '\u2A6D\u0338',
	ncup: '\u2A42',
	Ncy: '\u041D',
	ncy: '\u043D',
	ndash: '\u2013',
	ne: '\u2260',
	nearhk: '\u2924',
	neArr: '\u21D7',
	nearr: '\u2197',
	nearrow: '\u2197',
	nedot: '\u2250\u0338',
	NegativeMediumSpace: '\u200B',
	NegativeThickSpace: '\u200B',
	NegativeThinSpace: '\u200B',
	NegativeVeryThinSpace: '\u200B',
	nequiv: '\u2262',
	nesear: '\u2928',
	nesim: '\u2242\u0338',
	NestedGreaterGreater: '\u226B',
	NestedLessLess: '\u226A',
	NewLine: '\u000A',
	nexist: '\u2204',
	nexists: '\u2204',
	Nfr: '\uD835\uDD11',
	nfr: '\uD835\uDD2B',
	ngE: '\u2267\u0338',
	nge: '\u2271',
	ngeq: '\u2271',
	ngeqq: '\u2267\u0338',
	ngeqslant: '\u2A7E\u0338',
	nges: '\u2A7E\u0338',
	nGg: '\u22D9\u0338',
	ngsim: '\u2275',
	nGt: '\u226B\u20D2',
	ngt: '\u226F',
	ngtr: '\u226F',
	nGtv: '\u226B\u0338',
	nhArr: '\u21CE',
	nharr: '\u21AE',
	nhpar: '\u2AF2',
	ni: '\u220B',
	nis: '\u22FC',
	nisd: '\u22FA',
	niv: '\u220B',
	NJcy: '\u040A',
	njcy: '\u045A',
	nlArr: '\u21CD',
	nlarr: '\u219A',
	nldr: '\u2025',
	nlE: '\u2266\u0338',
	nle: '\u2270',
	nLeftarrow: '\u21CD',
	nleftarrow: '\u219A',
	nLeftrightarrow: '\u21CE',
	nleftrightarrow: '\u21AE',
	nleq: '\u2270',
	nleqq: '\u2266\u0338',
	nleqslant: '\u2A7D\u0338',
	nles: '\u2A7D\u0338',
	nless: '\u226E',
	nLl: '\u22D8\u0338',
	nlsim: '\u2274',
	nLt: '\u226A\u20D2',
	nlt: '\u226E',
	nltri: '\u22EA',
	nltrie: '\u22EC',
	nLtv: '\u226A\u0338',
	nmid: '\u2224',
	NoBreak: '\u2060',
	NonBreakingSpace: '\u00A0',
	Nopf: '\u2115',
	nopf: '\uD835\uDD5F',
	Not: '\u2AEC',
	not: '\u00AC',
	NotCongruent: '\u2262',
	NotCupCap: '\u226D',
	NotDoubleVerticalBar: '\u2226',
	NotElement: '\u2209',
	NotEqual: '\u2260',
	NotEqualTilde: '\u2242\u0338',
	NotExists: '\u2204',
	NotGreater: '\u226F',
	NotGreaterEqual: '\u2271',
	NotGreaterFullEqual: '\u2267\u0338',
	NotGreaterGreater: '\u226B\u0338',
	NotGreaterLess: '\u2279',
	NotGreaterSlantEqual: '\u2A7E\u0338',
	NotGreaterTilde: '\u2275',
	NotHumpDownHump: '\u224E\u0338',
	NotHumpEqual: '\u224F\u0338',
	notin: '\u2209',
	notindot: '\u22F5\u0338',
	notinE: '\u22F9\u0338',
	notinva: '\u2209',
	notinvb: '\u22F7',
	notinvc: '\u22F6',
	NotLeftTriangle: '\u22EA',
	NotLeftTriangleBar: '\u29CF\u0338',
	NotLeftTriangleEqual: '\u22EC',
	NotLess: '\u226E',
	NotLessEqual: '\u2270',
	NotLessGreater: '\u2278',
	NotLessLess: '\u226A\u0338',
	NotLessSlantEqual: '\u2A7D\u0338',
	NotLessTilde: '\u2274',
	NotNestedGreaterGreater: '\u2AA2\u0338',
	NotNestedLessLess: '\u2AA1\u0338',
	notni: '\u220C',
	notniva: '\u220C',
	notnivb: '\u22FE',
	notnivc: '\u22FD',
	NotPrecedes: '\u2280',
	NotPrecedesEqual: '\u2AAF\u0338',
	NotPrecedesSlantEqual: '\u22E0',
	NotReverseElement: '\u220C',
	NotRightTriangle: '\u22EB',
	NotRightTriangleBar: '\u29D0\u0338',
	NotRightTriangleEqual: '\u22ED',
	NotSquareSubset: '\u228F\u0338',
	NotSquareSubsetEqual: '\u22E2',
	NotSquareSuperset: '\u2290\u0338',
	NotSquareSupersetEqual: '\u22E3',
	NotSubset: '\u2282\u20D2',
	NotSubsetEqual: '\u2288',
	NotSucceeds: '\u2281',
	NotSucceedsEqual: '\u2AB0\u0338',
	NotSucceedsSlantEqual: '\u22E1',
	NotSucceedsTilde: '\u227F\u0338',
	NotSuperset: '\u2283\u20D2',
	NotSupersetEqual: '\u2289',
	NotTilde: '\u2241',
	NotTildeEqual: '\u2244',
	NotTildeFullEqual: '\u2247',
	NotTildeTilde: '\u2249',
	NotVerticalBar: '\u2224',
	npar: '\u2226',
	nparallel: '\u2226',
	nparsl: '\u2AFD\u20E5',
	npart: '\u2202\u0338',
	npolint: '\u2A14',
	npr: '\u2280',
	nprcue: '\u22E0',
	npre: '\u2AAF\u0338',
	nprec: '\u2280',
	npreceq: '\u2AAF\u0338',
	nrArr: '\u21CF',
	nrarr: '\u219B',
	nrarrc: '\u2933\u0338',
	nrarrw: '\u219D\u0338',
	nRightarrow: '\u21CF',
	nrightarrow: '\u219B',
	nrtri: '\u22EB',
	nrtrie: '\u22ED',
	nsc: '\u2281',
	nsccue: '\u22E1',
	nsce: '\u2AB0\u0338',
	Nscr: '\uD835\uDCA9',
	nscr: '\uD835\uDCC3',
	nshortmid: '\u2224',
	nshortparallel: '\u2226',
	nsim: '\u2241',
	nsime: '\u2244',
	nsimeq: '\u2244',
	nsmid: '\u2224',
	nspar: '\u2226',
	nsqsube: '\u22E2',
	nsqsupe: '\u22E3',
	nsub: '\u2284',
	nsubE: '\u2AC5\u0338',
	nsube: '\u2288',
	nsubset: '\u2282\u20D2',
	nsubseteq: '\u2288',
	nsubseteqq: '\u2AC5\u0338',
	nsucc: '\u2281',
	nsucceq: '\u2AB0\u0338',
	nsup: '\u2285',
	nsupE: '\u2AC6\u0338',
	nsupe: '\u2289',
	nsupset: '\u2283\u20D2',
	nsupseteq: '\u2289',
	nsupseteqq: '\u2AC6\u0338',
	ntgl: '\u2279',
	Ntilde: '\u00D1',
	ntilde: '\u00F1',
	ntlg: '\u2278',
	ntriangleleft: '\u22EA',
	ntrianglelefteq: '\u22EC',
	ntriangleright: '\u22EB',
	ntrianglerighteq: '\u22ED',
	Nu: '\u039D',
	nu: '\u03BD',
	num: '\u0023',
	numero: '\u2116',
	numsp: '\u2007',
	nvap: '\u224D\u20D2',
	nVDash: '\u22AF',
	nVdash: '\u22AE',
	nvDash: '\u22AD',
	nvdash: '\u22AC',
	nvge: '\u2265\u20D2',
	nvgt: '\u003E\u20D2',
	nvHarr: '\u2904',
	nvinfin: '\u29DE',
	nvlArr: '\u2902',
	nvle: '\u2264\u20D2',
	nvlt: '\u003C\u20D2',
	nvltrie: '\u22B4\u20D2',
	nvrArr: '\u2903',
	nvrtrie: '\u22B5\u20D2',
	nvsim: '\u223C\u20D2',
	nwarhk: '\u2923',
	nwArr: '\u21D6',
	nwarr: '\u2196',
	nwarrow: '\u2196',
	nwnear: '\u2927',
	Oacute: '\u00D3',
	oacute: '\u00F3',
	oast: '\u229B',
	ocir: '\u229A',
	Ocirc: '\u00D4',
	ocirc: '\u00F4',
	Ocy: '\u041E',
	ocy: '\u043E',
	odash: '\u229D',
	Odblac: '\u0150',
	odblac: '\u0151',
	odiv: '\u2A38',
	odot: '\u2299',
	odsold: '\u29BC',
	OElig: '\u0152',
	oelig: '\u0153',
	ofcir: '\u29BF',
	Ofr: '\uD835\uDD12',
	ofr: '\uD835\uDD2C',
	ogon: '\u02DB',
	Ograve: '\u00D2',
	ograve: '\u00F2',
	ogt: '\u29C1',
	ohbar: '\u29B5',
	ohm: '\u03A9',
	oint: '\u222E',
	olarr: '\u21BA',
	olcir: '\u29BE',
	olcross: '\u29BB',
	oline: '\u203E',
	olt: '\u29C0',
	Omacr: '\u014C',
	omacr: '\u014D',
	Omega: '\u03A9',
	omega: '\u03C9',
	Omicron: '\u039F',
	omicron: '\u03BF',
	omid: '\u29B6',
	ominus: '\u2296',
	Oopf: '\uD835\uDD46',
	oopf: '\uD835\uDD60',
	opar: '\u29B7',
	OpenCurlyDoubleQuote: '\u201C',
	OpenCurlyQuote: '\u2018',
	operp: '\u29B9',
	oplus: '\u2295',
	Or: '\u2A54',
	or: '\u2228',
	orarr: '\u21BB',
	ord: '\u2A5D',
	order: '\u2134',
	orderof: '\u2134',
	ordf: '\u00AA',
	ordm: '\u00BA',
	origof: '\u22B6',
	oror: '\u2A56',
	orslope: '\u2A57',
	orv: '\u2A5B',
	oS: '\u24C8',
	Oscr: '\uD835\uDCAA',
	oscr: '\u2134',
	Oslash: '\u00D8',
	oslash: '\u00F8',
	osol: '\u2298',
	Otilde: '\u00D5',
	otilde: '\u00F5',
	Otimes: '\u2A37',
	otimes: '\u2297',
	otimesas: '\u2A36',
	Ouml: '\u00D6',
	ouml: '\u00F6',
	ovbar: '\u233D',
	OverBar: '\u203E',
	OverBrace: '\u23DE',
	OverBracket: '\u23B4',
	OverParenthesis: '\u23DC',
	par: '\u2225',
	para: '\u00B6',
	parallel: '\u2225',
	parsim: '\u2AF3',
	parsl: '\u2AFD',
	part: '\u2202',
	PartialD: '\u2202',
	Pcy: '\u041F',
	pcy: '\u043F',
	percnt: '\u0025',
	period: '\u002E',
	permil: '\u2030',
	perp: '\u22A5',
	pertenk: '\u2031',
	Pfr: '\uD835\uDD13',
	pfr: '\uD835\uDD2D',
	Phi: '\u03A6',
	phi: '\u03C6',
	phiv: '\u03D5',
	phmmat: '\u2133',
	phone: '\u260E',
	Pi: '\u03A0',
	pi: '\u03C0',
	pitchfork: '\u22D4',
	piv: '\u03D6',
	planck: '\u210F',
	planckh: '\u210E',
	plankv: '\u210F',
	plus: '\u002B',
	plusacir: '\u2A23',
	plusb: '\u229E',
	pluscir: '\u2A22',
	plusdo: '\u2214',
	plusdu: '\u2A25',
	pluse: '\u2A72',
	PlusMinus: '\u00B1',
	plusmn: '\u00B1',
	plussim: '\u2A26',
	plustwo: '\u2A27',
	pm: '\u00B1',
	Poincareplane: '\u210C',
	pointint: '\u2A15',
	Popf: '\u2119',
	popf: '\uD835\uDD61',
	pound: '\u00A3',
	Pr: '\u2ABB',
	pr: '\u227A',
	prap: '\u2AB7',
	prcue: '\u227C',
	prE: '\u2AB3',
	pre: '\u2AAF',
	prec: '\u227A',
	precapprox: '\u2AB7',
	preccurlyeq: '\u227C',
	Precedes: '\u227A',
	PrecedesEqual: '\u2AAF',
	PrecedesSlantEqual: '\u227C',
	PrecedesTilde: '\u227E',
	preceq: '\u2AAF',
	precnapprox: '\u2AB9',
	precneqq: '\u2AB5',
	precnsim: '\u22E8',
	precsim: '\u227E',
	Prime: '\u2033',
	prime: '\u2032',
	primes: '\u2119',
	prnap: '\u2AB9',
	prnE: '\u2AB5',
	prnsim: '\u22E8',
	prod: '\u220F',
	Product: '\u220F',
	profalar: '\u232E',
	profline: '\u2312',
	profsurf: '\u2313',
	prop: '\u221D',
	Proportion: '\u2237',
	Proportional: '\u221D',
	propto: '\u221D',
	prsim: '\u227E',
	prurel: '\u22B0',
	Pscr: '\uD835\uDCAB',
	pscr: '\uD835\uDCC5',
	Psi: '\u03A8',
	psi: '\u03C8',
	puncsp: '\u2008',
	Qfr: '\uD835\uDD14',
	qfr: '\uD835\uDD2E',
	qint: '\u2A0C',
	Qopf: '\u211A',
	qopf: '\uD835\uDD62',
	qprime: '\u2057',
	Qscr: '\uD835\uDCAC',
	qscr: '\uD835\uDCC6',
	quaternions: '\u210D',
	quatint: '\u2A16',
	quest: '\u003F',
	questeq: '\u225F',
	QUOT: '\u0022',
	quot: '\u0022',
	rAarr: '\u21DB',
	race: '\u223D\u0331',
	Racute: '\u0154',
	racute: '\u0155',
	radic: '\u221A',
	raemptyv: '\u29B3',
	Rang: '\u27EB',
	rang: '\u27E9',
	rangd: '\u2992',
	range: '\u29A5',
	rangle: '\u27E9',
	raquo: '\u00BB',
	Rarr: '\u21A0',
	rArr: '\u21D2',
	rarr: '\u2192',
	rarrap: '\u2975',
	rarrb: '\u21E5',
	rarrbfs: '\u2920',
	rarrc: '\u2933',
	rarrfs: '\u291E',
	rarrhk: '\u21AA',
	rarrlp: '\u21AC',
	rarrpl: '\u2945',
	rarrsim: '\u2974',
	Rarrtl: '\u2916',
	rarrtl: '\u21A3',
	rarrw: '\u219D',
	rAtail: '\u291C',
	ratail: '\u291A',
	ratio: '\u2236',
	rationals: '\u211A',
	RBarr: '\u2910',
	rBarr: '\u290F',
	rbarr: '\u290D',
	rbbrk: '\u2773',
	rbrace: '\u007D',
	rbrack: '\u005D',
	rbrke: '\u298C',
	rbrksld: '\u298E',
	rbrkslu: '\u2990',
	Rcaron: '\u0158',
	rcaron: '\u0159',
	Rcedil: '\u0156',
	rcedil: '\u0157',
	rceil: '\u2309',
	rcub: '\u007D',
	Rcy: '\u0420',
	rcy: '\u0440',
	rdca: '\u2937',
	rdldhar: '\u2969',
	rdquo: '\u201D',
	rdquor: '\u201D',
	rdsh: '\u21B3',
	Re: '\u211C',
	real: '\u211C',
	realine: '\u211B',
	realpart: '\u211C',
	reals: '\u211D',
	rect: '\u25AD',
	REG: '\u00AE',
	reg: '\u00AE',
	ReverseElement: '\u220B',
	ReverseEquilibrium: '\u21CB',
	ReverseUpEquilibrium: '\u296F',
	rfisht: '\u297D',
	rfloor: '\u230B',
	Rfr: '\u211C',
	rfr: '\uD835\uDD2F',
	rHar: '\u2964',
	rhard: '\u21C1',
	rharu: '\u21C0',
	rharul: '\u296C',
	Rho: '\u03A1',
	rho: '\u03C1',
	rhov: '\u03F1',
	RightAngleBracket: '\u27E9',
	RightArrow: '\u2192',
	Rightarrow: '\u21D2',
	rightarrow: '\u2192',
	RightArrowBar: '\u21E5',
	RightArrowLeftArrow: '\u21C4',
	rightarrowtail: '\u21A3',
	RightCeiling: '\u2309',
	RightDoubleBracket: '\u27E7',
	RightDownTeeVector: '\u295D',
	RightDownVector: '\u21C2',
	RightDownVectorBar: '\u2955',
	RightFloor: '\u230B',
	rightharpoondown: '\u21C1',
	rightharpoonup: '\u21C0',
	rightleftarrows: '\u21C4',
	rightleftharpoons: '\u21CC',
	rightrightarrows: '\u21C9',
	rightsquigarrow: '\u219D',
	RightTee: '\u22A2',
	RightTeeArrow: '\u21A6',
	RightTeeVector: '\u295B',
	rightthreetimes: '\u22CC',
	RightTriangle: '\u22B3',
	RightTriangleBar: '\u29D0',
	RightTriangleEqual: '\u22B5',
	RightUpDownVector: '\u294F',
	RightUpTeeVector: '\u295C',
	RightUpVector: '\u21BE',
	RightUpVectorBar: '\u2954',
	RightVector: '\u21C0',
	RightVectorBar: '\u2953',
	ring: '\u02DA',
	risingdotseq: '\u2253',
	rlarr: '\u21C4',
	rlhar: '\u21CC',
	rlm: '\u200F',
	rmoust: '\u23B1',
	rmoustache: '\u23B1',
	rnmid: '\u2AEE',
	roang: '\u27ED',
	roarr: '\u21FE',
	robrk: '\u27E7',
	ropar: '\u2986',
	Ropf: '\u211D',
	ropf: '\uD835\uDD63',
	roplus: '\u2A2E',
	rotimes: '\u2A35',
	RoundImplies: '\u2970',
	rpar: '\u0029',
	rpargt: '\u2994',
	rppolint: '\u2A12',
	rrarr: '\u21C9',
	Rrightarrow: '\u21DB',
	rsaquo: '\u203A',
	Rscr: '\u211B',
	rscr: '\uD835\uDCC7',
	Rsh: '\u21B1',
	rsh: '\u21B1',
	rsqb: '\u005D',
	rsquo: '\u2019',
	rsquor: '\u2019',
	rthree: '\u22CC',
	rtimes: '\u22CA',
	rtri: '\u25B9',
	rtrie: '\u22B5',
	rtrif: '\u25B8',
	rtriltri: '\u29CE',
	RuleDelayed: '\u29F4',
	ruluhar: '\u2968',
	rx: '\u211E',
	Sacute: '\u015A',
	sacute: '\u015B',
	sbquo: '\u201A',
	Sc: '\u2ABC',
	sc: '\u227B',
	scap: '\u2AB8',
	Scaron: '\u0160',
	scaron: '\u0161',
	sccue: '\u227D',
	scE: '\u2AB4',
	sce: '\u2AB0',
	Scedil: '\u015E',
	scedil: '\u015F',
	Scirc: '\u015C',
	scirc: '\u015D',
	scnap: '\u2ABA',
	scnE: '\u2AB6',
	scnsim: '\u22E9',
	scpolint: '\u2A13',
	scsim: '\u227F',
	Scy: '\u0421',
	scy: '\u0441',
	sdot: '\u22C5',
	sdotb: '\u22A1',
	sdote: '\u2A66',
	searhk: '\u2925',
	seArr: '\u21D8',
	searr: '\u2198',
	searrow: '\u2198',
	sect: '\u00A7',
	semi: '\u003B',
	seswar: '\u2929',
	setminus: '\u2216',
	setmn: '\u2216',
	sext: '\u2736',
	Sfr: '\uD835\uDD16',
	sfr: '\uD835\uDD30',
	sfrown: '\u2322',
	sharp: '\u266F',
	SHCHcy: '\u0429',
	shchcy: '\u0449',
	SHcy: '\u0428',
	shcy: '\u0448',
	ShortDownArrow: '\u2193',
	ShortLeftArrow: '\u2190',
	shortmid: '\u2223',
	shortparallel: '\u2225',
	ShortRightArrow: '\u2192',
	ShortUpArrow: '\u2191',
	shy: '\u00AD',
	Sigma: '\u03A3',
	sigma: '\u03C3',
	sigmaf: '\u03C2',
	sigmav: '\u03C2',
	sim: '\u223C',
	simdot: '\u2A6A',
	sime: '\u2243',
	simeq: '\u2243',
	simg: '\u2A9E',
	simgE: '\u2AA0',
	siml: '\u2A9D',
	simlE: '\u2A9F',
	simne: '\u2246',
	simplus: '\u2A24',
	simrarr: '\u2972',
	slarr: '\u2190',
	SmallCircle: '\u2218',
	smallsetminus: '\u2216',
	smashp: '\u2A33',
	smeparsl: '\u29E4',
	smid: '\u2223',
	smile: '\u2323',
	smt: '\u2AAA',
	smte: '\u2AAC',
	smtes: '\u2AAC\uFE00',
	SOFTcy: '\u042C',
	softcy: '\u044C',
	sol: '\u002F',
	solb: '\u29C4',
	solbar: '\u233F',
	Sopf: '\uD835\uDD4A',
	sopf: '\uD835\uDD64',
	spades: '\u2660',
	spadesuit: '\u2660',
	spar: '\u2225',
	sqcap: '\u2293',
	sqcaps: '\u2293\uFE00',
	sqcup: '\u2294',
	sqcups: '\u2294\uFE00',
	Sqrt: '\u221A',
	sqsub: '\u228F',
	sqsube: '\u2291',
	sqsubset: '\u228F',
	sqsubseteq: '\u2291',
	sqsup: '\u2290',
	sqsupe: '\u2292',
	sqsupset: '\u2290',
	sqsupseteq: '\u2292',
	squ: '\u25A1',
	Square: '\u25A1',
	square: '\u25A1',
	SquareIntersection: '\u2293',
	SquareSubset: '\u228F',
	SquareSubsetEqual: '\u2291',
	SquareSuperset: '\u2290',
	SquareSupersetEqual: '\u2292',
	SquareUnion: '\u2294',
	squarf: '\u25AA',
	squf: '\u25AA',
	srarr: '\u2192',
	Sscr: '\uD835\uDCAE',
	sscr: '\uD835\uDCC8',
	ssetmn: '\u2216',
	ssmile: '\u2323',
	sstarf: '\u22C6',
	Star: '\u22C6',
	star: '\u2606',
	starf: '\u2605',
	straightepsilon: '\u03F5',
	straightphi: '\u03D5',
	strns: '\u00AF',
	Sub: '\u22D0',
	sub: '\u2282',
	subdot: '\u2ABD',
	subE: '\u2AC5',
	sube: '\u2286',
	subedot: '\u2AC3',
	submult: '\u2AC1',
	subnE: '\u2ACB',
	subne: '\u228A',
	subplus: '\u2ABF',
	subrarr: '\u2979',
	Subset: '\u22D0',
	subset: '\u2282',
	subseteq: '\u2286',
	subseteqq: '\u2AC5',
	SubsetEqual: '\u2286',
	subsetneq: '\u228A',
	subsetneqq: '\u2ACB',
	subsim: '\u2AC7',
	subsub: '\u2AD5',
	subsup: '\u2AD3',
	succ: '\u227B',
	succapprox: '\u2AB8',
	succcurlyeq: '\u227D',
	Succeeds: '\u227B',
	SucceedsEqual: '\u2AB0',
	SucceedsSlantEqual: '\u227D',
	SucceedsTilde: '\u227F',
	succeq: '\u2AB0',
	succnapprox: '\u2ABA',
	succneqq: '\u2AB6',
	succnsim: '\u22E9',
	succsim: '\u227F',
	SuchThat: '\u220B',
	Sum: '\u2211',
	sum: '\u2211',
	sung: '\u266A',
	Sup: '\u22D1',
	sup: '\u2283',
	sup1: '\u00B9',
	sup2: '\u00B2',
	sup3: '\u00B3',
	supdot: '\u2ABE',
	supdsub: '\u2AD8',
	supE: '\u2AC6',
	supe: '\u2287',
	supedot: '\u2AC4',
	Superset: '\u2283',
	SupersetEqual: '\u2287',
	suphsol: '\u27C9',
	suphsub: '\u2AD7',
	suplarr: '\u297B',
	supmult: '\u2AC2',
	supnE: '\u2ACC',
	supne: '\u228B',
	supplus: '\u2AC0',
	Supset: '\u22D1',
	supset: '\u2283',
	supseteq: '\u2287',
	supseteqq: '\u2AC6',
	supsetneq: '\u228B',
	supsetneqq: '\u2ACC',
	supsim: '\u2AC8',
	supsub: '\u2AD4',
	supsup: '\u2AD6',
	swarhk: '\u2926',
	swArr: '\u21D9',
	swarr: '\u2199',
	swarrow: '\u2199',
	swnwar: '\u292A',
	szlig: '\u00DF',
	Tab: '\u0009',
	target: '\u2316',
	Tau: '\u03A4',
	tau: '\u03C4',
	tbrk: '\u23B4',
	Tcaron: '\u0164',
	tcaron: '\u0165',
	Tcedil: '\u0162',
	tcedil: '\u0163',
	Tcy: '\u0422',
	tcy: '\u0442',
	tdot: '\u20DB',
	telrec: '\u2315',
	Tfr: '\uD835\uDD17',
	tfr: '\uD835\uDD31',
	there4: '\u2234',
	Therefore: '\u2234',
	therefore: '\u2234',
	Theta: '\u0398',
	theta: '\u03B8',
	thetasym: '\u03D1',
	thetav: '\u03D1',
	thickapprox: '\u2248',
	thicksim: '\u223C',
	ThickSpace: '\u205F\u200A',
	thinsp: '\u2009',
	ThinSpace: '\u2009',
	thkap: '\u2248',
	thksim: '\u223C',
	THORN: '\u00DE',
	thorn: '\u00FE',
	Tilde: '\u223C',
	tilde: '\u02DC',
	TildeEqual: '\u2243',
	TildeFullEqual: '\u2245',
	TildeTilde: '\u2248',
	times: '\u00D7',
	timesb: '\u22A0',
	timesbar: '\u2A31',
	timesd: '\u2A30',
	tint: '\u222D',
	toea: '\u2928',
	top: '\u22A4',
	topbot: '\u2336',
	topcir: '\u2AF1',
	Topf: '\uD835\uDD4B',
	topf: '\uD835\uDD65',
	topfork: '\u2ADA',
	tosa: '\u2929',
	tprime: '\u2034',
	TRADE: '\u2122',
	trade: '\u2122',
	triangle: '\u25B5',
	triangledown: '\u25BF',
	triangleleft: '\u25C3',
	trianglelefteq: '\u22B4',
	triangleq: '\u225C',
	triangleright: '\u25B9',
	trianglerighteq: '\u22B5',
	tridot: '\u25EC',
	trie: '\u225C',
	triminus: '\u2A3A',
	TripleDot: '\u20DB',
	triplus: '\u2A39',
	trisb: '\u29CD',
	tritime: '\u2A3B',
	trpezium: '\u23E2',
	Tscr: '\uD835\uDCAF',
	tscr: '\uD835\uDCC9',
	TScy: '\u0426',
	tscy: '\u0446',
	TSHcy: '\u040B',
	tshcy: '\u045B',
	Tstrok: '\u0166',
	tstrok: '\u0167',
	twixt: '\u226C',
	twoheadleftarrow: '\u219E',
	twoheadrightarrow: '\u21A0',
	Uacute: '\u00DA',
	uacute: '\u00FA',
	Uarr: '\u219F',
	uArr: '\u21D1',
	uarr: '\u2191',
	Uarrocir: '\u2949',
	Ubrcy: '\u040E',
	ubrcy: '\u045E',
	Ubreve: '\u016C',
	ubreve: '\u016D',
	Ucirc: '\u00DB',
	ucirc: '\u00FB',
	Ucy: '\u0423',
	ucy: '\u0443',
	udarr: '\u21C5',
	Udblac: '\u0170',
	udblac: '\u0171',
	udhar: '\u296E',
	ufisht: '\u297E',
	Ufr: '\uD835\uDD18',
	ufr: '\uD835\uDD32',
	Ugrave: '\u00D9',
	ugrave: '\u00F9',
	uHar: '\u2963',
	uharl: '\u21BF',
	uharr: '\u21BE',
	uhblk: '\u2580',
	ulcorn: '\u231C',
	ulcorner: '\u231C',
	ulcrop: '\u230F',
	ultri: '\u25F8',
	Umacr: '\u016A',
	umacr: '\u016B',
	uml: '\u00A8',
	UnderBar: '\u005F',
	UnderBrace: '\u23DF',
	UnderBracket: '\u23B5',
	UnderParenthesis: '\u23DD',
	Union: '\u22C3',
	UnionPlus: '\u228E',
	Uogon: '\u0172',
	uogon: '\u0173',
	Uopf: '\uD835\uDD4C',
	uopf: '\uD835\uDD66',
	UpArrow: '\u2191',
	Uparrow: '\u21D1',
	uparrow: '\u2191',
	UpArrowBar: '\u2912',
	UpArrowDownArrow: '\u21C5',
	UpDownArrow: '\u2195',
	Updownarrow: '\u21D5',
	updownarrow: '\u2195',
	UpEquilibrium: '\u296E',
	upharpoonleft: '\u21BF',
	upharpoonright: '\u21BE',
	uplus: '\u228E',
	UpperLeftArrow: '\u2196',
	UpperRightArrow: '\u2197',
	Upsi: '\u03D2',
	upsi: '\u03C5',
	upsih: '\u03D2',
	Upsilon: '\u03A5',
	upsilon: '\u03C5',
	UpTee: '\u22A5',
	UpTeeArrow: '\u21A5',
	upuparrows: '\u21C8',
	urcorn: '\u231D',
	urcorner: '\u231D',
	urcrop: '\u230E',
	Uring: '\u016E',
	uring: '\u016F',
	urtri: '\u25F9',
	Uscr: '\uD835\uDCB0',
	uscr: '\uD835\uDCCA',
	utdot: '\u22F0',
	Utilde: '\u0168',
	utilde: '\u0169',
	utri: '\u25B5',
	utrif: '\u25B4',
	uuarr: '\u21C8',
	Uuml: '\u00DC',
	uuml: '\u00FC',
	uwangle: '\u29A7',
	vangrt: '\u299C',
	varepsilon: '\u03F5',
	varkappa: '\u03F0',
	varnothing: '\u2205',
	varphi: '\u03D5',
	varpi: '\u03D6',
	varpropto: '\u221D',
	vArr: '\u21D5',
	varr: '\u2195',
	varrho: '\u03F1',
	varsigma: '\u03C2',
	varsubsetneq: '\u228A\uFE00',
	varsubsetneqq: '\u2ACB\uFE00',
	varsupsetneq: '\u228B\uFE00',
	varsupsetneqq: '\u2ACC\uFE00',
	vartheta: '\u03D1',
	vartriangleleft: '\u22B2',
	vartriangleright: '\u22B3',
	Vbar: '\u2AEB',
	vBar: '\u2AE8',
	vBarv: '\u2AE9',
	Vcy: '\u0412',
	vcy: '\u0432',
	VDash: '\u22AB',
	Vdash: '\u22A9',
	vDash: '\u22A8',
	vdash: '\u22A2',
	Vdashl: '\u2AE6',
	Vee: '\u22C1',
	vee: '\u2228',
	veebar: '\u22BB',
	veeeq: '\u225A',
	vellip: '\u22EE',
	Verbar: '\u2016',
	verbar: '\u007C',
	Vert: '\u2016',
	vert: '\u007C',
	VerticalBar: '\u2223',
	VerticalLine: '\u007C',
	VerticalSeparator: '\u2758',
	VerticalTilde: '\u2240',
	VeryThinSpace: '\u200A',
	Vfr: '\uD835\uDD19',
	vfr: '\uD835\uDD33',
	vltri: '\u22B2',
	vnsub: '\u2282\u20D2',
	vnsup: '\u2283\u20D2',
	Vopf: '\uD835\uDD4D',
	vopf: '\uD835\uDD67',
	vprop: '\u221D',
	vrtri: '\u22B3',
	Vscr: '\uD835\uDCB1',
	vscr: '\uD835\uDCCB',
	vsubnE: '\u2ACB\uFE00',
	vsubne: '\u228A\uFE00',
	vsupnE: '\u2ACC\uFE00',
	vsupne: '\u228B\uFE00',
	Vvdash: '\u22AA',
	vzigzag: '\u299A',
	Wcirc: '\u0174',
	wcirc: '\u0175',
	wedbar: '\u2A5F',
	Wedge: '\u22C0',
	wedge: '\u2227',
	wedgeq: '\u2259',
	weierp: '\u2118',
	Wfr: '\uD835\uDD1A',
	wfr: '\uD835\uDD34',
	Wopf: '\uD835\uDD4E',
	wopf: '\uD835\uDD68',
	wp: '\u2118',
	wr: '\u2240',
	wreath: '\u2240',
	Wscr: '\uD835\uDCB2',
	wscr: '\uD835\uDCCC',
	xcap: '\u22C2',
	xcirc: '\u25EF',
	xcup: '\u22C3',
	xdtri: '\u25BD',
	Xfr: '\uD835\uDD1B',
	xfr: '\uD835\uDD35',
	xhArr: '\u27FA',
	xharr: '\u27F7',
	Xi: '\u039E',
	xi: '\u03BE',
	xlArr: '\u27F8',
	xlarr: '\u27F5',
	xmap: '\u27FC',
	xnis: '\u22FB',
	xodot: '\u2A00',
	Xopf: '\uD835\uDD4F',
	xopf: '\uD835\uDD69',
	xoplus: '\u2A01',
	xotime: '\u2A02',
	xrArr: '\u27F9',
	xrarr: '\u27F6',
	Xscr: '\uD835\uDCB3',
	xscr: '\uD835\uDCCD',
	xsqcup: '\u2A06',
	xuplus: '\u2A04',
	xutri: '\u25B3',
	xvee: '\u22C1',
	xwedge: '\u22C0',
	Yacute: '\u00DD',
	yacute: '\u00FD',
	YAcy: '\u042F',
	yacy: '\u044F',
	Ycirc: '\u0176',
	ycirc: '\u0177',
	Ycy: '\u042B',
	ycy: '\u044B',
	yen: '\u00A5',
	Yfr: '\uD835\uDD1C',
	yfr: '\uD835\uDD36',
	YIcy: '\u0407',
	yicy: '\u0457',
	Yopf: '\uD835\uDD50',
	yopf: '\uD835\uDD6A',
	Yscr: '\uD835\uDCB4',
	yscr: '\uD835\uDCCE',
	YUcy: '\u042E',
	yucy: '\u044E',
	Yuml: '\u0178',
	yuml: '\u00FF',
	Zacute: '\u0179',
	zacute: '\u017A',
	Zcaron: '\u017D',
	zcaron: '\u017E',
	Zcy: '\u0417',
	zcy: '\u0437',
	Zdot: '\u017B',
	zdot: '\u017C',
	zeetrf: '\u2128',
	ZeroWidthSpace: '\u200B',
	Zeta: '\u0396',
	zeta: '\u03B6',
	Zfr: '\u2128',
	zfr: '\uD835\uDD37',
	ZHcy: '\u0416',
	zhcy: '\u0436',
	zigrarr: '\u21DD',
	Zopf: '\u2124',
	zopf: '\uD835\uDD6B',
	Zscr: '\uD835\uDCB5',
	zscr: '\uD835\uDCCF',
	zwj: '\u200D',
	zwnj: '\u200C',
});

/**
 * @deprecated use `HTML_ENTITIES` instead
 * @see HTML_ENTITIES
 */
exports.entityMap = exports.HTML_ENTITIES;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var dom = __webpack_require__(/*! ./dom */ "./node_modules/@xmldom/xmldom/lib/dom.js")
exports.DOMImplementation = dom.DOMImplementation
exports.XMLSerializer = dom.XMLSerializer
exports.DOMParser = __webpack_require__(/*! ./dom-parser */ "./node_modules/@xmldom/xmldom/lib/dom-parser.js").DOMParser


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/sax.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/sax.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var NAMESPACE = (__webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js").NAMESPACE);

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

/**
 * Creates an error that will not be caught by XMLReader aka the SAX parser.
 *
 * @param {string} message
 * @param {any?} locator Optional, can provide details about the location in the source
 * @constructor
 */
function ParseError(message, locator) {
	this.message = message
	this.locator = locator
	if(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
}
ParseError.prototype = new Error();
ParseError.prototype.name = ParseError.name

function XMLReader(){

}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if (Object.hasOwnProperty.call(entityMap, k)) {
			return entityMap[k];
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;

	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
				var config = parseStack.pop();
				if(end<0){

	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for (var prefix in localNSMap) {
							if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
								domBuilder.endPrefixMapping(prefix);
							}
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case
					}
		        }else{
		        	parseStack.push(config)
		        }

				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;


				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}

				if (NAMESPACE.isHTML(el.uri) && !el.closed) {
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				} else {
					end++;
				}
			}
		}catch(e){
			if (e instanceof ParseError) {
				throw e;
			}
			errorHandler.error('element parse error: '+e)
			end = -1;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: sax
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){

	/**
	 * @param {string} qname
	 * @param {string} value
	 * @param {number} startIndex
	 */
	function addAttribute(qname, value, startIndex) {
		if (el.attributeNames.hasOwnProperty(qname)) {
			errorHandler.fatalError('Attribute ' + qname + ' redefined')
		}
		el.addValue(
			qname,
			// @see https://www.w3.org/TR/xml/#AVNormalize
			// since the xmldom sax parser does not "interpret" DTD the following is not implemented:
			// - recursive replacement of (DTD) entity references
			// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
			value.replace(/[\t\n\r]/g, ' ').replace(/&#?\w+;/g, entityReplacer),
			startIndex
		)
	}
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName'); // No known test case
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start, p);
					addAttribute(attrName, value, start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start, p);
				addAttribute(attrName, value, start);
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="'); // No known test case
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
				break;
				case S_ATTR_SPACE:
					el.closed = true;
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')") // No known test case
			}
			break;
		case ''://end document
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!');
					addAttribute(attrName, value, start)
				}else{
					if(!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					addAttribute(value, value, start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start, p);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					addAttribute(attrName, value, start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					addAttribute(attrName, attrName, start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = NAMESPACE.XMLNS
			domBuilder.startPrefixMapping(nsPrefix, value)
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = NAMESPACE.XML;
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']

				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for (prefix in localNSMap) {
				if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
					domBuilder.endPrefixMapping(prefix);
				}
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}

		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//}
}

function _copy (source, target) {
	for (var n in source) {
		if (Object.prototype.hasOwnProperty.call(source, n)) {
			target[n] = source[n];
		}
	}
}

function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA()
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = false;
			var sysid = false;
			if(len>3){
				if(/^public$/i.test(matchs[2][0])){
					pubid = matchs[3][0];
					sysid = len>4 && matchs[4][0];
				}else if(/^system$/i.test(matchs[2][0])){
					sysid = matchs[3][0];
				}
			}
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name, pubid, sysid);
			domBuilder.endDTD();

			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

function ElementAttributes(){
	this.attributeNames = {}
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	addValue:function(qName, value, offset) {
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this.attributeNames[qName] = this.length;
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}



function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;
exports.ParseError = ParseError;


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/eventemitter3/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/eventemitter3/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/eventemitter3/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSPlugin: () => (/* binding */ CSSPlugin),
/* harmony export */   _createElement: () => (/* binding */ _createElement),
/* harmony export */   _getBBox: () => (/* binding */ _getBBox),
/* harmony export */   checkPrefix: () => (/* binding */ _checkPropPrefix),
/* harmony export */   "default": () => (/* binding */ CSSPlugin)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _reverting,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _saveStyle = function _saveStyle(property, isNotCSS) {
  var _this = this;

  var target = this.target,
      style = target.style,
      cache = target._gsap;

  if (property in _transformProps && style) {
    this.tfm = this.tfm || {};

    if (property !== "transform") {
      property = _propertyAliases[property] || property;
      ~property.indexOf(",") ? property.split(",").forEach(function (a) {
        return _this.tfm[a] = _get(target, a);
      }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to "scaleX,scaleY", thus we loop and apply them both.

      property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
    } else {
      return _propertyAliases.transform.split(",").forEach(function (p) {
        return _saveStyle.call(_this, p, isNotCSS);
      });
    }

    if (this.props.indexOf(_transformProp) >= 0) {
      return;
    }

    if (cache.svg) {
      this.svgo = target.getAttribute("data-svg-origin");
      this.props.push(_transformOriginProp, isNotCSS, "");
    }

    property = _transformProp;
  }

  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
},
    _removeIndependentTransforms = function _removeIndependentTransforms(style) {
  if (style.translate) {
    style.removeProperty("translate");
    style.removeProperty("scale");
    style.removeProperty("rotate");
  }
},
    _revertStyle = function _revertStyle() {
  var props = this.props,
      target = this.target,
      style = target.style,
      cache = target._gsap,
      i,
      p;

  for (i = 0; i < props.length; i += 3) {
    // stored like this: property, isNotCSS, value
    if (!props[i + 1]) {
      props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
    } else if (props[i + 1] === 2) {
      // non-CSS value (function-based)
      target[props[i]](props[i + 2]);
    } else {
      // non-CSS value (not function-based)
      target[props[i]] = props[i + 2];
    }
  }

  if (this.tfm) {
    for (p in this.tfm) {
      cache[p] = this.tfm[p];
    }

    if (cache.svg) {
      cache.renderTransform();
      target.setAttribute("data-svg-origin", this.svgo || "");
    }

    i = _reverting();

    if ((!i || !i.isStart) && !style[_transformProp]) {
      _removeIndependentTransforms(style);

      if (cache.zOrigin && style[_transformOriginProp]) {
        style[_transformOriginProp] += " " + cache.zOrigin + "px"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.

        cache.zOrigin = 0;
        cache.renderTransform();
      }

      cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.
    }
  }
},
    _getStyleSaver = function _getStyleSaver(target, properties) {
  var saver = {
    target: target,
    props: [],
    revert: _revertStyle,
    save: _saveStyle
  };
  target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.

  properties && target.style && target.nodeType && properties.split(",").forEach(function (p) {
    return saver.save(p);
  }); // make sure it's a DOM node too.

  return saver;
},
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting;
    _pluginInitted = 1;
  }
},
    _getReparentedCloneBBox = function _getReparentedCloneBBox(target) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var owner = target.ownerSVGElement,
      svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      clone = target.cloneNode(true),
      bbox;

  clone.style.display = "block";
  svg.appendChild(clone);

  _docElement.appendChild(svg);

  try {
    bbox = clone.getBBox();
  } catch (e) {}

  svg.removeChild(clone);

  _docElement.removeChild(svg);

  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds, cloned;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getReparentedCloneBBox(target);
    cloned = 1;
  }

  bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style,
        first2Chars;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      first2Chars = property.substr(0, 2);

      if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    _nonStandardLayouts = {
  grid: 1,
  flex: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache) {
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
  } else {
    if (toPercent && (property === "height" || property === "width")) {
      // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.
      var v = target.style[property];
      target.style[property] = amount + unit;
      px = target[measureProperty];
      v ? target.style[property] = v : _removeProperty(target, property);
    } else {
      (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
      parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

      parent.appendChild(_tempDiv);
      px = _tempDiv[measureProperty];
      parent.removeChild(_tempDiv);
      style.position = "absolute";
    }

    if (horizontal && toPercent) {
      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; // ensure values are strings

  end += "";

  if (end.substring(0, 6) === "var(--") {
    end = _getComputedProperty(target, end.substring(4, end.indexOf(")")));
  }

  if (end === "auto") {
    startValue = target.style[prop];
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
  }

  a = [start, end];

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");
        style.scale = style.rotate = style.translate = "none";

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;

        _removeIndependentTransforms(style);
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375. Note: position: fixed elements report a null offsetParent but they could also be invisible because they're in an ancestor with display: none, so we check getBoundingClientRect(). We only want to alter the DOM if we absolutely have to because it can cause iframe content to reload, like a Vimeo video.
      addedToDOM = 1; //flag

      nextSibling = target.nextElementSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin); // if (!("xOrigin" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration
    // 	xOrigin -= bounds.x;
    // 	yOrigin -= bounds.y;
    // }
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      cs = getComputedStyle(target),
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));

  if (cs.translate) {
    // accommodate independent transforms by combining them into normal ones.
    if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
      style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
    }

    style.scale = style.rotate = style.translate = "none";
  }

  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    if (cache.uncache) {
      // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.
      t2 = target.getBBox();
      origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
      t1 = "";
    } else {
      t1 = !uncache && target.getAttribute("data-svg-origin"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
    }

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
  var cap = 360,
      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority,
        inlineProps;
    _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps

    this.styles = this.styles || _getStyleSaver(target);
    inlineProps = this.styles.props;
    this.tween = tween;

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;

        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
        inlineProps.push(p, 0, style[p]);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + "") || startValue === "auto" || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            inlineProps.push("visibility", 0, style.visibility);

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          this.styles.save(p);

          if (type === "string" && endValue.substring(0, 6) === "var(--") {
            endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(")")));
            endNum = parseFloat(endValue);
          }

          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
            this._pt.u = 0;
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else if (p !== "parseTransform") {
            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }

        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === "function" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));
        props.push(p);
      }
    }

    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);
  },
  render: function render(ratio, data) {
    if (data.tween._time || !_reverting()) {
      var pt = data._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    } else {
      data.styles.revert();
    }
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Animation: () => (/* binding */ Animation),
/* harmony export */   Back: () => (/* binding */ Back),
/* harmony export */   Bounce: () => (/* binding */ Bounce),
/* harmony export */   Circ: () => (/* binding */ Circ),
/* harmony export */   Cubic: () => (/* binding */ Cubic),
/* harmony export */   Elastic: () => (/* binding */ Elastic),
/* harmony export */   Expo: () => (/* binding */ Expo),
/* harmony export */   GSCache: () => (/* binding */ GSCache),
/* harmony export */   Linear: () => (/* binding */ Linear),
/* harmony export */   Power0: () => (/* binding */ Power0),
/* harmony export */   Power1: () => (/* binding */ Power1),
/* harmony export */   Power2: () => (/* binding */ Power2),
/* harmony export */   Power3: () => (/* binding */ Power3),
/* harmony export */   Power4: () => (/* binding */ Power4),
/* harmony export */   PropTween: () => (/* binding */ PropTween),
/* harmony export */   Quad: () => (/* binding */ Quad),
/* harmony export */   Quart: () => (/* binding */ Quart),
/* harmony export */   Quint: () => (/* binding */ Quint),
/* harmony export */   Sine: () => (/* binding */ Sine),
/* harmony export */   SteppedEase: () => (/* binding */ SteppedEase),
/* harmony export */   Strong: () => (/* binding */ Strong),
/* harmony export */   Timeline: () => (/* binding */ Timeline),
/* harmony export */   TimelineLite: () => (/* binding */ Timeline),
/* harmony export */   TimelineMax: () => (/* binding */ Timeline),
/* harmony export */   Tween: () => (/* binding */ Tween),
/* harmony export */   TweenLite: () => (/* binding */ Tween),
/* harmony export */   TweenMax: () => (/* binding */ Tween),
/* harmony export */   _checkPlugin: () => (/* binding */ _checkPlugin),
/* harmony export */   _colorExp: () => (/* binding */ _colorExp),
/* harmony export */   _colorStringFilter: () => (/* binding */ _colorStringFilter),
/* harmony export */   _config: () => (/* binding */ _config),
/* harmony export */   _forEachName: () => (/* binding */ _forEachName),
/* harmony export */   _getCache: () => (/* binding */ _getCache),
/* harmony export */   _getProperty: () => (/* binding */ _getProperty),
/* harmony export */   _getSetter: () => (/* binding */ _getSetter),
/* harmony export */   _isString: () => (/* binding */ _isString),
/* harmony export */   _isUndefined: () => (/* binding */ _isUndefined),
/* harmony export */   _missingPlugin: () => (/* binding */ _missingPlugin),
/* harmony export */   _numExp: () => (/* binding */ _numExp),
/* harmony export */   _numWithUnitExp: () => (/* binding */ _numWithUnitExp),
/* harmony export */   _parseRelative: () => (/* binding */ _parseRelative),
/* harmony export */   _plugins: () => (/* binding */ _plugins),
/* harmony export */   _relExp: () => (/* binding */ _relExp),
/* harmony export */   _removeLinkedListItem: () => (/* binding */ _removeLinkedListItem),
/* harmony export */   _renderComplexString: () => (/* binding */ _renderComplexString),
/* harmony export */   _replaceRandom: () => (/* binding */ _replaceRandom),
/* harmony export */   _round: () => (/* binding */ _round),
/* harmony export */   _roundModifier: () => (/* binding */ _roundModifier),
/* harmony export */   _setDefaults: () => (/* binding */ _setDefaults),
/* harmony export */   _sortPropTweensByPriority: () => (/* binding */ _sortPropTweensByPriority),
/* harmony export */   _ticker: () => (/* binding */ _ticker),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   "default": () => (/* binding */ gsap),
/* harmony export */   distribute: () => (/* binding */ distribute),
/* harmony export */   getUnit: () => (/* binding */ getUnit),
/* harmony export */   gsap: () => (/* binding */ gsap),
/* harmony export */   interpolate: () => (/* binding */ interpolate),
/* harmony export */   mapRange: () => (/* binding */ mapRange),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   selector: () => (/* binding */ selector),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   snap: () => (/* binding */ snap),
/* harmony export */   splitColor: () => (/* binding */ splitColor),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   unitize: () => (/* binding */ unitize),
/* harmony export */   wrap: () => (/* binding */ wrap),
/* harmony export */   wrapYoyo: () => (/* binding */ wrapYoyo)
/* harmony export */ });
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _reverting,
    _context,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _startAtRevertConfig = {
  suppressEvents: true,
  isStart: true,
  kill: false
},
    _revertConfigNoKill = {
  suppressEvents: true,
  kill: false
},
    _revertConfig = {
  suppressEvents: true
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_parseRelative = function _parseRelative(start, value) {
  var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _isRevertWorthy = function _isRevertWorthy(animation) {
  return !!(animation._initted || animation._startAt || animation.add);
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && !_reverting && _lazyRender();
  animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));
  _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {
    // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)

  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
  _initTween(tween, time, tTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [tTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents && !_reverting) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
  animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = (Math.random() * i) | 0, v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt < l && wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);

    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      prevContext = _context,
      context = animation._ctx,
      params,
      scope,
      result;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  context && (_context = context);
  result = params ? callback.apply(scope, params) : callback.call(scope);
  _context = prevContext;
  return result;
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _registerPluginQueue = [],
    _createPlugin = function _createPlugin(config) {
  if (!config) return;
  config = !config.name && config["default"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  if (_windowExists() || config.headless) {
    // edge case: some build tools may pass in a null/undefined value
    var name = config.name,
        isFunc = _isFunction(config),
        Plugin = name && !isFunc && config.init ? function () {
      this._props = [];
    } : config,
        //in case someone passes in an object that's not a plugin, like CustomEase
    instanceDefaults = {
      init: _emptyFunc,
      render: _renderPropTweens,
      add: _addPropTween,
      kill: _killPropTweensOf,
      modifier: _addPluginModifier,
      rawVars: 0
    },
        statics = {
      targetTest: 0,
      get: 0,
      getSetter: _getSetter,
      aliases: {},
      register: 0
    };

    _wake();

    if (config !== Plugin) {
      if (_plugins[name]) {
        return;
      }

      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


      _plugins[Plugin.prop = name] = Plugin;

      if (config.targetTest) {
        _harnessPlugins.push(Plugin);

        _reservedProps[name] = 1;
      }

      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
    }

    _addGlobal(name, Plugin);

    config.register && config.register(gsap, Plugin, PropTween);
  } else {
    _registerPluginQueue.push(config);
  }
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _registerPluginQueue.forEach(_createPlugin);
        }

        _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function (t, d, f, v) {
        callback(t, d, f, v);

        _self.remove(func);
      } : callback;

      _self.remove(callback);

      _listeners[prioritize ? "unshift" : "push"](func);

      _wake();

      return func;
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);
}); // previously 2 ** (10 * (p - 1)) but that doesn't end up with the value quite at the right spot so we do a blended ease to ensure it lands where it should perfectly.


_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;

    if (_context) {
      this._ctx = _context;

      _context.data.push(this);
    }

    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value, suppressEvents) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return _recacheAncestors(this);
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    } // possible future addition - if an animation is removed from its parent and then .restart() or .play() or .resume() is called, perhaps we should force it back into the globalTimeline but be careful because what if it's already at its end? We don't want it to just persist forever and not get released for GC.
    // !this.parent && !value && this._tTime < this._tDur && this !== _globalTimeline && _globalTimeline.add(this);


    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.revert = function revert(config) {
    if (config === void 0) {
      config = _revertConfig;
    }

    var prevIsReverting = _reverting;
    _reverting = config;

    if (_isRevertWorthy(this)) {
      this.timeline && this.timeline.revert(config);
      this.totalTime(-0.01, config.suppressEvents);
    }

    this.data !== "nested" && config.kill !== false && this.kill();
    _reverting = prevIsReverting;
    return this;
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (Math.abs(animation._ts) || 1);
      animation = animation._dp;
    }

    return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). "_sat" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    this._dur || (this._zTime = -_tinyNum); // ensures onComplete fires on a zero-duration animation that gets restarted.

    return this;
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)

          iteration = ~~prevIteration;

          if (iteration && iteration === prevIteration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the "repeatDelay" portion

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.

          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && tTime && !suppressEvents && !prevIteration) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    child.parent === this && _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate(soft) {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate(soft);
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this, soft);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (!optional || parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_forceAllPropTweens,
    _initTween = function _initTween(tween, time, tTime) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);

    if (prevStartAt) {
      prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.

      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a "startAt" (not "from()" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)
      // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for "startAt" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.

      prevStartAt._lazy = 0;
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: !prevStartAt && _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate && function () {
          return _callback(tween, "onUpdate");
        },
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.

      tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween

      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        if (dur && time <= 0 && tTime <= 0) {
          // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (!prevStartAt) {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        tween._startAt._dp = 0; // don't allow it to get put back into root timeline!

        tween._startAt._sat = tween; // used in globalTime()

        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      rootPT,
      lookup,
      i;

  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;

    while (i--) {
      pt = lookup[i][property];

      if (pt && pt.d && pt.d._pt) {
        // it's a plugin, so find the nested PropTween
        pt = pt.d._pt;

        while (pt && pt.p !== property && pt.fp !== property) {
          // "fp" is functionParam for things like setting CSS variables which require .setProperty("--var-name", value)
          pt = pt._next;
        }
      }

      if (!pt) {
        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

        tween.vars[property] = "+=0";

        _initTween(tween, time);

        _forceAllPropTweens = 0;
        return skipRecursion ? _warn(property + " not eligible for reset") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().
      }

      ptCache.push(pt);
    }
  }

  i = ptCache.length;

  while (i--) {
    rootPT = ptCache[i];
    pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.

    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)

    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)
  }
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {},
        targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.

      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay) || 0); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        isNegative = totalTime < 0,
        tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
      // this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && isNegative) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)

          iteration = ~~prevIteration;

          if (iteration && iteration === prevIteration) {
            time = dur;
            iteration--;
          } else if (time > dur) {
            time = dur;
          }
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted && iteration === prevIteration) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {
            // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!
          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (!prevTime && tTime && !suppressEvents && !prevIteration) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate(soft) {
    // "soft" gives us a way to clear out everything EXCEPT the recorded pre-"from" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the "from" values would persist and then on the next render, the from() tweens would initialize and the current value would match the "from" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.
    (!soft || !this.vars.runBackwards) && (this._startAt = 0);
    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate(soft);
    return _Animation2.prototype.invalidate.call(this, soft);
  };

  _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
      return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}


    _alignPlayhead(this, 0);

    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);
      return this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;

var _media = [],
    _listeners = {},
    _emptyArray = [],
    _lastMediaTime = 0,
    _contextID = 0,
    _dispatch = function _dispatch(type) {
  return (_listeners[type] || _emptyArray).map(function (f) {
    return f();
  });
},
    _onMediaChange = function _onMediaChange() {
  var time = Date.now(),
      matches = [];

  if (time - _lastMediaTime > 2) {
    _dispatch("matchMediaInit");

    _media.forEach(function (c) {
      var queries = c.queries,
          conditions = c.conditions,
          match,
          p,
          anyMatch,
          toggled;

      for (p in queries) {
        match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.

        match && (anyMatch = 1);

        if (match !== conditions[p]) {
          conditions[p] = match;
          toggled = 1;
        }
      }

      if (toggled) {
        c.revert();
        anyMatch && matches.push(c);
      }
    });

    _dispatch("matchMediaRevert");

    matches.forEach(function (c) {
      return c.onMatch(c, function (func) {
        return c.add(null, func);
      });
    });
    _lastMediaTime = time;

    _dispatch("matchMedia");
  }
};

var Context = /*#__PURE__*/function () {
  function Context(func, scope) {
    this.selector = scope && selector(scope);
    this.data = [];
    this._r = []; // returned/cleanup functions

    this.isReverted = false;
    this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because "this" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely

    func && this.add(func);
  }

  var _proto5 = Context.prototype;

  _proto5.add = function add(name, func, scope) {
    // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.
    // if (name && _isFunction(name.revert)) {
    // 	this.data.push(name);
    // 	return (name._ctx = this);
    // }
    if (_isFunction(name)) {
      scope = func;
      func = name;
      name = _isFunction;
    }

    var self = this,
        f = function f() {
      var prev = _context,
          prevSelector = self.selector,
          result;
      prev && prev !== self && prev.data.push(self);
      scope && (self.selector = selector(scope));
      _context = self;
      result = func.apply(self, arguments);
      _isFunction(result) && self._r.push(result);
      _context = prev;
      self.selector = prevSelector;
      self.isReverted = false;
      return result;
    };

    self.last = f;
    return name === _isFunction ? f(self, function (func) {
      return self.add(null, func);
    }) : name ? self[name] = f : f;
  };

  _proto5.ignore = function ignore(func) {
    var prev = _context;
    _context = null;
    func(this);
    _context = prev;
  };

  _proto5.getTweens = function getTweens() {
    var a = [];
    this.data.forEach(function (e) {
      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
    });
    return a;
  };

  _proto5.clear = function clear() {
    this._r.length = this.data.length = 0;
  };

  _proto5.kill = function kill(revert, matchMedia) {
    var _this4 = this;

    if (revert) {
      (function () {
        var tweens = _this4.getTweens(),
            i = _this4.data.length,
            t;

        while (i--) {
          // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.
          t = _this4.data[i];

          if (t.data === "isFlip") {
            t.revert();
            t.getChildren(true, true, false).forEach(function (tween) {
              return tweens.splice(tweens.indexOf(tween), 1);
            });
          }
        } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort


        tweens.map(function (t) {
          return {
            g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,
            t: t
          };
        }).sort(function (a, b) {
          return b.g - a.g || -Infinity;
        }).forEach(function (o) {
          return o.t.revert(revert);
        }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the " || -1" in the sort keeps the order properly.

        i = _this4.data.length;

        while (i--) {
          // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first
          t = _this4.data[i];

          if (t instanceof Timeline) {
            if (t.data !== "nested") {
              t.scrollTrigger && t.scrollTrigger.revert();
              t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens
            }
          } else {
            !(t instanceof Tween) && t.revert && t.revert(revert);
          }
        }

        _this4._r.forEach(function (f) {
          return f(revert, _this4);
        });

        _this4.isReverted = true;
      })();
    } else {
      this.data.forEach(function (e) {
        return e.kill && e.kill();
      });
    }

    this.clear();

    if (matchMedia) {
      var i = _media.length;

      while (i--) {
        // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.
        _media[i].id === this.id && _media.splice(i, 1);
      }
    }
  } // killWithCleanup() {
  // 	this.kill();
  // 	this._r.forEach(f => f(false, this));
  // }
  ;

  _proto5.revert = function revert(config) {
    this.kill(config || {});
  };

  return Context;
}();

var MatchMedia = /*#__PURE__*/function () {
  function MatchMedia(scope) {
    this.contexts = [];
    this.scope = scope;
    _context && _context.data.push(this);
  }

  var _proto6 = MatchMedia.prototype;

  _proto6.add = function add(conditions, func, scope) {
    _isObject(conditions) || (conditions = {
      matches: conditions
    });
    var context = new Context(0, scope || this.scope),
        cond = context.conditions = {},
        mq,
        p,
        active;
    _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()

    this.contexts.push(context);
    func = context.add("onMatch", func);
    context.queries = conditions;

    for (p in conditions) {
      if (p === "all") {
        active = 1;
      } else {
        mq = _win.matchMedia(conditions[p]);

        if (mq) {
          _media.indexOf(context) < 0 && _media.push(context);
          (cond[p] = mq.matches) && (active = 1);
          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
        }
      }
    }

    active && func(context, function (f) {
      return context.add(null, f);
    });
    return this;
  } // refresh() {
  // 	let time = _lastMediaTime,
  // 		media = _media;
  // 	_lastMediaTime = -1;
  // 	_media = this.contexts;
  // 	_onMediaChange();
  // 	_lastMediaTime = time;
  // 	_media = media;
  // }
  ;

  _proto6.revert = function revert(config) {
    this.kill(config || {});
  };

  _proto6.kill = function kill(revert) {
    this.contexts.forEach(function (c) {
      return c.kill(revert, true);
    });
  };

  return MatchMedia;
}();
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */


var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _setDefaults2;

    var tween = gsap.to(target, _setDefaults((_setDefaults2 = {}, _setDefaults2[property] = "+=0.1", _setDefaults2.paused = true, _setDefaults2.stagger = 0, _setDefaults2), vars || {})),
        func = function func(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };

    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  context: function context(func, scope) {
    return func ? new Context(func, scope) : _context;
  },
  matchMedia: function matchMedia(scope) {
    return new MatchMedia(scope);
  },
  matchMediaRefresh: function matchMediaRefresh() {
    return _media.forEach(function (c) {
      var cond = c.conditions,
          found,
          p;

      for (p in cond) {
        if (cond[p]) {
          cond[p] = false;
          found = 1;
        }
      }

      found && c.revert();
    }) || _onMediaChange();
  },
  addEventListener: function addEventListener(type, callback) {
    var a = _listeners[type] || (_listeners[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  },
  removeEventListener: function removeEventListener(type, callback) {
    var a = _listeners[type],
        i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    reverting: function reverting() {
      return _reverting;
    },
    context: function context(toAdd) {
      if (toAdd && _context) {
        _context.data.push(toAdd);

        toAdd._ctx = _context;
      }

      return _context;
    },
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    headless: 1,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt, v;
    this.tween = tween;

    for (p in vars) {
      v = target.getAttribute(p) || "";
      pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
      pt.op = p;
      pt.b = v; // record the beginning value so we can revert()

      this._props.push(p);
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt;

    while (pt) {
      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)

      pt = pt._next;
    }
  }
}, {
  name: "endArray",
  headless: 1,
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.13.0";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Back: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),
/* harmony export */   Bounce: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),
/* harmony export */   CSSPlugin: () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),
/* harmony export */   Circ: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),
/* harmony export */   Cubic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),
/* harmony export */   Elastic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),
/* harmony export */   Expo: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),
/* harmony export */   Linear: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),
/* harmony export */   Power0: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),
/* harmony export */   Power1: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),
/* harmony export */   Power2: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),
/* harmony export */   Power3: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),
/* harmony export */   Power4: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),
/* harmony export */   Quad: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),
/* harmony export */   Quart: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),
/* harmony export */   Quint: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),
/* harmony export */   Sine: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),
/* harmony export */   SteppedEase: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),
/* harmony export */   Strong: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),
/* harmony export */   TimelineLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),
/* harmony export */   TimelineMax: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),
/* harmony export */   TweenLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),
/* harmony export */   TweenMax: () => (/* binding */ TweenMaxWithCSS),
/* harmony export */   "default": () => (/* binding */ gsapWithCSS),
/* harmony export */   gsap: () => (/* binding */ gsapWithCSS)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");


var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./node_modules/ismobilejs/esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ismobilejs/esm/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _isMobile__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _isMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isMobile */ "./node_modules/ismobilejs/esm/isMobile.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ismobilejs/esm/isMobile.js":
/*!*************************************************!*\
  !*** ./node_modules/ismobilejs/esm/isMobile.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isMobile)
/* harmony export */ });
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
        navigator.platform === 'MacIntel' &&
        typeof navigator.maxTouchPoints === 'number' &&
        navigator.maxTouchPoints > 1 &&
        typeof MSStream === 'undefined');
};
function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
}
function isMobile(param) {
    var nav = {
        userAgent: '',
        platform: '',
        maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
        nav = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
    }
    else if (typeof param === 'string') {
        nav.userAgent = param;
    }
    else if (param && param.userAgent) {
        nav = {
            userAgent: param.userAgent,
            platform: param.platform,
            maxTouchPoints: param.maxTouchPoints || 0
        };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
        apple: {
            phone: match(appleIphone) && !match(windowsPhone),
            ipod: match(appleIpod),
            tablet: !match(appleIphone) &&
                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone),
            universal: match(appleUniversal),
            device: (match(appleIphone) ||
                match(appleIpod) ||
                match(appleTablet) ||
                match(appleUniversal) ||
                isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone)
        },
        amazon: {
            phone: match(amazonPhone),
            tablet: !match(amazonPhone) && match(amazonTablet),
            device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
            phone: (!match(windowsPhone) && match(amazonPhone)) ||
                (!match(windowsPhone) && match(androidPhone)),
            tablet: !match(windowsPhone) &&
                !match(amazonPhone) &&
                !match(androidPhone) &&
                (match(amazonTablet) || match(androidTablet)),
            device: (!match(windowsPhone) &&
                (match(amazonPhone) ||
                    match(amazonTablet) ||
                    match(androidPhone) ||
                    match(androidTablet))) ||
                match(/\bokhttp\b/i)
        },
        windows: {
            phone: match(windowsPhone),
            tablet: match(windowsTablet),
            device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
            blackberry: match(otherBlackBerry),
            blackberry10: match(otherBlackBerry10),
            opera: match(otherOpera),
            firefox: match(otherFirefox),
            chrome: match(otherChrome),
            device: match(otherBlackBerry) ||
                match(otherBlackBerry10) ||
                match(otherOpera) ||
                match(otherFirefox) ||
                match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
    };
    result.any =
        result.apple.device ||
            result.android.device ||
            result.windows.device ||
            result.other.device;
    result.phone =
        result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
        result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
}
//# sourceMappingURL=isMobile.js.map

/***/ }),

/***/ "./node_modules/parse-svg-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/parse-svg-path/index.js ***!
  \**********************************************/
/***/ ((module) => {


module.exports = parse

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = []
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase()
		args = parseValues(args)

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)))
			type = 'l'
			command = command == 'm' ? 'l' : 'L'
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command)
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])))
		}
	})
	return data
}

var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig

function parseValues(args) {
	var numbers = args.match(number)
	return numbers ? numbers.map(Number) : []
}


/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/basis.worker.mjs":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/basis.worker.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerInstance)
/* harmony export */ });
const WORKER_CODE = "(function () {\n    'use strict';\n\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\n      const images = basisTexture.getNumImages();\n      const levels = basisTexture.getNumLevels(0);\n      const success = basisTexture.startTranscoding();\n      if (!success) {\n        throw new Error(\"startTranscoding failed\");\n      }\n      const levelBuffers = [];\n      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\n          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n          const levelBuffer = new Uint8Array(transcodeSize);\n          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n          if (!success2) {\n            throw new Error(\"transcodeImage failed\");\n          }\n          levelBuffers.push(levelBuffer);\n        }\n      }\n      return levelBuffers;\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      \"bc3-rgba-unorm\": 3,\n      // cTFBC3_RGBA\n      \"bc7-rgba-unorm\": 6,\n      // cTFBC7_RGBA,\n      \"etc2-rgba8unorm\": 1,\n      // cTFETC2_RGBA,\n      \"astc-4x4-unorm\": 10,\n      // cTFASTC_4x4_RGBA,\n      // Uncompressed\n      rgba8unorm: 13,\n      // cTFRGBA32,\n      rgba4unorm: 16\n      // cTFRGBA4444,\n    };\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: \"basis/basis_transcoder.js\",\n      wasmUrl: \"basis/basis_transcoder.wasm\"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let basisPromise;\n    async function getBasis() {\n      if (!basisPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        basisPromise = new Promise((resolve) => {\n          BASIS({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((module) => {\n            module.initializeBasis();\n            resolve(module.BasisFile);\n          });\n        });\n      }\n      return basisPromise;\n    }\n    async function fetchBasisTexture(url, BasisTexture) {\n      const basisResponse = await fetch(url);\n      if (basisResponse.ok) {\n        const basisArrayBuffer = await basisResponse.arrayBuffer();\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\n      }\n      throw new Error(`Failed to load Basis texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      \"bc7-rgba-unorm\",\n      \"astc-4x4-unorm\",\n      \"etc2-rgba8unorm\",\n      \"bc3-rgba-unorm\",\n      \"rgba8unorm\"\n    ];\n    async function load(url) {\n      const BasisTexture = await getBasis();\n      const basisTexture = await fetchBasisTexture(url, BasisTexture);\n      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);\n      return {\n        width: basisTexture.getImageWidth(0, 0),\n        height: basisTexture.getImageHeight(0, 0),\n        format: basisTranscodedTextureFormat,\n        resource: levelBuffers,\n        alphaMode: \"no-premultiply-alpha\"\n      };\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getBasis();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: \"load\",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type](message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance
{
    constructor()
    {
        if (!WORKER_URL)
        {
            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL()
{
    if (WORKER_URL)
    {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};


//# sourceMappingURL=basis.worker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerInstance)
/* harmony export */ });
const WORKER_CODE = "(function () {\n    'use strict';\n\n    const WHITE_PNG = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\";\n    async function checkImageBitmap() {\n      try {\n        if (typeof createImageBitmap !== \"function\")\n          return false;\n        const response = await fetch(WHITE_PNG);\n        const imageBlob = await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\n      } catch (_e) {\n        return false;\n      }\n    }\n    void checkImageBitmap().then((result) => {\n      self.postMessage(result);\n    });\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance
{
    constructor()
    {
        if (!WORKER_URL)
        {
            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL()
{
    if (WORKER_URL)
    {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};


//# sourceMappingURL=checkImageBitmap.worker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/ktx.worker.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/ktx.worker.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerInstance)
/* harmony export */ });
const WORKER_CODE = "(function () {\n    'use strict';\n\n    const converters = {\n      rgb8unorm: {\n        convertedFormat: \"rgba8unorm\",\n        convertFunction: convertRGBtoRGBA\n      },\n      \"rgb8unorm-srgb\": {\n        convertedFormat: \"rgba8unorm-srgb\",\n        convertFunction: convertRGBtoRGBA\n      }\n    };\n    function convertFormatIfRequired(textureOptions) {\n      const format = textureOptions.format;\n      if (converters[format]) {\n        const convertFunction = converters[format].convertFunction;\n        const levelBuffers = textureOptions.resource;\n        for (let i = 0; i < levelBuffers.length; i++) {\n          levelBuffers[i] = convertFunction(levelBuffers[i]);\n        }\n        textureOptions.format = converters[format].convertedFormat;\n      }\n    }\n    function convertRGBtoRGBA(levelBuffer) {\n      const pixelCount = levelBuffer.byteLength / 3;\n      const levelBufferWithAlpha = new Uint32Array(pixelCount);\n      for (let i = 0; i < pixelCount; ++i) {\n        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\n      }\n      return new Uint8Array(levelBufferWithAlpha.buffer);\n    }\n\n    function createLevelBuffersFromKTX(ktxTexture) {\n      const levelBuffers = [];\n      for (let i = 0; i < ktxTexture.numLevels; i++) {\n        const imageData = ktxTexture.getImageData(i, 0, 0);\n        const levelBuffer = new Uint8Array(imageData.byteLength);\n        levelBuffer.set(imageData);\n        levelBuffers.push(levelBuffer);\n      }\n      return levelBuffers;\n    }\n\n    const glFormatToGPUFormatMap = {\n      6408: \"rgba8unorm\",\n      32856: \"bgra8unorm\",\n      //\n      32857: \"rgb10a2unorm\",\n      33189: \"depth16unorm\",\n      33190: \"depth24plus\",\n      33321: \"r8unorm\",\n      33323: \"rg8unorm\",\n      33325: \"r16float\",\n      33326: \"r32float\",\n      33327: \"rg16float\",\n      33328: \"rg32float\",\n      33329: \"r8sint\",\n      33330: \"r8uint\",\n      33331: \"r16sint\",\n      33332: \"r16uint\",\n      33333: \"r32sint\",\n      33334: \"r32uint\",\n      33335: \"rg8sint\",\n      33336: \"rg8uint\",\n      33337: \"rg16sint\",\n      33338: \"rg16uint\",\n      33339: \"rg32sint\",\n      33340: \"rg32uint\",\n      33778: \"bc2-rgba-unorm\",\n      33779: \"bc3-rgba-unorm\",\n      34836: \"rgba32float\",\n      34842: \"rgba16float\",\n      35056: \"depth24plus-stencil8\",\n      35898: \"rg11b10ufloat\",\n      35901: \"rgb9e5ufloat\",\n      35907: \"rgba8unorm-srgb\",\n      // bgra8unorm-srgb\n      36012: \"depth32float\",\n      36013: \"depth32float-stencil8\",\n      36168: \"stencil8\",\n      36208: \"rgba32uint\",\n      36214: \"rgba16uint\",\n      36220: \"rgba8uint\",\n      36226: \"rgba32sint\",\n      36232: \"rgba16sint\",\n      36238: \"rgba8sint\",\n      36492: \"bc7-rgba-unorm\",\n      36756: \"r8snorm\",\n      36757: \"rg8snorm\",\n      36759: \"rgba8snorm\",\n      37496: \"etc2-rgba8unorm\",\n      37808: \"astc-4x4-unorm\"\n    };\n    function glFormatToGPUFormat(glInternalFormat) {\n      const format = glFormatToGPUFormatMap[glInternalFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n    }\n\n    const vkFormatToGPUFormatMap = {\n      23: \"rgb8unorm\",\n      // VK_FORMAT_R8G8B8_UNORM\n      37: \"rgba8unorm\",\n      // VK_FORMAT_R8G8B8A8_UNORM\n      43: \"rgba8unorm-srgb\"\n      // VK_FORMAT_R8G8B8A8_SRGB\n      // TODO add more!\n    };\n    function vkFormatToGPUFormat(vkFormat) {\n      const format = vkFormatToGPUFormatMap[vkFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n    }\n\n    function getTextureFormatFromKTXTexture(ktxTexture) {\n      if (ktxTexture.classId === 2) {\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\n      }\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      \"bc3-rgba-unorm\": \"BC3_RGBA\",\n      \"bc7-rgba-unorm\": \"BC7_M5_RGBA\",\n      \"etc2-rgba8unorm\": \"ETC2_RGBA\",\n      \"astc-4x4-unorm\": \"ASTC_4x4_RGBA\",\n      // Uncompressed\n      rgba8unorm: \"RGBA32\",\n      rg11b10ufloat: \"R11F_G11F_B10F\"\n    };\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: \"\",\n      wasmUrl: \"\"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let ktxPromise;\n    async function getKTX() {\n      if (!ktxPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        ktxPromise = new Promise((resolve) => {\n          LIBKTX({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((libktx) => {\n            resolve(libktx);\n          });\n        });\n      }\n      return ktxPromise;\n    }\n    async function fetchKTXTexture(url, ktx) {\n      const ktx2Response = await fetch(url);\n      if (ktx2Response.ok) {\n        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\n      }\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      \"bc7-rgba-unorm\",\n      \"astc-4x4-unorm\",\n      \"etc2-rgba8unorm\",\n      \"bc3-rgba-unorm\",\n      \"rgba8unorm\"\n    ];\n    async function load(url) {\n      const ktx = await getKTX();\n      const ktxTexture = await fetchKTXTexture(url, ktx);\n      let format;\n      if (ktxTexture.needsTranscoding) {\n        format = basisTranscodedTextureFormat;\n        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];\n        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\n        if (result !== ktx.ErrorCode.SUCCESS) {\n          throw new Error(\"Unable to transcode basis texture.\");\n        }\n      } else {\n        format = getTextureFormatFromKTXTexture(ktxTexture);\n      }\n      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);\n      const textureOptions = {\n        width: ktxTexture.baseWidth,\n        height: ktxTexture.baseHeight,\n        format,\n        mipLevelCount: ktxTexture.numLevels,\n        resource: levelBuffers,\n        alphaMode: \"no-premultiply-alpha\"\n      };\n      convertFormatIfRequired(textureOptions);\n      return textureOptions;\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getKTX();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: \"load\",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type]?.(message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance
{
    constructor()
    {
        if (!WORKER_URL)
        {
            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL()
{
    if (WORKER_URL)
    {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};


//# sourceMappingURL=ktx.worker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerInstance)
/* harmony export */ });
const WORKER_CODE = "(function () {\n    'use strict';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === \"premultiplied-alpha\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \"none\" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n";
let WORKER_URL = null;
class WorkerInstance
{
    constructor()
    {
        if (!WORKER_URL)
        {
            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));
        }
        this.worker = new Worker(WORKER_URL);
    }
}
WorkerInstance.revokeObjectURL = function revokeObjectURL()
{
    if (WORKER_URL)
    {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
    }
};


//# sourceMappingURL=loadImageBitmap.worker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessibilitySystem: () => (/* binding */ AccessibilitySystem)
/* harmony export */ });
/* harmony import */ var _events_FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/FederatedEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedEvent.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_browser_isMobile_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/browser/isMobile.mjs */ "./node_modules/pixi.js/lib/utils/browser/isMobile.mjs");
/* harmony import */ var _utils_data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/data/removeItems.mjs */ "./node_modules/pixi.js/lib/utils/data/removeItems.mjs");





"use strict";
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
const _AccessibilitySystem = class _AccessibilitySystem {
  // 2fps
  // eslint-disable-next-line jsdoc/require-param
  /**
   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
   */
  constructor(renderer, _mobileInfo = _utils_browser_isMobile_mjs__WEBPACK_IMPORTED_MODULE_0__.isMobile) {
    this._mobileInfo = _mobileInfo;
    /** Whether accessibility divs are visible for debugging */
    this.debug = false;
    /** Whether to activate on tab key press */
    this._activateOnTab = true;
    /** Whether to deactivate accessibility when mouse moves */
    this._deactivateOnMouseMove = true;
    /** Internal variable, see isActive getter. */
    this._isActive = false;
    /** Internal variable, see isMobileAccessibility getter. */
    this._isMobileAccessibility = false;
    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */
    this._div = null;
    /** A simple pool for storing divs. */
    this._pool = [];
    /** This is a tick used to check if an object is no longer being rendered. */
    this._renderId = 0;
    /** The array of currently active accessible items. */
    this._children = [];
    /** Count to throttle div updates on android devices. */
    this._androidUpdateCount = 0;
    /**  The frequency to update the div elements. */
    this._androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (_mobileInfo.tablet || _mobileInfo.phone) {
      this._createTouchHook();
    }
    this._renderer = renderer;
  }
  /**
   * Value of `true` if accessibility is currently active and accessibility layers are showing.
   * @member {boolean}
   * @readonly
   */
  get isActive() {
    return this._isActive;
  }
  /**
   * Value of `true` if accessibility is enabled for touch devices.
   * @member {boolean}
   * @readonly
   */
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  get hookDiv() {
    return this._hookDiv;
  }
  /**
   * Creates the touch hooks.
   * @private
   */
  _createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this._activate();
      this._destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  /**
   * Destroys the touch hooks.
   * @private
   */
  _destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  /**
   * Activating will cause the Accessibility layer to be shown.
   * This is called when a user presses the tab key.
   * @private
   */
  _activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    if (!this._div) {
      this._div = document.createElement("div");
      this._div.style.width = `${DIV_TOUCH_SIZE}px`;
      this._div.style.height = `${DIV_TOUCH_SIZE}px`;
      this._div.style.position = "absolute";
      this._div.style.top = `${DIV_TOUCH_POS_X}px`;
      this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
      this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      this._div.style.pointerEvents = "none";
    }
    if (this._activateOnTab) {
      this._onKeyDown = this._onKeyDown.bind(this);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    if (this._deactivateOnMouseMove) {
      this._onMouseMove = this._onMouseMove.bind(this);
      globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    }
    const canvas = this._renderer.view.canvas;
    if (!canvas.parentNode) {
      const observer = new MutationObserver(() => {
        if (canvas.parentNode) {
          canvas.parentNode.appendChild(this._div);
          observer.disconnect();
          this._initAccessibilitySetup();
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });
    } else {
      canvas.parentNode.appendChild(this._div);
      this._initAccessibilitySetup();
    }
  }
  // New method to handle initialization after div is ready
  _initAccessibilitySetup() {
    this._renderer.runners.postrender.add(this);
    if (this._renderer.lastObjectRendered) {
      this._updateAccessibleObjects(this._renderer.lastObjectRendered);
    }
  }
  /**
   * Deactivates the accessibility system. Removes listeners and accessibility elements.
   * @private
   */
  _deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    if (this._activateOnTab) {
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    this._renderer.runners.postrender.remove(this);
    for (const child of this._children) {
      if (child._accessibleDiv && child._accessibleDiv.parentNode) {
        child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
        child._accessibleDiv = null;
      }
      child._accessibleActive = false;
    }
    this._pool.forEach((div) => {
      if (div.parentNode) {
        div.parentNode.removeChild(div);
      }
    });
    if (this._div && this._div.parentNode) {
      this._div.parentNode.removeChild(this._div);
    }
    this._pool = [];
    this._children = [];
  }
  /**
   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
   * @private
   * @param {Container} container - The Container to check.
   */
  _updateAccessibleObjects(container) {
    if (!container.visible || !container.accessibleChildren) {
      return;
    }
    if (container.accessible) {
      if (!container._accessibleActive) {
        this._addChild(container);
      }
      container._renderId = this._renderId;
    }
    const children = container.children;
    if (children) {
      for (let i = 0; i < children.length; i++) {
        this._updateAccessibleObjects(children[i]);
      }
    }
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(options) {
    const defaultOpts = _AccessibilitySystem.defaultOptions;
    const mergedOptions = {
      accessibilityOptions: {
        ...defaultOpts,
        ...options?.accessibilityOptions || {}
      }
    };
    this.debug = mergedOptions.accessibilityOptions.debug;
    this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
    this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
    if (mergedOptions.accessibilityOptions.enabledByDefault) {
      this._activate();
    } else if (this._activateOnTab) {
      this._onKeyDown = this._onKeyDown.bind(this);
      globalThis.addEventListener("keydown", this._onKeyDown, false);
    }
    this._renderer.runners.postrender.remove(this);
  }
  /**
   * Updates the accessibility layer during rendering.
   * - Removes divs for containers no longer in the scene
   * - Updates the position and dimensions of the root div
   * - Updates positions of active accessibility divs
   * Only fires while the accessibility system is active.
   * @ignore
   */
  postrender() {
    const now = performance.now();
    if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
      return;
    }
    this._androidUpdateCount = now + this._androidUpdateFrequency;
    if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
      return;
    }
    const activeIds = /* @__PURE__ */ new Set();
    if (this._renderer.lastObjectRendered) {
      this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      for (const child of this._children) {
        if (child._renderId === this._renderId) {
          activeIds.add(this._children.indexOf(child));
        }
      }
    }
    for (let i = this._children.length - 1; i >= 0; i--) {
      const child = this._children[i];
      if (!activeIds.has(i)) {
        if (child._accessibleDiv && child._accessibleDiv.parentNode) {
          child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
          this._pool.push(child._accessibleDiv);
          child._accessibleDiv = null;
        }
        child._accessibleActive = false;
        (0,_utils_data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_1__.removeItems)(this._children, i, 1);
      }
    }
    if (this._renderer.renderingToScreen) {
      const { x, y, width: viewWidth, height: viewHeight } = this._renderer.screen;
      const div = this._div;
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.width = `${viewWidth}px`;
      div.style.height = `${viewHeight}px`;
    }
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      if (!child._accessibleActive || !child._accessibleDiv) {
        continue;
      }
      const div = child._accessibleDiv;
      const hitArea = child.hitArea || child.getBounds().rectangle;
      if (child.hitArea) {
        const wt = child.worldTransform;
        const sx = this._renderer.resolution;
        const sy = this._renderer.resolution;
        div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
        div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
        div.style.width = `${hitArea.width * wt.a * sx}px`;
        div.style.height = `${hitArea.height * wt.d * sy}px`;
      } else {
        this._capHitArea(hitArea);
        const sx = this._renderer.resolution;
        const sy = this._renderer.resolution;
        div.style.left = `${hitArea.x * sx}px`;
        div.style.top = `${hitArea.y * sy}px`;
        div.style.width = `${hitArea.width * sx}px`;
        div.style.height = `${hitArea.height * sy}px`;
      }
    }
    this._renderId++;
  }
  /**
   * private function that will visually add the information to the
   * accessibility div
   * @param {HTMLElement} div -
   */
  _updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  /**
   * Adjust the hit area based on the bounds of a display object
   * @param {Rectangle} hitArea - Bounds of the child
   */
  _capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this._renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  /**
   * Creates or reuses a div element for a Container and adds it to the accessibility layer.
   * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.
   * @private
   * @param {Container} container - The child to make accessible.
   */
  _addChild(container) {
    let div = this._pool.pop();
    if (!div) {
      if (container.accessibleType === "button") {
        div = document.createElement("button");
      } else {
        div = document.createElement(container.accessibleType);
        div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
        if (container.accessibleText) {
          div.innerText = container.accessibleText;
        }
      }
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = container.accessiblePointerEvents;
    div.type = container.accessibleType;
    if (container.accessibleTitle && container.accessibleTitle !== null) {
      div.title = container.accessibleTitle;
    } else if (!container.accessibleHint || container.accessibleHint === null) {
      div.title = `container ${container.tabIndex}`;
    }
    if (container.accessibleHint && container.accessibleHint !== null) {
      div.setAttribute("aria-label", container.accessibleHint);
    }
    if (this.debug) {
      this._updateDebugHTML(div);
    }
    container._accessibleActive = true;
    container._accessibleDiv = div;
    div.container = container;
    this._children.push(container);
    this._div.appendChild(container._accessibleDiv);
    if (container.interactive) {
      container._accessibleDiv.tabIndex = container.tabIndex;
    }
  }
  /**
   * Dispatch events with the EventSystem.
   * @param e
   * @param type
   * @private
   */
  _dispatchEvent(e, type) {
    const { container: target } = e.target;
    const boundary = this._renderer.events.rootBoundary;
    const event = Object.assign(new _events_FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_2__.FederatedEvent(boundary), { target });
    boundary.rootTarget = this._renderer.lastObjectRendered;
    type.forEach((type2) => boundary.dispatchEvent(event, type2));
  }
  /**
   * Maps the div button press to pixi's EventSystem (click)
   * @private
   * @param {MouseEvent} e - The click event.
   */
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseover)
   * @private
   * @param {FocusEvent} e - The focus event.
   */
  _onFocus(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e, ["mouseover"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseout)
   * @private
   * @param {FocusEvent} e - The focusout event.
   */
  _onFocusOut(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e, ["mouseout"]);
  }
  /**
   * Is called when a key is pressed
   * @private
   * @param {KeyboardEvent} e - The keydown event.
   */
  _onKeyDown(e) {
    if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
      return;
    }
    this._activate();
  }
  /**
   * Is called when the mouse moves across the renderer element
   * @private
   * @param {MouseEvent} e - The mouse event.
   */
  _onMouseMove(e) {
    if (e.movementX === 0 && e.movementY === 0) {
      return;
    }
    this._deactivate();
  }
  /** Destroys the accessibility system. Removes all elements and listeners. */
  destroy() {
    this._deactivate();
    this._destroyTouchHook();
    this._div = null;
    this._pool = null;
    this._children = null;
    this._renderer = null;
    if (this._activateOnTab) {
      globalThis.removeEventListener("keydown", this._onKeyDown);
    }
  }
  /**
   * Enables or disables the accessibility system.
   * @param enabled - Whether to enable or disable accessibility.
   */
  setAccessibilityEnabled(enabled) {
    if (enabled) {
      this._activate();
    } else {
      this._deactivate();
    }
  }
};
/** @ignore */
_AccessibilitySystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGPUSystem
  ],
  name: "accessibility"
};
/** default options used by the system */
_AccessibilitySystem.defaultOptions = {
  /**
   * Whether to enable accessibility features on initialization
   * @default false
   */
  enabledByDefault: false,
  /**
   * Whether to visually show the accessibility divs for debugging
   * @default false
   */
  debug: false,
  /**
   * Whether to activate accessibility when tab key is pressed
   * @default true
   */
  activateOnTab: true,
  /**
   * Whether to deactivate accessibility when mouse moves
   * @default true
   */
  deactivateOnMouseMove: true
};
let AccessibilitySystem = _AccessibilitySystem;


//# sourceMappingURL=AccessibilitySystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   accessibilityTarget: () => (/* binding */ accessibilityTarget)
/* harmony export */ });

const accessibilityTarget = {
  /**
   * Flag for if the object is accessible. If true AccessibilityManager will overlay a
   * shadow div with attributes set
   * @member {boolean}
   * @memberof scene.Container#
   */
  accessible: false,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
   * @member {string}
   * @memberof scene.Container#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof scene.Container#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof scene.Container#
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof scene.Container#
   * @private
   */
  _accessibleActive: false,
  /**
   * @memberof scene.Container#
   * @private
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof scene.Container#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Sets the text content of the shadow div
   * @member {string}
   * @memberof scene.Container#
   */
  accessibleText: null,
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @type {PointerEvents}
   * @memberof scene.Container#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof scene.Container#
   * @default true
   */
  accessibleChildren: true,
  /**
   * @member {number}
   * @memberof scene.Container#
   * @private
   */
  _renderId: -1
};


//# sourceMappingURL=accessibilityTarget.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorBlend: () => (/* binding */ ColorBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");
/* harmony import */ var _filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filters/blend-modes/hls/GLhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs");
/* harmony import */ var _filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../filters/blend-modes/hls/GPUhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs");





"use strict";
class ColorBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                ${_filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_1__.hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                ${_filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_2__.hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
ColorBlend.extension = {
  name: "color",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.BlendMode
};


//# sourceMappingURL=ColorBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorBurnBlend: () => (/* binding */ ColorBurnBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class ColorBurnBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
      },
      gpu: {
        functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
ColorBurnBlend.extension = {
  name: "color-burn",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=ColorBurnBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorDodgeBlend: () => (/* binding */ ColorDodgeBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class ColorDodgeBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
ColorDodgeBlend.extension = {
  name: "color-dodge",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=ColorDodgeBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DarkenBlend: () => (/* binding */ DarkenBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class DarkenBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
DarkenBlend.extension = {
  name: "darken",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=DarkenBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DifferenceBlend: () => (/* binding */ DifferenceBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class DifferenceBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
      },
      gpu: {
        functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
DifferenceBlend.extension = {
  name: "difference",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=DifferenceBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DivideBlend: () => (/* binding */ DivideBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class DivideBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
DivideBlend.extension = {
  name: "divide",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=DivideBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExclusionBlend: () => (/* binding */ ExclusionBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class ExclusionBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
ExclusionBlend.extension = {
  name: "exclusion",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=ExclusionBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HardLightBlend: () => (/* binding */ HardLightBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class HardLightBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
      },
      gpu: {
        functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
HardLightBlend.extension = {
  name: "hard-light",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=HardLightBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HardMixBlend: () => (/* binding */ HardMixBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class HardMixBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
      },
      gpu: {
        functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
HardMixBlend.extension = {
  name: "hard-mix",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=HardMixBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LightenBlend: () => (/* binding */ LightenBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class LightenBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
LightenBlend.extension = {
  name: "lighten",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=LightenBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinearBurnBlend: () => (/* binding */ LinearBurnBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class LinearBurnBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
LinearBurnBlend.extension = {
  name: "linear-burn",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=LinearBurnBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinearDodgeBlend: () => (/* binding */ LinearDodgeBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class LinearDodgeBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
LinearDodgeBlend.extension = {
  name: "linear-dodge",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=LinearDodgeBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LinearLightBlend: () => (/* binding */ LinearLightBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class LinearLightBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
LinearLightBlend.extension = {
  name: "linear-light",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=LinearLightBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LuminosityBlend: () => (/* binding */ LuminosityBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");
/* harmony import */ var _filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filters/blend-modes/hls/GLhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs");
/* harmony import */ var _filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../filters/blend-modes/hls/GPUhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs");





"use strict";
class LuminosityBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                ${_filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_1__.hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                ${_filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_2__.hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
LuminosityBlend.extension = {
  name: "luminosity",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.BlendMode
};


//# sourceMappingURL=LuminosityBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NegationBlend: () => (/* binding */ NegationBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class NegationBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
NegationBlend.extension = {
  name: "negation",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=NegationBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OverlayBlend: () => (/* binding */ OverlayBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class OverlayBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );
   
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
OverlayBlend.extension = {
  name: "overlay",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=OverlayBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PinLightBlend: () => (/* binding */ PinLightBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class PinLightBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
PinLightBlend.extension = {
  name: "pin-light",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=PinLightBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SaturationBlend: () => (/* binding */ SaturationBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");
/* harmony import */ var _filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filters/blend-modes/hls/GLhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs");
/* harmony import */ var _filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../filters/blend-modes/hls/GPUhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs");





"use strict";
class SaturationBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                ${_filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_1__.hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
            `
      },
      gpu: {
        functions: `
                ${_filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_2__.hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
      }
    });
  }
}
/** @ignore */
SaturationBlend.extension = {
  name: "saturation",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.BlendMode
};


//# sourceMappingURL=SaturationBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SoftLightBlend: () => (/* binding */ SoftLightBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class SoftLightBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
SoftLightBlend.extension = {
  name: "soft-light",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=SoftLightBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SubtractBlend: () => (/* binding */ SubtractBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class SubtractBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
      },
      gpu: {
        functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
SubtractBlend.extension = {
  name: "subtract",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=SubtractBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VividLightBlend: () => (/* binding */ VividLightBlend)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");



"use strict";
class VividLightBlend extends _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
      },
      gpu: {
        functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
      }
    });
  }
}
/** @ignore */
VividLightBlend.extension = {
  name: "vivid-light",
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.BlendMode
};


//# sourceMappingURL=VividLightBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/app/Application.mjs":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/app/Application.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Application: () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_autoDetectRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rendering/renderers/autoDetectRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs");
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _utils_global_globalHooks_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/global/globalHooks.mjs */ "./node_modules/pixi.js/lib/utils/global/globalHooks.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");






"use strict";
const _Application = class _Application {
  /** @ignore */
  constructor(...args) {
    /** The root display container that's rendered. */
    this.stage = new _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__.Container();
    if (args[0] !== void 0) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
    }
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(options) {
    options = { ...options };
    this.renderer = await (0,_rendering_renderers_autoDetectRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__.autoDetectRenderer)(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @readonly
   * @member {HTMLCanvasElement}
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {HTMLCanvasElement}
   * @deprecated since 8.0.0
   */
  get view() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @readonly
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
   * @param {object|boolean} [options=false] - The options for destroying the stage.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */
  destroy(rendererDestroyOptions = false, options = false) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(rendererDestroyOptions);
    this.renderer = null;
  }
};
/**
 * Collection of installed plugins.
 * @alias _plugins
 */
_Application._plugins = [];
let Application = _Application;
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.extensions.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.Application, Application._plugins);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.extensions.add(_utils_global_globalHooks_mjs__WEBPACK_IMPORTED_MODULE_4__.ApplicationInitHook);


//# sourceMappingURL=Application.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/app/ResizePlugin.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/app/ResizePlugin.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResizePlugin: () => (/* binding */ ResizePlugin)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class ResizePlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    Object.defineProperty(
      this,
      "resizeTo",
      /**
       * The HTML element or window to automatically resize the
       * renderer's view element to match width and height.
       * @member {Window|HTMLElement}
       * @name resizeTo
       * @memberof app.Application#
       */
      {
        set(dom) {
          globalThis.removeEventListener("resize", this.queueResize);
          this._resizeTo = dom;
          if (dom) {
            globalThis.addEventListener("resize", this.queueResize);
            this.resize();
          }
        },
        get() {
          return this._resizeTo;
        }
      }
    );
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this._cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this._cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this._cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  /**
   * Clean up the ticker, scoped to application
   * @static
   * @private
   */
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this._cancelResize();
    this._cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
/** @ignore */
ResizePlugin.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Application;


//# sourceMappingURL=ResizePlugin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/app/TickerPlugin.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/app/TickerPlugin.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TickerPlugin: () => (/* binding */ TickerPlugin)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ticker/const.mjs */ "./node_modules/pixi.js/lib/ticker/const.mjs");
/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ticker/Ticker.mjs */ "./node_modules/pixi.js/lib/ticker/Ticker.mjs");




"use strict";
class TickerPlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(
      this,
      "ticker",
      {
        set(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_PRIORITY.LOW);
          }
        },
        get() {
          return this._ticker;
        }
      }
    );
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__.Ticker.shared : new _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__.Ticker();
    if (options.autoStart) {
      this.start();
    }
  }
  /**
   * Clean up the ticker, scoped to application.
   * @static
   * @private
   */
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
/** @ignore */
TickerPlugin.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.Application;


//# sourceMappingURL=TickerPlugin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/Assets.mjs":
/*!****************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/Assets.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Assets: () => (/* binding */ Assets),
/* harmony export */   AssetsClass: () => (/* binding */ AssetsClass)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _scene_text_bitmap_asset_loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../scene/text-bitmap/asset/loadBitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _BackgroundLoader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BackgroundLoader.mjs */ "./node_modules/pixi.js/lib/assets/BackgroundLoader.mjs");
/* harmony import */ var _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _cache_parsers_cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cache/parsers/cacheTextureArray.mjs */ "./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs");
/* harmony import */ var _detections_parsers_detectAvif_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./detections/parsers/detectAvif.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs");
/* harmony import */ var _detections_parsers_detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./detections/parsers/detectDefaults.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs");
/* harmony import */ var _detections_parsers_detectMp4_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./detections/parsers/detectMp4.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs");
/* harmony import */ var _detections_parsers_detectOgv_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./detections/parsers/detectOgv.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs");
/* harmony import */ var _detections_parsers_detectWebm_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./detections/parsers/detectWebm.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs");
/* harmony import */ var _detections_parsers_detectWebp_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./detections/parsers/detectWebp.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs");
/* harmony import */ var _loader_Loader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader/Loader.mjs */ "./node_modules/pixi.js/lib/assets/loader/Loader.mjs");
/* harmony import */ var _loader_parsers_loadJson_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./loader/parsers/loadJson.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs");
/* harmony import */ var _loader_parsers_loadTxt_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./loader/parsers/loadTxt.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs");
/* harmony import */ var _loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./loader/parsers/loadWebFont.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs");
/* harmony import */ var _loader_parsers_textures_loadSVG_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./loader/parsers/textures/loadSVG.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs");
/* harmony import */ var _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs");
/* harmony import */ var _loader_parsers_textures_loadVideoTextures_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./loader/parsers/textures/loadVideoTextures.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs");
/* harmony import */ var _resolver_parsers_resolveJsonUrl_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./resolver/parsers/resolveJsonUrl.mjs */ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs");
/* harmony import */ var _resolver_parsers_resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./resolver/parsers/resolveTextureUrl.mjs */ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs");
/* harmony import */ var _resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resolver/Resolver.mjs */ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/convertToList.mjs */ "./node_modules/pixi.js/lib/assets/utils/convertToList.mjs");
/* harmony import */ var _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/isSingleItem.mjs */ "./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs");

























"use strict";
class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new _resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_0__.Resolver();
    this.loader = new _loader_Loader_mjs__WEBPACK_IMPORTED_MODULE_1__.Loader();
    this.cache = _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache;
    this._backgroundLoader = new _BackgroundLoader_mjs__WEBPACK_IMPORTED_MODULE_3__.BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Assets class to work, only if you want to set any initial properties
   * @param options - options to initialize the Assets manager with
   */
  async init(options = {}) {
    if (this._initialized) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__.warn)("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    const formats = await this._detectFormats({
      preferredFormats: options.texturePreference?.format,
      skipDetections: options.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  /**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny.{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */
  add(assets) {
    this.resolver.add(assets);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_5__.isSingleItem)(urls);
    const urlArray = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__.convertToList)(urls).map((url) => {
      if (typeof url !== "string") {
        const aliases = this.resolver.getAlias(url);
        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
          this.add(url);
        }
        return Array.isArray(aliases) ? aliases[0] : aliases;
      }
      if (!this.resolver.hasKey(url))
        this.add({ alias: url, src: url });
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Assets.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your initial load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.get(keys);
    }
    const assets = {};
    for (let i = 0; i < keys.length; i++) {
      assets[i] = _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.get(keys[i]);
    }
    return assets;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = [...new Set(Object.values(resolveResults))];
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult) => {
      const asset = loadedAssets[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      keys.forEach((key) => {
        out[key] = asset;
      });
      _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.set(keys, asset);
    });
    return out;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__.convertToList)(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__.convertToList)(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(options) {
    let formats = [];
    if (options.preferredFormats) {
      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
    }
    for (const detection of options.detections) {
      if (options.skipDetections || await detection.test()) {
        formats = await detection.add(formats);
      } else if (!options.skipDetections) {
        formats = await detection.remove(formats);
      }
    }
    formats = formats.filter((format, index) => formats.indexOf(format) === index);
    return formats;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.extensions.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.DetectionParser, Assets.detections);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.extensions.add(
  _cache_parsers_cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_8__.cacheTextureArray,
  _detections_parsers_detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_9__.detectDefaults,
  _detections_parsers_detectAvif_mjs__WEBPACK_IMPORTED_MODULE_10__.detectAvif,
  _detections_parsers_detectWebp_mjs__WEBPACK_IMPORTED_MODULE_11__.detectWebp,
  _detections_parsers_detectMp4_mjs__WEBPACK_IMPORTED_MODULE_12__.detectMp4,
  _detections_parsers_detectOgv_mjs__WEBPACK_IMPORTED_MODULE_13__.detectOgv,
  _detections_parsers_detectWebm_mjs__WEBPACK_IMPORTED_MODULE_14__.detectWebm,
  _loader_parsers_loadJson_mjs__WEBPACK_IMPORTED_MODULE_15__.loadJson,
  _loader_parsers_loadTxt_mjs__WEBPACK_IMPORTED_MODULE_16__.loadTxt,
  _loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_17__.loadWebFont,
  _loader_parsers_textures_loadSVG_mjs__WEBPACK_IMPORTED_MODULE_18__.loadSvg,
  _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_19__.loadTextures,
  _loader_parsers_textures_loadVideoTextures_mjs__WEBPACK_IMPORTED_MODULE_20__.loadVideoTextures,
  _scene_text_bitmap_asset_loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_21__.loadBitmapFont,
  _scene_text_bitmap_asset_loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_21__.bitmapFontCachePlugin,
  _resolver_parsers_resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_22__.resolveTextureUrl,
  _resolver_parsers_resolveJsonUrl_mjs__WEBPACK_IMPORTED_MODULE_23__.resolveJsonUrl
);
const assetKeyMap = {
  loader: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.LoadParser,
  resolver: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.ResolveParser,
  cache: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.CacheParser,
  detection: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.DetectionParser
};
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.extensions.handle(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.extensions.add(Object.assign(
    ref[key],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: ref[key].extension ?? type }
  )));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.extensions.remove(ref[key]));
});


//# sourceMappingURL=Assets.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/BackgroundLoader.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/BackgroundLoader.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundLoader: () => (/* binding */ BackgroundLoader)
/* harmony export */ });

class BackgroundLoader {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(assetUrls) {
    assetUrls.forEach((a) => {
      this._assetList.push(a);
    });
    if (this.verbose) {
      console.log("[BackgroundLoader] assets: ", this._assetList);
    }
    if (this._isActive && !this._isLoading) {
      void this._next();
    }
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < toLoadAmount; i++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      void this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      void this._next();
    }
  }
}


//# sourceMappingURL=BackgroundLoader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/cache/Cache.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cache: () => (/* binding */ Cache)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/convertToList.mjs */ "./node_modules/pixi.js/lib/assets/utils/convertToList.mjs");



"use strict";
class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(key) {
    return this._cache.has(key);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(key, value) {
    const keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__.convertToList)(key);
    let cacheableAssets;
    for (let i = 0; i < this.parsers.length; i++) {
      const parser = this.parsers[i];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
    if (!cacheableAssets) {
      keys.forEach((key2) => {
        cacheableMap.set(key2, value);
      });
    }
    const cacheKeys = [...cacheableMap.keys()];
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      const val = cacheableAssets ? cacheableAssets[key2] : value;
      if (this._cache.has(key2) && this._cache.get(key2) !== val) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableMap.get(key2));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(key) {
    if (!this._cacheMap.has(key)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  /** All loader parsers registered */
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();


//# sourceMappingURL=Cache.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cacheTextureArray: () => (/* binding */ cacheTextureArray)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");



"use strict";
const cacheTextureArray = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CacheParser,
    name: "cacheTextureArray"
  },
  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    keys.forEach((key) => {
      asset.forEach((item, i) => {
        out[key + (i === 0 ? "" : i + 1)] = item;
      });
    });
    return out;
  }
};


//# sourceMappingURL=cacheTextureArray.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectAvif: () => (/* binding */ detectAvif)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_testImageFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/testImageFormat.mjs */ "./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs");



"use strict";
const detectAvif = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => (0,_utils_testImageFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.testImageFormat)(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f) => f !== "avif")
};


//# sourceMappingURL=detectAvif.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectDefaults: () => (/* binding */ detectDefaults)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))
};


//# sourceMappingURL=detectDefaults.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectMp4: () => (/* binding */ detectMp4)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/testVideoFormat.mjs */ "./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs");



"use strict";
const detectMp4 = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => (0,_utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.testVideoFormat)("video/mp4"),
  add: async (formats) => [...formats, "mp4", "m4v"],
  remove: async (formats) => formats.filter((f) => f !== "mp4" && f !== "m4v")
};


//# sourceMappingURL=detectMp4.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectOgv: () => (/* binding */ detectOgv)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/testVideoFormat.mjs */ "./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs");



"use strict";
const detectOgv = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => (0,_utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.testVideoFormat)("video/ogg"),
  add: async (formats) => [...formats, "ogv"],
  remove: async (formats) => formats.filter((f) => f !== "ogv")
};


//# sourceMappingURL=detectOgv.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectWebm: () => (/* binding */ detectWebm)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/testVideoFormat.mjs */ "./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs");



"use strict";
const detectWebm = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => (0,_utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.testVideoFormat)("video/webm"),
  add: async (formats) => [...formats, "webm"],
  remove: async (formats) => formats.filter((f) => f !== "webm")
};


//# sourceMappingURL=detectWebm.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectWebp: () => (/* binding */ detectWebp)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_testImageFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/testImageFormat.mjs */ "./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs");



"use strict";
const detectWebp = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => (0,_utils_testImageFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.testImageFormat)(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f) => f !== "webp")
};


//# sourceMappingURL=detectWebp.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   testImageFormat: () => (/* binding */ testImageFormat)
/* harmony export */ });

async function testImageFormat(imageData) {
  if ("Image" in globalThis) {
    return new Promise((resolve) => {
      const image = new Image();
      image.onload = () => {
        resolve(true);
      };
      image.onerror = () => {
        resolve(false);
      };
      image.src = imageData;
    });
  }
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch (_e) {
      return false;
    }
    return true;
  }
  return false;
}


//# sourceMappingURL=testImageFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   testVideoFormat: () => (/* binding */ testVideoFormat)
/* harmony export */ });

const inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function testVideoFormat(mimeType) {
  if (inWorker) {
    return false;
  }
  const video = document.createElement("video");
  return video.canPlayType(mimeType) !== "";
}


//# sourceMappingURL=testVideoFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/Loader.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/Loader.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Loader: () => (/* binding */ Loader)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/path.mjs */ "./node_modules/pixi.js/lib/utils/path.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/convertToList.mjs */ "./node_modules/pixi.js/lib/assets/utils/convertToList.mjs");
/* harmony import */ var _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/isSingleItem.mjs */ "./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs");





"use strict";
class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    /**
     * All loader parsers registered
     * @type {assets.LoaderParser[]}
     */
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    /** Cache loading promises that ae currently active */
    this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
        }
      }
      if (!parser) {
        for (let i = 0; i < this.parsers.length; i++) {
          const parserX = this.parsers[i];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_1__.isSingleItem)(assetsToLoadIn);
    const assetsToLoad = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_2__.convertToList)(assetsToLoadIn, (item) => ({
      alias: [item],
      src: item,
      data: {}
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__.path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url]) {
            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
          }
          assets[asset.src] = await this.promiseCache[url].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e) {
          delete this.promiseCache[url];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url}.
${e}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(assetsToUnloadIn) {
    const assetsToUnload = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_2__.convertToList)(assetsToUnloadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__.path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        delete this.promiseCache[url];
        await loadPromise.parser?.unload?.(loadedAsset, asset, this);
      }
    });
    await Promise.all(promises);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (!parser.name) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`[Assets] loadParser should have a name`);
      } else if (hash[parser.name]) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
}


//# sourceMappingURL=Loader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoaderParserPriority: () => (/* binding */ LoaderParserPriority)
/* harmony export */ });

var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});


//# sourceMappingURL=LoaderParser.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadJson: () => (/* binding */ loadJson)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/checkDataUrl.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");






"use strict";
const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_2__.checkDataUrl)(url, validJSONMIME) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_3__.checkExtension)(url, validJSONExtension);
  },
  async load(url) {
    const response = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_4__.DOMAdapter.get().fetch(url);
    const json = await response.json();
    return json;
  }
};


//# sourceMappingURL=loadJson.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadTxt: () => (/* binding */ loadTxt)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/checkDataUrl.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");






"use strict";
const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  name: "loadTxt",
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.Low,
    name: "loadTxt"
  },
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_2__.checkDataUrl)(url, validTXTMIME) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_3__.checkExtension)(url, validTXTExtension);
  },
  async load(url) {
    const response = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_4__.DOMAdapter.get().fetch(url);
    const txt = await response.text();
    return txt;
  }
};


//# sourceMappingURL=loadTxt.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFontFamilyName: () => (/* binding */ getFontFamilyName),
/* harmony export */   loadWebFont: () => (/* binding */ loadWebFont)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/path.mjs */ "./node_modules/pixi.js/lib/utils/path.mjs");
/* harmony import */ var _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/checkDataUrl.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");









"use strict";
const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url) {
  const ext = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__.path.extname(url);
  const name = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__.path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function encodeURIWhenNeeded(uri) {
  if (validURICharactersRegex.test(uri)) {
    return uri;
  }
  return encodeURI(uri);
}
const loadWebFont = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_2__.LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_3__.checkDataUrl)(url, validFontMIMEs) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_4__.checkExtension)(url, validFontExtensions);
  },
  async load(url, options) {
    const fonts = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_5__.DOMAdapter.get().getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name = options.data?.family ?? getFontFamilyName(url);
      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
      const data = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        const weight = weights[i];
        const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_6__.Cache.set(`${name}-and-url`, {
        url,
        fontFaces
      });
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_7__.warn)("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t) => {
      _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_6__.Cache.remove(`${t.family}-and-url`);
      _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_5__.DOMAdapter.get().getFontFaceSet().delete(t);
    });
  }
};


//# sourceMappingURL=loadWebFont.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadSvg: () => (/* binding */ loadSvg)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs");
/* harmony import */ var _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../scene/graphics/shared/GraphicsContext.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs");
/* harmony import */ var _utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../utils/network/getResolutionOfUrl.mjs */ "./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/checkDataUrl.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");










"use strict";
const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSvg = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.Low,
    name: "loadSVG"
  },
  name: "loadSVG",
  config: {
    crossOrigin: "anonymous",
    parseAsGraphicsContext: false
  },
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_2__.checkDataUrl)(url, validSVGMIME) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_3__.checkExtension)(url, validSVGExtension);
  },
  async load(url, asset, loader) {
    if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {
      return loadAsGraphics(url);
    }
    return loadAsTexture(url, asset, loader, this.config.crossOrigin);
  },
  unload(asset) {
    asset.destroy(true);
  }
};
async function loadAsTexture(url, asset, loader, crossOrigin) {
  const response = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_4__.DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const blobUrl = URL.createObjectURL(blob);
  const image = new Image();
  image.src = blobUrl;
  image.crossOrigin = crossOrigin;
  await image.decode();
  URL.revokeObjectURL(blobUrl);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  const resolution = asset.data?.resolution || (0,_utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_5__.getResolutionOfUrl)(url);
  const width = asset.data?.width ?? image.width;
  const height = asset.data?.height ?? image.height;
  canvas.width = width * resolution;
  canvas.height = height * resolution;
  context.drawImage(image, 0, 0, width * resolution, height * resolution);
  const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};
  const base = new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_6__.ImageSource({
    resource: canvas,
    alphaMode: "premultiply-alpha-on-upload",
    resolution,
    ...rest
  });
  return (0,_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.createTexture)(base, loader, url);
}
async function loadAsGraphics(url) {
  const response = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_4__.DOMAdapter.get().fetch(url);
  const svgSource = await response.text();
  const context = new _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_8__.GraphicsContext();
  context.svg(svgSource);
  return context;
}


//# sourceMappingURL=loadSVG.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadImageBitmap: () => (/* binding */ loadImageBitmap),
/* harmony export */   loadTextures: () => (/* binding */ loadTextures)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs");
/* harmony import */ var _utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../utils/network/getResolutionOfUrl.mjs */ "./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/checkDataUrl.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _workers_WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../workers/WorkerManager.mjs */ "./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");










"use strict";
const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url, asset) {
  const response = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  return asset?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_2__.LoaderParserPriority.High,
    name: "loadTextures"
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_3__.checkDataUrl)(url, validImageMIMEs) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_4__.checkExtension)(url, validImageExtensions);
  },
  async load(url, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await _workers_WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_5__.WorkerManager.isImageBitmapSupported()) {
        src = await _workers_WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_5__.WorkerManager.loadImageBitmap(url, asset);
      } else {
        src = await loadImageBitmap(url, asset);
      }
    } else {
      src = await new Promise((resolve, reject) => {
        src = new Image();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url;
        if (src.complete) {
          resolve(src);
        } else {
          src.onload = () => {
            resolve(src);
          };
          src.onerror = reject;
        }
      });
    }
    const base = new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_6__.ImageSource({
      resource: src,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: asset.data?.resolution || (0,_utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_7__.getResolutionOfUrl)(url),
      ...asset.data
    });
    return (0,_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_8__.createTexture)(base, loader, url);
  },
  unload(texture) {
    texture.destroy(true);
  }
};


//# sourceMappingURL=loadTextures.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   crossOrigin: () => (/* binding */ crossOrigin),
/* harmony export */   determineCrossOrigin: () => (/* binding */ determineCrossOrigin),
/* harmony export */   loadVideoTextures: () => (/* binding */ loadVideoTextures),
/* harmony export */   preloadVideo: () => (/* binding */ preloadVideo)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/VideoSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs");
/* harmony import */ var _utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../utils/browser/detectVideoAlphaMode.mjs */ "./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs");
/* harmony import */ var _utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../utils/network/getResolutionOfUrl.mjs */ "./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/checkDataUrl.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");








"use strict";
const validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
const validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);
function crossOrigin(element, url, crossorigin) {
  if (crossorigin === void 0 && !url.startsWith("data:")) {
    element.crossOrigin = determineCrossOrigin(url);
  } else if (crossorigin !== false) {
    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
  }
}
function preloadVideo(element) {
  return new Promise((resolve, reject) => {
    element.addEventListener("canplaythrough", loaded);
    element.addEventListener("error", error);
    element.load();
    function loaded() {
      cleanup();
      resolve();
    }
    function error(err) {
      cleanup();
      reject(err);
    }
    function cleanup() {
      element.removeEventListener("canplaythrough", loaded);
      element.removeEventListener("error", error);
    }
  });
}
function determineCrossOrigin(url, loc = globalThis.location) {
  if (url.startsWith("data:")) {
    return "";
  }
  loc || (loc = globalThis.location);
  const parsedUrl = new URL(url, document.baseURI);
  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
const loadVideoTextures = {
  name: "loadVideo",
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    name: "loadVideo"
  },
  test(url) {
    const isValidDataUrl = (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__.checkDataUrl)(url, validVideoMIMEs);
    const isValidExtension = (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, validVideoExtensions);
    return isValidDataUrl || isValidExtension;
  },
  async load(url, asset, loader) {
    const options = {
      ..._rendering_renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_3__.VideoSource.defaultOptions,
      resolution: asset.data?.resolution || (0,_utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_4__.getResolutionOfUrl)(url),
      alphaMode: asset.data?.alphaMode || await (0,_utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_5__.detectVideoAlphaMode)(),
      ...asset.data
    };
    const videoElement = document.createElement("video");
    const attributeMap = {
      preload: options.autoLoad !== false ? "auto" : void 0,
      "webkit-playsinline": options.playsinline !== false ? "" : void 0,
      playsinline: options.playsinline !== false ? "" : void 0,
      muted: options.muted === true ? "" : void 0,
      loop: options.loop === true ? "" : void 0,
      autoplay: options.autoPlay !== false ? "" : void 0
    };
    Object.keys(attributeMap).forEach((key) => {
      const value = attributeMap[key];
      if (value !== void 0)
        videoElement.setAttribute(key, value);
    });
    if (options.muted === true) {
      videoElement.muted = true;
    }
    crossOrigin(videoElement, url, options.crossorigin);
    const sourceElement = document.createElement("source");
    let mime;
    if (url.startsWith("data:")) {
      mime = url.slice(5, url.indexOf(";"));
    } else if (!url.startsWith("blob:")) {
      const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
      mime = _rendering_renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_3__.VideoSource.MIME_TYPES[ext] || `video/${ext}`;
    }
    sourceElement.src = url;
    if (mime) {
      sourceElement.type = mime;
    }
    return new Promise((resolve) => {
      const onCanPlay = async () => {
        const base = new _rendering_renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_3__.VideoSource({ ...options, resource: videoElement });
        videoElement.removeEventListener("canplay", onCanPlay);
        if (asset.data.preload) {
          await preloadVideo(videoElement);
        }
        resolve((0,_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__.createTexture)(base, loader, url));
      };
      videoElement.addEventListener("canplay", onCanPlay);
      videoElement.appendChild(sourceElement);
    });
  },
  unload(texture) {
    texture.destroy(true);
  }
};


//# sourceMappingURL=loadVideoTextures.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTexture: () => (/* binding */ createTexture)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");




"use strict";
function createTexture(source, loader, url) {
  source.label = url;
  source._sourceOrigin = url;
  const texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture({
    source,
    label: url
  });
  const unload = () => {
    delete loader.promiseCache[url];
    if (_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.has(url)) {
      _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.remove(url);
    }
  };
  texture.source.once("destroy", () => {
    if (loader.promiseCache[url]) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
      unload();
    }
  });
  texture.once("destroy", () => {
    if (!source.destroyed) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
      unload();
    }
  });
  return texture;
}


//# sourceMappingURL=createTexture.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkerManager: () => (/* binding */ WorkerManager)
/* harmony export */ });
/* harmony import */ var _virtual_checkImageBitmap_worker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_virtual/checkImageBitmap.worker.mjs */ "./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs");
/* harmony import */ var _virtual_loadImageBitmap_worker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../_virtual/loadImageBitmap.worker.mjs */ "./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs");



"use strict";
let UUID = 0;
let MAX_WORKERS;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this._workerPool = [];
    this._queue = [];
    this._resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve) => {
      const { worker } = new _virtual_checkImageBitmap_worker_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();
      worker.addEventListener("message", (event) => {
        worker.terminate();
        _virtual_checkImageBitmap_worker_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].revokeObjectURL();
        resolve(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src, asset) {
    return this._run("loadImageBitmap", [src, asset?.data?.alphaMode]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  _getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this._workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      this._createdWorkers++;
      worker = new _virtual_loadImageBitmap_worker_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]().worker;
      worker.addEventListener("message", (event) => {
        this._complete(event.data);
        this._returnWorker(event.target);
        this._next();
      });
    }
    return worker;
  }
  _returnWorker(worker) {
    this._workerPool.push(worker);
  }
  _complete(data) {
    if (data.error !== void 0) {
      this._resolveHash[data.uuid].reject(data.error);
    } else {
      this._resolveHash[data.uuid].resolve(data.data);
    }
    this._resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve, reject) => {
      this._queue.push({ id, arguments: args, resolve, reject });
    });
    this._next();
    return promise;
  }
  _next() {
    if (!this._queue.length)
      return;
    const worker = this._getWorker();
    if (!worker) {
      return;
    }
    const toDo = this._queue.pop();
    const id = toDo.id;
    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();


//# sourceMappingURL=WorkerManager.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Resolver: () => (/* binding */ Resolver),
/* harmony export */   getUrlExtension: () => (/* binding */ getUrlExtension)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_path_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/path.mjs */ "./node_modules/pixi.js/lib/utils/path.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/convertToList.mjs */ "./node_modules/pixi.js/lib/assets/utils/convertToList.mjs");
/* harmony import */ var _utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/createStringVariations.mjs */ "./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs");
/* harmony import */ var _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/isSingleItem.mjs */ "./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs");






"use strict";
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    /**
     * A function that generates a bundle asset id key from a bundleId and an assetId
     * @param bundleId - the bundleId
     * @param assetId  - the assetId
     * @returns the bundle asset id key
     */
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    /**
     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId
     * @param bundleId - the bundleId
     * @param assetBundleId - the bundle asset id key
     * @returns the assetId
     */
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(asset) {
    const { alias, src } = asset;
    const aliasesToUse = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToList)(
      alias || src,
      (value) => {
        if (typeof value === "string")
          return value;
        if (Array.isArray(value))
          return value.map((v) => v?.src ?? v);
        if (value?.src)
          return value.src;
        return value;
      },
      true
    );
    return aliasesToUse;
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(manifest) {
    if (this._manifest) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__.warn)("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    const assetNames = [];
    let convertedAssets = assets;
    if (!Array.isArray(assets)) {
      convertedAssets = Object.entries(assets).map(([alias, src]) => {
        if (typeof src === "string" || Array.isArray(src)) {
          return { alias, src };
        }
        return { alias, ...src };
      });
    }
    convertedAssets.forEach((asset) => {
      const srcs = asset.src;
      const aliases = asset.alias;
      let ids;
      if (typeof aliases === "string") {
        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
        assetNames.push(bundleAssetId);
        ids = [aliases, bundleAssetId];
      } else {
        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
        assetNames.push(...bundleIds);
        ids = [...aliases, ...bundleIds];
      }
      this.add({
        ...asset,
        ...{
          alias: ids,
          src: srcs
        }
      });
    });
    this._bundles[bundleId] = assetNames;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(aliases) {
    const assets = [];
    if (Array.isArray(aliases)) {
      assets.push(...aliases);
    } else {
      assets.push(aliases);
    }
    let keyCheck;
    keyCheck = (key) => {
      if (this.hasKey(key)) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__.warn)(`[Resolver] already has key: ${key} overwriting`);
      }
    };
    const assetArray = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToList)(assets);
    assetArray.forEach((asset) => {
      const { src } = asset;
      let { data, format, loadParser } = asset;
      const srcsToUse = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToList)(src).map((src2) => {
        if (typeof src2 === "string") {
          return (0,_utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_2__.createStringVariations)(src2);
        }
        return Array.isArray(src2) ? src2 : [src2];
      });
      const aliasesToUse = this.getAlias(asset);
      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
      const resolvedAssets = [];
      srcsToUse.forEach((srcs) => {
        srcs.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 !== "object") {
            formattedAsset.src = src2;
            for (let i = 0; i < this._parsers.length; i++) {
              const parser = this._parsers[i];
              if (parser.test(src2)) {
                formattedAsset = parser.parse(src2);
                break;
              }
            }
          } else {
            data = src2.data ?? data;
            format = src2.format ?? format;
            loadParser = src2.loadParser ?? loadParser;
            formattedAsset = {
              ...formattedAsset,
              ...src2
            };
          }
          if (!aliasesToUse) {
            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
          }
          formattedAsset = this._buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data,
            format,
            loadParser
          });
          resolvedAssets.push(formattedAsset);
        });
      });
      aliasesToUse.forEach((alias) => {
        this._assetMap[alias] = resolvedAssets;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(bundleIds) {
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_3__.isSingleItem)(bundleIds);
    bundleIds = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToList)(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i in result) {
        out[i] = result[i].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_3__.isSingleItem)(keys);
    keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToList)(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0];
        } else {
          this._resolverHash[key] = this._buildResolvedAsset({
            alias: [key],
            src: key
          }, {});
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(key) {
    return !!this._assetMap[key];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(key) {
    return !!this._bundles[key];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[i];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, format } = data;
    if (this._basePath || this._rootPath) {
      formattedAsset.src = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_4__.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
    }
    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
    return formattedAsset;
  }
}
/**
 * The prefix that denotes a URL is for a retina asset.
 * @static
 * @name RETINA_PREFIX
 * @type {RegExp}
 * @default /@([0-9\.]+)x/
 * @example `@2x`
 */
Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
function getUrlExtension(url) {
  return url.split(".").pop().split("?").shift().split("#").shift();
}


//# sourceMappingURL=Resolver.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveJsonUrl: () => (/* binding */ resolveJsonUrl)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _Resolver_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Resolver.mjs */ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs");
/* harmony import */ var _resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolveTextureUrl.mjs */ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs");




"use strict";
const resolveJsonUrl = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ResolveParser,
    priority: -2,
    name: "resolveJson"
  },
  test: (value) => _Resolver_mjs__WEBPACK_IMPORTED_MODULE_1__.Resolver.RETINA_PREFIX.test(value) && value.endsWith(".json"),
  parse: _resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveTextureUrl.parse
};


//# sourceMappingURL=resolveJsonUrl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveTextureUrl: () => (/* binding */ resolveTextureUrl)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../loader/parsers/textures/loadTextures.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs");
/* harmony import */ var _Resolver_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Resolver.mjs */ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs");




"use strict";
const resolveTextureUrl = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ResolveParser,
    name: "resolveTexture"
  },
  test: _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_1__.loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(_Resolver_mjs__WEBPACK_IMPORTED_MODULE_2__.Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: value.split(".").pop(),
    src: value
  })
};


//# sourceMappingURL=resolveTextureUrl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkDataUrl: () => (/* binding */ checkDataUrl)
/* harmony export */ });

function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}


//# sourceMappingURL=checkDataUrl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkExtension: () => (/* binding */ checkExtension)
/* harmony export */ });
/* harmony import */ var _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/path.mjs */ "./node_modules/pixi.js/lib/utils/path.mjs");


"use strict";
function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__.path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}


//# sourceMappingURL=checkExtension.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/convertToList.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/convertToList.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertToList: () => (/* binding */ convertToList)
/* harmony export */ });

const convertToList = (input, transform, forceTransform = false) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string" || forceTransform) {
      return transform(item);
    }
    return item;
  });
};


//# sourceMappingURL=convertToList.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copySearchParams: () => (/* binding */ copySearchParams)
/* harmony export */ });

const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};


//# sourceMappingURL=copySearchParams.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStringVariations: () => (/* binding */ createStringVariations)
/* harmony export */ });

function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}


//# sourceMappingURL=createStringVariations.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isSingleItem: () => (/* binding */ isSingleItem)
/* harmony export */ });

const isSingleItem = (item) => !Array.isArray(item);


//# sourceMappingURL=isSingleItem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/color/Color.mjs":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/color/Color.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color)
/* harmony export */ });
/* harmony import */ var _pixi_colord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/colord */ "./node_modules/@pixi/colord/index.mjs");
/* harmony import */ var _pixi_colord_plugins_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/colord/plugins/names */ "./node_modules/@pixi/colord/plugins/names.mjs");



"use strict";
(0,_pixi_colord__WEBPACK_IMPORTED_MODULE_0__.extend)([_pixi_colord_plugins_names__WEBPACK_IMPORTED_MODULE_1__["default"]]);
const _Color = class _Color {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  /** Get red component (0 - 1) */
  get red() {
    return this._components[0];
  }
  /** Get green component (0 - 1) */
  get green() {
    return this._components[1];
  }
  /** Get blue component (0 - 1) */
  get blue() {
    return this._components[2];
  }
  /** Get alpha component (0 - 1) */
  get alpha() {
    return this._components[3];
  }
  /**
   * Set the value, suitable for chaining
   * @param value
   * @see Color.value
   */
  setValue(value) {
    this.value = value;
    return this;
  }
  /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
   *   {@link Color.premultiply premultiply} or {@link Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   */
  set value(value) {
    if (value instanceof _Color) {
      this._value = this._cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set Color#value to null");
    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
      this._value = this._cloneSource(value);
      this._normalize(this._value);
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v, i) => v === value2[i]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */
  toRgba() {
    const [r, g, b, a] = this._components;
    return { r, g, b, a };
  }
  /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */
  toRgb() {
    const [r, g, b] = this._components;
    return { r, g, b };
  }
  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
  toRgbaString() {
    const [r, g, b] = this.toUint8RgbArray();
    return `rgba(${r},${g},${b},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r, g, b] = this._components;
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out || (out = this._arrayRgb);
    out[0] = Math.round(r * 255);
    out[1] = Math.round(g * 255);
    out[2] = Math.round(b * 255);
    return out;
  }
  toArray(out) {
    if (!this._arrayRgba) {
      this._arrayRgba = [];
    }
    out || (out = this._arrayRgba);
    const [r, g, b, a] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
  }
  toRgbArray(out) {
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out || (out = this._arrayRgb);
    const [r, g, b] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    return out;
  }
  /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   */
  toBgrNumber() {
    const [r, g, b] = this.toUint8RgbArray();
    return (b << 16) + (g << 8) + r;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {ColorSource} value - The color to multiply by.
   */
  multiply(value) {
    const [r, g, b, a] = _Color._temp.setValue(value)._components;
    this._components[0] *= r;
    this._components[1] *= g;
    this._components[2] *= b;
    this._components[3] *= a;
    this._refreshInt();
    this._value = null;
    return this;
  }
  /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {Color} - Itself.
   */
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this._refreshInt();
    this._value = null;
    return this;
  }
  /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r = this._int >> 16 & 255;
    let g = this._int >> 8 & 255;
    let b = this._int & 255;
    if (applyToRGB) {
      r = r * alpha + 0.5 | 0;
      g = g * alpha + 0.5 | 0;
      b = b * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
  }
  /**
   * Convert to a hexadecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  /**
   * Convert to a hexadecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(value) {
    let r;
    let g;
    let b;
    let a;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r = (int >> 16 & 255) / 255;
      g = (int >> 8 & 255) / 255;
      b = (int & 255) / 255;
      a = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r, g, b, a = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r, g, b, a = 255] = value;
      r /= 255;
      g /= 255;
      b /= 255;
      a /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = (0,_pixi_colord__WEBPACK_IMPORTED_MODULE_0__.colord)(value);
      if (color.isValid()) {
        ({ r, g, b, a } = color.rgba);
        r /= 255;
        g /= 255;
        b /= 255;
      }
    }
    if (r !== void 0) {
      this._components[0] = r;
      this._components[1] = g;
      this._components[2] = b;
      this._components[3] = a;
      this._refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [r, g, b] = this._components;
    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v, i) => {
      value[i] = Math.min(Math.max(v, min), max);
    });
    return value;
  }
  /**
   * Check if the value is a color-like object
   * @param value - Value to check
   * @returns True if the value is a color-like object
   * @static
   * @example
   * import { Color } from 'pixi.js';
   * Color.isColorLike('white'); // returns true
   * Color.isColorLike(0xffffff); // returns true
   * Color.isColorLike([1, 1, 1]); // returns true
   */
  static isColorLike(value) {
    return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
  }
};
/**
 * Default Color object for static uses
 * @example
 * import { Color } from 'pixi.js';
 * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'
 */
_Color.shared = new _Color();
/**
 * Temporary Color object for static uses internally.
 * As to not conflict with Color.shared.
 * @ignore
 */
_Color._temp = new _Color();
/** Pattern for hex strings */
// eslint-disable-next-line @typescript-eslint/naming-convention
_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Color = _Color;


//# sourceMappingURL=Color.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectBasis: () => (/* binding */ detectBasis)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/browser/isWebGLSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs");
/* harmony import */ var _utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/browser/isWebGPUSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs");




"use strict";
const detectBasis = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 3
  },
  test: async () => {
    if (await (0,_utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_1__.isWebGPUSupported)())
      return true;
    if ((0,_utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_2__.isWebGLSupported)())
      return true;
    return false;
  },
  add: async (formats) => [...formats, "basis"],
  remove: async (formats) => formats.filter((f) => f !== "basis")
};


//# sourceMappingURL=detectBasis.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadBasis: () => (/* binding */ loadBasis)
/* harmony export */ });
/* harmony import */ var _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");
/* harmony import */ var _assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs");
/* harmony import */ var _worker_loadBasisOnWorker_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker/loadBasisOnWorker.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs");








"use strict";
const loadBasis = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.High,
    name: "loadBasis"
  },
  name: "loadBasis",
  test(url) {
    return (0,_assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, [".basis"]);
  },
  async load(url, _asset, loader) {
    const supportedTextures = await (0,_rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__.getSupportedTextureFormats)();
    const textureOptions = await (0,_worker_loadBasisOnWorker_mjs__WEBPACK_IMPORTED_MODULE_4__.loadBasisOnWorker)(url, supportedTextures);
    const compressedTextureSource = new _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__.CompressedSource(textureOptions);
    return (0,_assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__.createTexture)(compressedTextureSource, loader, url);
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};


//# sourceMappingURL=loadBasis.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLevelBuffers: () => (/* binding */ createLevelBuffers)
/* harmony export */ });

function createLevelBuffers(basisTexture, basisTranscoderFormat) {
  const images = basisTexture.getNumImages();
  const levels = basisTexture.getNumLevels(0);
  const success = basisTexture.startTranscoding();
  if (!success) {
    throw new Error("startTranscoding failed");
  }
  const levelBuffers = [];
  for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {
    for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {
      const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
      const levelBuffer = new Uint8Array(transcodeSize);
      const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
      if (!success2) {
        throw new Error("transcodeImage failed");
      }
      levelBuffers.push(levelBuffer);
    }
  }
  return levelBuffers;
}


//# sourceMappingURL=createLevelBuffers.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gpuFormatToBasisTranscoderFormat: () => (/* binding */ gpuFormatToBasisTranscoderFormat)
/* harmony export */ });

const gpuFormatToBasisTranscoderFormatMap = {
  "bc3-rgba-unorm": 3,
  // cTFBC3_RGBA
  "bc7-rgba-unorm": 6,
  // cTFBC7_RGBA,
  "etc2-rgba8unorm": 1,
  // cTFETC2_RGBA,
  "astc-4x4-unorm": 10,
  // cTFASTC_4x4_RGBA,
  // Uncompressed
  rgba8unorm: 13,
  // cTFRGBA32,
  rgba4unorm: 16
  // cTFRGBA4444,
};
function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
  const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
}


//# sourceMappingURL=gpuFormatToBasisTranscoderFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basisTranscoderUrls: () => (/* binding */ basisTranscoderUrls),
/* harmony export */   setBasisTranscoderPath: () => (/* binding */ setBasisTranscoderPath)
/* harmony export */ });

const basisTranscoderUrls = {
  jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js",
  wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"
};
function setBasisTranscoderPath(config) {
  Object.assign(basisTranscoderUrls, config);
}


//# sourceMappingURL=setBasisTranscoderPath.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadBasisOnWorker: () => (/* binding */ loadBasisOnWorker)
/* harmony export */ });
/* harmony import */ var _virtual_basis_worker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_virtual/basis.worker.mjs */ "./node_modules/pixi.js/lib/_virtual/basis.worker.mjs");
/* harmony import */ var _utils_setBasisTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/setBasisTranscoderPath.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs");



"use strict";
let basisWorker;
const urlHash = {};
function getBasisWorker(supportedTextures) {
  if (!basisWorker) {
    basisWorker = new _virtual_basis_worker_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]().worker;
    basisWorker.onmessage = (messageEvent) => {
      const { success, url, textureOptions } = messageEvent.data;
      if (!success) {
        console.warn("Failed to load Basis texture", url);
      }
      urlHash[url](textureOptions);
    };
    basisWorker.postMessage({
      type: "init",
      jsUrl: _utils_setBasisTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_1__.basisTranscoderUrls.jsUrl,
      wasmUrl: _utils_setBasisTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_1__.basisTranscoderUrls.wasmUrl,
      supportedTextures
    });
  }
  return basisWorker;
}
function loadBasisOnWorker(url, supportedTextures) {
  const ktxWorker = getBasisWorker(supportedTextures);
  return new Promise((resolve) => {
    urlHash[url] = resolve;
    ktxWorker.postMessage({ type: "load", url });
  });
}


//# sourceMappingURL=loadBasisOnWorker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/dds/const.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/dds/const.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D3D10_RESOURCE_DIMENSION: () => (/* binding */ D3D10_RESOURCE_DIMENSION),
/* harmony export */   D3DFMT: () => (/* binding */ D3DFMT),
/* harmony export */   DDS: () => (/* binding */ DDS),
/* harmony export */   DXGI_FORMAT: () => (/* binding */ DXGI_FORMAT),
/* harmony export */   DXGI_TO_TEXTURE_FORMAT: () => (/* binding */ DXGI_TO_TEXTURE_FORMAT),
/* harmony export */   FOURCC_TO_TEXTURE_FORMAT: () => (/* binding */ FOURCC_TO_TEXTURE_FORMAT),
/* harmony export */   TEXTURE_FORMAT_BLOCK_SIZE: () => (/* binding */ TEXTURE_FORMAT_BLOCK_SIZE)
/* harmony export */ });

const DDS_HEADER_FIELDS = {
  MAGIC: 0,
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19,
  PF_FLAGS: 20,
  FOURCC: 21,
  RGB_BITCOUNT: 22,
  R_BIT_MASK: 23,
  G_BIT_MASK: 24,
  B_BIT_MASK: 25,
  A_BIT_MASK: 26
};
const DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
  return DXGI_FORMAT2;
})(DXGI_FORMAT || {});
var D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
  return D3D10_RESOURCE_DIMENSION2;
})(D3D10_RESOURCE_DIMENSION || {});
function fourCCToInt32(value) {
  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
var D3DFMT = ((D3DFMT2) => {
  D3DFMT2[D3DFMT2["UNKNOWN"] = 0] = "UNKNOWN";
  D3DFMT2[D3DFMT2["R8G8B8"] = 20] = "R8G8B8";
  D3DFMT2[D3DFMT2["A8R8G8B8"] = 21] = "A8R8G8B8";
  D3DFMT2[D3DFMT2["X8R8G8B8"] = 22] = "X8R8G8B8";
  D3DFMT2[D3DFMT2["R5G6B5"] = 23] = "R5G6B5";
  D3DFMT2[D3DFMT2["X1R5G5B5"] = 24] = "X1R5G5B5";
  D3DFMT2[D3DFMT2["A1R5G5B5"] = 25] = "A1R5G5B5";
  D3DFMT2[D3DFMT2["A4R4G4B4"] = 26] = "A4R4G4B4";
  D3DFMT2[D3DFMT2["R3G3B2"] = 27] = "R3G3B2";
  D3DFMT2[D3DFMT2["A8"] = 28] = "A8";
  D3DFMT2[D3DFMT2["A8R3G3B2"] = 29] = "A8R3G3B2";
  D3DFMT2[D3DFMT2["X4R4G4B4"] = 30] = "X4R4G4B4";
  D3DFMT2[D3DFMT2["A2B10G10R10"] = 31] = "A2B10G10R10";
  D3DFMT2[D3DFMT2["A8B8G8R8"] = 32] = "A8B8G8R8";
  D3DFMT2[D3DFMT2["X8B8G8R8"] = 33] = "X8B8G8R8";
  D3DFMT2[D3DFMT2["G16R16"] = 34] = "G16R16";
  D3DFMT2[D3DFMT2["A2R10G10B10"] = 35] = "A2R10G10B10";
  D3DFMT2[D3DFMT2["A16B16G16R16"] = 36] = "A16B16G16R16";
  D3DFMT2[D3DFMT2["A8P8"] = 40] = "A8P8";
  D3DFMT2[D3DFMT2["P8"] = 41] = "P8";
  D3DFMT2[D3DFMT2["L8"] = 50] = "L8";
  D3DFMT2[D3DFMT2["A8L8"] = 51] = "A8L8";
  D3DFMT2[D3DFMT2["A4L4"] = 52] = "A4L4";
  D3DFMT2[D3DFMT2["V8U8"] = 60] = "V8U8";
  D3DFMT2[D3DFMT2["L6V5U5"] = 61] = "L6V5U5";
  D3DFMT2[D3DFMT2["X8L8V8U8"] = 62] = "X8L8V8U8";
  D3DFMT2[D3DFMT2["Q8W8V8U8"] = 63] = "Q8W8V8U8";
  D3DFMT2[D3DFMT2["V16U16"] = 64] = "V16U16";
  D3DFMT2[D3DFMT2["A2W10V10U10"] = 67] = "A2W10V10U10";
  D3DFMT2[D3DFMT2["Q16W16V16U16"] = 110] = "Q16W16V16U16";
  D3DFMT2[D3DFMT2["R16F"] = 111] = "R16F";
  D3DFMT2[D3DFMT2["G16R16F"] = 112] = "G16R16F";
  D3DFMT2[D3DFMT2["A16B16G16R16F"] = 113] = "A16B16G16R16F";
  D3DFMT2[D3DFMT2["R32F"] = 114] = "R32F";
  D3DFMT2[D3DFMT2["G32R32F"] = 115] = "G32R32F";
  D3DFMT2[D3DFMT2["A32B32G32R32F"] = 116] = "A32B32G32R32F";
  D3DFMT2[D3DFMT2["UYVY"] = fourCCToInt32("UYVY")] = "UYVY";
  D3DFMT2[D3DFMT2["R8G8_B8G8"] = fourCCToInt32("RGBG")] = "R8G8_B8G8";
  D3DFMT2[D3DFMT2["YUY2"] = fourCCToInt32("YUY2")] = "YUY2";
  D3DFMT2[D3DFMT2["D3DFMT_G8R8_G8B8"] = fourCCToInt32("GRGB")] = "D3DFMT_G8R8_G8B8";
  D3DFMT2[D3DFMT2["DXT1"] = fourCCToInt32("DXT1")] = "DXT1";
  D3DFMT2[D3DFMT2["DXT2"] = fourCCToInt32("DXT2")] = "DXT2";
  D3DFMT2[D3DFMT2["DXT3"] = fourCCToInt32("DXT3")] = "DXT3";
  D3DFMT2[D3DFMT2["DXT4"] = fourCCToInt32("DXT4")] = "DXT4";
  D3DFMT2[D3DFMT2["DXT5"] = fourCCToInt32("DXT5")] = "DXT5";
  D3DFMT2[D3DFMT2["ATI1"] = fourCCToInt32("ATI1")] = "ATI1";
  D3DFMT2[D3DFMT2["AT1N"] = fourCCToInt32("AT1N")] = "AT1N";
  D3DFMT2[D3DFMT2["ATI2"] = fourCCToInt32("ATI2")] = "ATI2";
  D3DFMT2[D3DFMT2["AT2N"] = fourCCToInt32("AT2N")] = "AT2N";
  D3DFMT2[D3DFMT2["BC4U"] = fourCCToInt32("BC4U")] = "BC4U";
  D3DFMT2[D3DFMT2["BC4S"] = fourCCToInt32("BC4S")] = "BC4S";
  D3DFMT2[D3DFMT2["BC5U"] = fourCCToInt32("BC5U")] = "BC5U";
  D3DFMT2[D3DFMT2["BC5S"] = fourCCToInt32("BC5S")] = "BC5S";
  D3DFMT2[D3DFMT2["DX10"] = fourCCToInt32("DX10")] = "DX10";
  return D3DFMT2;
})(D3DFMT || {});
const FOURCC_TO_TEXTURE_FORMAT = {
  [D3DFMT.DXT1]: "bc1-rgba-unorm",
  [D3DFMT.DXT2]: "bc2-rgba-unorm",
  [D3DFMT.DXT3]: "bc2-rgba-unorm",
  [D3DFMT.DXT4]: "bc3-rgba-unorm",
  [D3DFMT.DXT5]: "bc3-rgba-unorm",
  [D3DFMT.ATI1]: "bc4-r-unorm",
  [D3DFMT.BC4U]: "bc4-r-unorm",
  [D3DFMT.BC4S]: "bc4-r-snorm",
  [D3DFMT.ATI2]: "bc5-rg-unorm",
  [D3DFMT.BC5U]: "bc5-rg-unorm",
  [D3DFMT.BC5S]: "bc5-rg-snorm",
  [36 /* A16B16G16R16 */]: "rgba16uint",
  [110 /* Q16W16V16U16 */]: "rgba16sint",
  [111 /* R16F */]: "r16float",
  [112 /* G16R16F */]: "rg16float",
  [113 /* A16B16G16R16F */]: "rgba16float",
  [114 /* R32F */]: "r32float",
  [115 /* G32R32F */]: "rg32float",
  [116 /* A32B32G32R32F */]: "rgba32float"
};
const DXGI_TO_TEXTURE_FORMAT = {
  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: "bc1-rgba-unorm",
  [71 /* DXGI_FORMAT_BC1_UNORM */]: "bc1-rgba-unorm",
  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: "bc1-rgba-unorm-srgb",
  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: "bc2-rgba-unorm",
  [74 /* DXGI_FORMAT_BC2_UNORM */]: "bc2-rgba-unorm",
  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: "bc2-rgba-unorm-srgb",
  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: "bc3-rgba-unorm",
  [77 /* DXGI_FORMAT_BC3_UNORM */]: "bc3-rgba-unorm",
  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: "bc3-rgba-unorm-srgb",
  [79 /* DXGI_FORMAT_BC4_TYPELESS */]: "bc4-r-unorm",
  [80 /* DXGI_FORMAT_BC4_UNORM */]: "bc4-r-unorm",
  [81 /* DXGI_FORMAT_BC4_SNORM */]: "bc4-r-snorm",
  [82 /* DXGI_FORMAT_BC5_TYPELESS */]: "bc5-rg-unorm",
  [83 /* DXGI_FORMAT_BC5_UNORM */]: "bc5-rg-unorm",
  [84 /* DXGI_FORMAT_BC5_SNORM */]: "bc5-rg-snorm",
  [94 /* DXGI_FORMAT_BC6H_TYPELESS */]: "bc6h-rgb-ufloat",
  [95 /* DXGI_FORMAT_BC6H_UF16 */]: "bc6h-rgb-ufloat",
  [96 /* DXGI_FORMAT_BC6H_SF16 */]: "bc6h-rgb-float",
  [97 /* DXGI_FORMAT_BC7_TYPELESS */]: "bc7-rgba-unorm",
  [98 /* DXGI_FORMAT_BC7_UNORM */]: "bc7-rgba-unorm",
  [99 /* DXGI_FORMAT_BC7_UNORM_SRGB */]: "bc7-rgba-unorm-srgb",
  [28 /* DXGI_FORMAT_R8G8B8A8_UNORM */]: "rgba8unorm",
  [29 /* DXGI_FORMAT_R8G8B8A8_UNORM_SRGB */]: "rgba8unorm-srgb",
  [87 /* DXGI_FORMAT_B8G8R8A8_UNORM */]: "bgra8unorm",
  [91 /* DXGI_FORMAT_B8G8R8A8_UNORM_SRGB */]: "bgra8unorm-srgb",
  [41 /* DXGI_FORMAT_R32_FLOAT */]: "r32float",
  [49 /* DXGI_FORMAT_R8G8_UNORM */]: "rg8unorm",
  [56 /* DXGI_FORMAT_R16_UNORM */]: "r16uint",
  [61 /* DXGI_FORMAT_R8_UNORM */]: "r8unorm",
  [24 /* DXGI_FORMAT_R10G10B10A2_UNORM */]: "rgb10a2unorm",
  [11 /* DXGI_FORMAT_R16G16B16A16_UNORM */]: "rgba16uint",
  [13 /* DXGI_FORMAT_R16G16B16A16_SNORM */]: "rgba16sint",
  [10 /* DXGI_FORMAT_R16G16B16A16_FLOAT */]: "rgba16float",
  [54 /* DXGI_FORMAT_R16_FLOAT */]: "r16float",
  [34 /* DXGI_FORMAT_R16G16_FLOAT */]: "rg16float",
  [16 /* DXGI_FORMAT_R32G32_FLOAT */]: "rg32float",
  [2 /* DXGI_FORMAT_R32G32B32A32_FLOAT */]: "rgba32float"
};
const DDS = {
  MAGIC_VALUE: 542327876,
  MAGIC_SIZE: 4,
  HEADER_SIZE: 124,
  HEADER_DX10_SIZE: 20,
  PIXEL_FORMAT_FLAGS: {
    // PIXEL_FORMAT flags
    // https://github.com/Microsoft/DirectXTex/blob/main/DirectXTex/DDS.h
    // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dds-pixelformat
    ALPHAPIXELS: 1,
    ALPHA: 2,
    FOURCC: 4,
    RGB: 64,
    RGBA: 65,
    YUV: 512,
    LUMINANCE: 131072,
    LUMINANCEA: 131073
  },
  RESOURCE_MISC_TEXTURECUBE: 4,
  HEADER_FIELDS: DDS_HEADER_FIELDS,
  HEADER_DX10_FIELDS: DDS_DX10_FIELDS,
  DXGI_FORMAT,
  D3D10_RESOURCE_DIMENSION,
  D3DFMT
};
const TEXTURE_FORMAT_BLOCK_SIZE = {
  "bc1-rgba-unorm": 8,
  "bc1-rgba-unorm-srgb": 8,
  "bc2-rgba-unorm": 16,
  "bc2-rgba-unorm-srgb": 16,
  "bc3-rgba-unorm": 16,
  "bc3-rgba-unorm-srgb": 16,
  "bc4-r-unorm": 8,
  "bc4-r-snorm": 8,
  "bc5-rg-unorm": 16,
  "bc5-rg-snorm": 16,
  "bc6h-rgb-ufloat": 16,
  "bc6h-rgb-float": 16,
  "bc7-rgba-unorm": 16,
  "bc7-rgba-unorm-srgb": 16
};


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadDDS: () => (/* binding */ loadDDS)
/* harmony export */ });
/* harmony import */ var _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");
/* harmony import */ var _assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs");
/* harmony import */ var _parseDDS_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parseDDS.mjs */ "./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs");








"use strict";
const loadDDS = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.High,
    name: "loadDDS"
  },
  name: "loadDDS",
  test(url) {
    return (0,_assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, [".dds"]);
  },
  async load(url, _asset, loader) {
    const supportedTextures = await (0,_rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__.getSupportedTextureFormats)();
    const ddsResponse = await fetch(url);
    const ddsArrayBuffer = await ddsResponse.arrayBuffer();
    const textureOptions = (0,_parseDDS_mjs__WEBPACK_IMPORTED_MODULE_4__.parseDDS)(ddsArrayBuffer, supportedTextures);
    const compressedTextureSource = new _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__.CompressedSource(textureOptions);
    return (0,_assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__.createTexture)(compressedTextureSource, loader, url);
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};


//# sourceMappingURL=loadDDS.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseDDS: () => (/* binding */ parseDDS)
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/pixi.js/lib/compressed-textures/dds/const.mjs");


"use strict";
function parseDDS(arrayBuffer, supportedFormats) {
  const {
    format,
    fourCC,
    width,
    height,
    dataOffset,
    mipmapCount
  } = parseDDSHeader(arrayBuffer);
  if (!supportedFormats.includes(format)) {
    throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);
  }
  if (mipmapCount <= 1) {
    return {
      format,
      width,
      height,
      resource: [new Uint8Array(arrayBuffer, dataOffset)],
      alphaMode: "no-premultiply-alpha"
    };
  }
  const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);
  const textureOptions = {
    format,
    width,
    height,
    resource: levelBuffers,
    alphaMode: "no-premultiply-alpha"
  };
  return textureOptions;
}
function getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer) {
  const levelBuffers = [];
  const blockBytes = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_FORMAT_BLOCK_SIZE[format];
  let mipWidth = width;
  let mipHeight = height;
  let offset = dataOffset;
  for (let level = 0; level < mipmapCount; ++level) {
    const alignedWidth = Math.ceil(Math.max(4, mipWidth) / 4) * 4;
    const alignedHeight = Math.ceil(Math.max(4, mipHeight) / 4) * 4;
    const byteLength = blockBytes ? alignedWidth / 4 * alignedHeight / 4 * blockBytes : mipWidth * mipHeight * 4;
    const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);
    levelBuffers.push(levelBuffer);
    offset += byteLength;
    mipWidth = Math.max(mipWidth >> 1, 1);
    mipHeight = Math.max(mipHeight >> 1, 1);
  }
  return levelBuffers;
}
function parseDDSHeader(buffer) {
  const header = new Uint32Array(buffer, 0, _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  if (header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.MAGIC] !== _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.MAGIC_VALUE) {
    throw new Error("Invalid magic number in DDS header");
  }
  const height = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.HEIGHT];
  const width = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.WIDTH];
  const mipmapCount = Math.max(1, header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.MIPMAP_COUNT]);
  const flags = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.PF_FLAGS];
  const fourCC = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.FOURCC];
  const format = getTextureFormat(header, flags, fourCC, buffer);
  const dataOffset = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.MAGIC_SIZE + _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_SIZE + (fourCC === _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.D3DFMT.DX10 ? _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_DX10_SIZE : 0);
  return {
    format,
    fourCC,
    width,
    height,
    dataOffset,
    mipmapCount
  };
}
function getTextureFormat(header, flags, fourCC, buffer) {
  if (flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.FOURCC) {
    if (fourCC === _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.D3DFMT.DX10) {
      const dx10Header = new Uint32Array(
        buffer,
        _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.MAGIC_SIZE + _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_SIZE,
        // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER
        _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT
      );
      const miscFlag = dx10Header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_DX10_FIELDS.MISC_FLAG];
      if (miscFlag === _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.RESOURCE_MISC_TEXTURECUBE) {
        throw new Error("DDSParser does not support cubemap textures");
      }
      const resourceDimension = dx10Header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION];
      if (resourceDimension === _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
        throw new Error("DDSParser does not supported 3D texture data");
      }
      const dxgiFormat = dx10Header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];
      if (dxgiFormat in _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[dxgiFormat];
      }
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (fourCC in _const_mjs__WEBPACK_IMPORTED_MODULE_0__.FOURCC_TO_TEXTURE_FORMAT) {
      return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.FOURCC_TO_TEXTURE_FORMAT[fourCC];
    }
    throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);
  }
  if (flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.RGB || flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.RGBA) {
    return getUncompressedTextureFormat(header);
  }
  if (flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
function getUncompressedTextureFormat(header) {
  const bitCount = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.RGB_BITCOUNT];
  const rBitMask = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.R_BIT_MASK];
  const gBitMask = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.G_BIT_MASK];
  const bBitMask = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.B_BIT_MASK];
  const aBitMask = header[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.HEADER_FIELDS.A_BIT_MASK];
  switch (bitCount) {
    case 32:
      if (rBitMask === 255 && gBitMask === 65280 && bBitMask === 16711680 && aBitMask === 4278190080) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
      }
      if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 4278190080) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
      }
      if (rBitMask === 1072693248 && gBitMask === 1047552 && bBitMask === 1023 && aBitMask === 3221225472) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
      }
      if (rBitMask === 65535 && gBitMask === 4294901760 && bBitMask === 0 && aBitMask === 0) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
      }
      if (rBitMask === 4294967295 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
      }
      break;
    case 24:
      if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 32768) {
      }
      break;
    case 16:
      if (rBitMask === 31744 && gBitMask === 992 && bBitMask === 31 && aBitMask === 32768) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
      }
      if (rBitMask === 63488 && gBitMask === 2016 && bBitMask === 31 && aBitMask === 0) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
      }
      if (rBitMask === 3840 && gBitMask === 240 && bBitMask === 15 && aBitMask === 61440) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
      }
      if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 65280) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
      }
      if (rBitMask === 65535 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
      }
      break;
    case 8:
      if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
        return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DXGI_TO_TEXTURE_FORMAT[_const_mjs__WEBPACK_IMPORTED_MODULE_0__.DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
      }
      break;
  }
  throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);
}


//# sourceMappingURL=parseDDS.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadKTX: () => (/* binding */ loadKTX)
/* harmony export */ });
/* harmony import */ var _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");
/* harmony import */ var _assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs");
/* harmony import */ var _parseKTX_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parseKTX.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs");








"use strict";
const loadKTX = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.High,
    name: "loadKTX"
  },
  name: "loadKTX",
  test(url) {
    return (0,_assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, ".ktx");
  },
  async load(url, _asset, loader) {
    const supportedTextures = await (0,_rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__.getSupportedTextureFormats)();
    const ktxResponse = await fetch(url);
    const ktxArrayBuffer = await ktxResponse.arrayBuffer();
    const textureOptions = (0,_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_4__.parseKTX)(ktxArrayBuffer, supportedTextures);
    const compressedTextureSource = new _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__.CompressedSource(textureOptions);
    return (0,_assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__.createTexture)(compressedTextureSource, loader, url);
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};


//# sourceMappingURL=loadKTX.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseKTX: () => (/* binding */ parseKTX)
/* harmony export */ });
/* harmony import */ var _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ktx2/const.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs");


"use strict";
function parseKTX(arrayBuffer, supportedFormats) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(dataView)) {
    throw new Error("Invalid KTX identifier in header");
  }
  const {
    littleEndian,
    glType,
    glFormat,
    glInternalFormat,
    pixelWidth,
    pixelHeight,
    numberOfMipmapLevels,
    offset
  } = parseKTXHeader(dataView);
  const textureFormat = _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];
  if (!textureFormat) {
    throw new Error(`Unknown texture format ${glInternalFormat}`);
  }
  if (!supportedFormats.includes(textureFormat)) {
    throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);
  }
  const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);
  const imageBuffers = getImageBuffers(
    dataView,
    glType,
    imagePixelByteSize,
    pixelWidth,
    pixelHeight,
    offset,
    numberOfMipmapLevels,
    littleEndian
  );
  return {
    format: textureFormat,
    width: pixelWidth,
    height: pixelHeight,
    resource: imageBuffers,
    alphaMode: "no-premultiply-alpha"
  };
}
function getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian) {
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let mipByteSize = imagePixels * imagePixelByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = offset;
  const imageBuffers = new Array(numberOfMipmapLevels);
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);
    elementOffset += mipByteSize;
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + 4 - 1 & ~(4 - 1);
    alignedMipHeight = mipHeight + 4 - 1 & ~(4 - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  return imageBuffers;
}
function getImagePixelByteSize(glType, glFormat, glInternalFormat) {
  let imagePixelByteSize = _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  if (glType !== 0) {
    if (_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  return imagePixelByteSize;
}
function parseKTXHeader(dataView) {
  const littleEndian = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.ENDIANNESS, true) === _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.ENDIANNESS;
  const glType = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  return {
    littleEndian,
    glType,
    glFormat,
    glInternalFormat,
    pixelWidth,
    pixelHeight,
    numberOfMipmapLevels,
    offset: _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FILE_HEADER_SIZE + bytesOfKeyValueData
  };
}
function validate(dataView) {
  for (let i = 0; i < _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FILE_IDENTIFIER.length; i++) {
    if (dataView.getUint8(i) !== _ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_0__.KTX.FILE_IDENTIFIER[i]) {
      return false;
    }
  }
  return true;
}


//# sourceMappingURL=parseKTX.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GL_INTERNAL_FORMAT: () => (/* binding */ GL_INTERNAL_FORMAT),
/* harmony export */   KTX: () => (/* binding */ KTX)
/* harmony export */ });

var GL_INTERNAL_FORMAT = /* @__PURE__ */ ((GL_INTERNAL_FORMAT2) => {
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA"] = 6408] = "RGBA";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8UI"] = 36220] = "RGBA8UI";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8I"] = 36238] = "RGBA8I";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8"] = 32856] = "RGBA8";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
  GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
  return GL_INTERNAL_FORMAT2;
})(GL_INTERNAL_FORMAT || {});
var GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
  GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
  GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
  GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
  GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
  GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
  GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return GL_FORMATS2;
})(GL_FORMATS || {});
var GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
  GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
  GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
  GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
  GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
  GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return GL_TYPES2;
})(GL_TYPES || {});
const INTERNAL_FORMAT_TO_TEXTURE_FORMATS = {
  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: "bc1-rgba-unorm",
  // TODO: ???
  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: "bc1-rgba-unorm",
  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: "bc2-rgba-unorm",
  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: "bc3-rgba-unorm",
  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: "bc1-rgba-unorm-srgb",
  // TODO: ???
  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: "bc1-rgba-unorm-srgb",
  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: "bc2-rgba-unorm-srgb",
  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: "bc3-rgba-unorm-srgb",
  [36283 /* COMPRESSED_RED_RGTC1_EXT */]: "bc4-r-unorm",
  [36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */]: "bc4-r-snorm",
  [36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */]: "bc5-rg-unorm",
  [36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */]: "bc5-rg-snorm",
  [37488 /* COMPRESSED_R11_EAC */]: "eac-r11unorm",
  // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 'eac-r11snorm',
  [37490 /* COMPRESSED_RG11_EAC */]: "eac-rg11snorm",
  // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 'eac-rg11unorm',
  [37492 /* COMPRESSED_RGB8_ETC2 */]: "etc2-rgb8unorm",
  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: "etc2-rgba8unorm",
  [37493 /* COMPRESSED_SRGB8_ETC2 */]: "etc2-rgb8unorm-srgb",
  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: "etc2-rgba8unorm-srgb",
  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: "etc2-rgb8a1unorm",
  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: "etc2-rgb8a1unorm-srgb",
  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: "astc-4x4-unorm",
  [37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */]: "astc-4x4-unorm-srgb",
  [37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */]: "astc-5x4-unorm",
  [37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */]: "astc-5x4-unorm-srgb",
  [37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */]: "astc-5x5-unorm",
  [37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */]: "astc-5x5-unorm-srgb",
  [37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */]: "astc-6x5-unorm",
  [37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */]: "astc-6x5-unorm-srgb",
  [37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */]: "astc-6x6-unorm",
  [37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */]: "astc-6x6-unorm-srgb",
  [37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */]: "astc-8x5-unorm",
  [37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */]: "astc-8x5-unorm-srgb",
  [37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */]: "astc-8x6-unorm",
  [37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */]: "astc-8x6-unorm-srgb",
  [37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */]: "astc-8x8-unorm",
  [37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */]: "astc-8x8-unorm-srgb",
  [37816 /* COMPRESSED_RGBA_ASTC_10x5_KHR */]: "astc-10x5-unorm",
  [37848 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */]: "astc-10x5-unorm-srgb",
  [37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */]: "astc-10x6-unorm",
  [37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */]: "astc-10x6-unorm-srgb",
  [37818 /* COMPRESSED_RGBA_ASTC_10x8_KHR */]: "astc-10x8-unorm",
  [37850 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */]: "astc-10x8-unorm-srgb",
  [37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */]: "astc-10x10-unorm",
  [37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */]: "astc-10x10-unorm-srgb",
  [37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */]: "astc-12x10-unorm",
  [37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */]: "astc-12x10-unorm-srgb",
  [37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */]: "astc-12x12-unorm",
  [37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */]: "astc-12x12-unorm-srgb",
  [36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */]: "bc7-rgba-unorm",
  [36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */]: "bc7-rgba-unorm-srgb",
  [36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */]: "bc6h-rgb-float",
  [36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */]: "bc6h-rgb-ufloat",
  [35907 /* SRGB8_ALPHA8 */]: "rgba8unorm-srgb",
  [36759 /* RGBA8_SNORM */]: "rgba8snorm",
  [36220 /* RGBA8UI */]: "rgba8uint",
  [36238 /* RGBA8I */]: "rgba8sint",
  [6408 /* RGBA */]: "rgba8unorm"
  // [GL_INTERNAL_FORMAT.RGBA8]: 'bgra8unorm'
};
const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
const FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const ENDIANNESS = 67305985;
const TYPES_TO_BYTES_PER_COMPONENT = {
  [5121 /* UNSIGNED_BYTE */]: 1,
  [5123 /* UNSIGNED_SHORT */]: 2,
  [5124 /* INT */]: 4,
  [5125 /* UNSIGNED_INT */]: 4,
  [5126 /* FLOAT */]: 4,
  [36193 /* HALF_FLOAT */]: 8
};
const FORMATS_TO_COMPONENTS = {
  [6408 /* RGBA */]: 4,
  [6407 /* RGB */]: 3,
  [33319 /* RG */]: 2,
  [6403 /* RED */]: 1,
  [6409 /* LUMINANCE */]: 1,
  [6410 /* LUMINANCE_ALPHA */]: 2,
  [6406 /* ALPHA */]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
  [32819 /* UNSIGNED_SHORT_4_4_4_4 */]: 2,
  [32820 /* UNSIGNED_SHORT_5_5_5_1 */]: 2,
  [33635 /* UNSIGNED_SHORT_5_6_5 */]: 2
};
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,
  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,
  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,
  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,
  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,
  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,
  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,
  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,
  [36283 /* COMPRESSED_RED_RGTC1_EXT */]: 0.5,
  [36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */]: 0.5,
  [36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */]: 1,
  [36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */]: 1,
  [37488 /* COMPRESSED_R11_EAC */]: 0.5,
  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,
  [37490 /* COMPRESSED_RG11_EAC */]: 1,
  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,
  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,
  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,
  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,
  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,
  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1,
  [37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */]: 1,
  [37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */]: 0.8,
  [37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */]: 0.8,
  [37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */]: 0.64,
  [37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */]: 0.64,
  [37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */]: 0.53375,
  [37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */]: 0.53375,
  [37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */]: 0.445,
  [37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */]: 0.445,
  [37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */]: 0.4,
  [37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */]: 0.4,
  [37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */]: 0.33375,
  [37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */]: 0.33375,
  [37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */]: 0.25,
  [37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */]: 0.25,
  [37816 /* COMPRESSED_RGBA_ASTC_10x5_KHR */]: 0.32,
  [37848 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */]: 0.32,
  [37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */]: 0.26625,
  [37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */]: 0.26625,
  [37818 /* COMPRESSED_RGBA_ASTC_10x8_KHR */]: 0.2,
  [37850 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */]: 0.2,
  [37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */]: 0.16,
  [37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */]: 0.16,
  [37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */]: 0.13375,
  [37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */]: 0.13375,
  [37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */]: 0.11125,
  [37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */]: 0.11125,
  [36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */]: 1,
  [36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */]: 1,
  [36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */]: 1,
  [36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */]: 1
};
const KTX = {
  FILE_HEADER_SIZE,
  FILE_IDENTIFIER,
  FORMATS_TO_COMPONENTS,
  INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
  INTERNAL_FORMAT_TO_TEXTURE_FORMATS,
  FIELDS,
  TYPES_TO_BYTES_PER_COMPONENT,
  TYPES_TO_BYTES_PER_PIXEL,
  ENDIANNESS
};


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadKTX2: () => (/* binding */ loadKTX2)
/* harmony export */ });
/* harmony import */ var _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/loader/parsers/LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../assets/loader/parsers/textures/utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");
/* harmony import */ var _assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/CompressedSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs");
/* harmony import */ var _worker_loadKTX2onWorker_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./worker/loadKTX2onWorker.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs");








"use strict";
const loadKTX2 = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.High,
    name: "loadKTX2"
  },
  name: "loadKTX2",
  test(url) {
    return (0,_assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, ".ktx2");
  },
  async load(url, _asset, loader) {
    const supportedTextures = await (0,_rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__.getSupportedTextureFormats)();
    const textureOptions = await (0,_worker_loadKTX2onWorker_mjs__WEBPACK_IMPORTED_MODULE_4__.loadKTX2onWorker)(url, supportedTextures);
    const compressedTextureSource = new _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_5__.CompressedSource(textureOptions);
    return (0,_assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_6__.createTexture)(compressedTextureSource, loader, url);
  },
  async unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};


//# sourceMappingURL=loadKTX2.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertFormatIfRequired: () => (/* binding */ convertFormatIfRequired)
/* harmony export */ });

const converters = {
  rgb8unorm: {
    convertedFormat: "rgba8unorm",
    convertFunction: convertRGBtoRGBA
  },
  "rgb8unorm-srgb": {
    convertedFormat: "rgba8unorm-srgb",
    convertFunction: convertRGBtoRGBA
  }
};
function convertFormatIfRequired(textureOptions) {
  const format = textureOptions.format;
  if (converters[format]) {
    const convertFunction = converters[format].convertFunction;
    const levelBuffers = textureOptions.resource;
    for (let i = 0; i < levelBuffers.length; i++) {
      levelBuffers[i] = convertFunction(levelBuffers[i]);
    }
    textureOptions.format = converters[format].convertedFormat;
  }
}
function convertRGBtoRGBA(levelBuffer) {
  const pixelCount = levelBuffer.byteLength / 3;
  const levelBufferWithAlpha = new Uint32Array(pixelCount);
  for (let i = 0; i < pixelCount; ++i) {
    levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;
  }
  return new Uint8Array(levelBufferWithAlpha.buffer);
}


//# sourceMappingURL=convertFormatIfRequired.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLevelBuffersFromKTX: () => (/* binding */ createLevelBuffersFromKTX)
/* harmony export */ });

function createLevelBuffersFromKTX(ktxTexture) {
  const levelBuffers = [];
  for (let i = 0; i < ktxTexture.numLevels; i++) {
    const imageData = ktxTexture.getImageData(i, 0, 0);
    const levelBuffer = new Uint8Array(imageData.byteLength);
    levelBuffer.set(imageData);
    levelBuffers.push(levelBuffer);
  }
  return levelBuffers;
}


//# sourceMappingURL=createLevelBuffersFromKTX.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTextureFormatFromKTXTexture: () => (/* binding */ getTextureFormatFromKTXTexture)
/* harmony export */ });
/* harmony import */ var _glFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glFormatToGPUFormat.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs");
/* harmony import */ var _vkFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vkFormatToGPUFormat.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs");



"use strict";
function getTextureFormatFromKTXTexture(ktxTexture) {
  if (ktxTexture.classId === 2) {
    return (0,_vkFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_0__.vkFormatToGPUFormat)(ktxTexture.vkFormat);
  }
  return (0,_glFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.glFormatToGPUFormat)(ktxTexture.glInternalformat);
}


//# sourceMappingURL=getTextureFormatFromKTXTexture.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   glFormatToGPUFormat: () => (/* binding */ glFormatToGPUFormat)
/* harmony export */ });

const glFormatToGPUFormatMap = {
  6408: "rgba8unorm",
  32856: "bgra8unorm",
  //
  32857: "rgb10a2unorm",
  33189: "depth16unorm",
  33190: "depth24plus",
  33321: "r8unorm",
  33323: "rg8unorm",
  33325: "r16float",
  33326: "r32float",
  33327: "rg16float",
  33328: "rg32float",
  33329: "r8sint",
  33330: "r8uint",
  33331: "r16sint",
  33332: "r16uint",
  33333: "r32sint",
  33334: "r32uint",
  33335: "rg8sint",
  33336: "rg8uint",
  33337: "rg16sint",
  33338: "rg16uint",
  33339: "rg32sint",
  33340: "rg32uint",
  33778: "bc2-rgba-unorm",
  33779: "bc3-rgba-unorm",
  34836: "rgba32float",
  34842: "rgba16float",
  35056: "depth24plus-stencil8",
  35898: "rg11b10ufloat",
  35901: "rgb9e5ufloat",
  35907: "rgba8unorm-srgb",
  // bgra8unorm-srgb
  36012: "depth32float",
  36013: "depth32float-stencil8",
  36168: "stencil8",
  36208: "rgba32uint",
  36214: "rgba16uint",
  36220: "rgba8uint",
  36226: "rgba32sint",
  36232: "rgba16sint",
  36238: "rgba8sint",
  36492: "bc7-rgba-unorm",
  36756: "r8snorm",
  36757: "rg8snorm",
  36759: "rgba8snorm",
  37496: "etc2-rgba8unorm",
  37808: "astc-4x4-unorm"
};
function glFormatToGPUFormat(glInternalFormat) {
  const format = glFormatToGPUFormatMap[glInternalFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);
}


//# sourceMappingURL=glFormatToGPUFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gpuFormatToKTXBasisTranscoderFormat: () => (/* binding */ gpuFormatToKTXBasisTranscoderFormat)
/* harmony export */ });

const gpuFormatToBasisTranscoderFormatMap = {
  "bc3-rgba-unorm": "BC3_RGBA",
  "bc7-rgba-unorm": "BC7_M5_RGBA",
  "etc2-rgba8unorm": "ETC2_RGBA",
  "astc-4x4-unorm": "ASTC_4x4_RGBA",
  // Uncompressed
  rgba8unorm: "RGBA32",
  rg11b10ufloat: "R11F_G11F_B10F"
};
function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
  const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
}


//# sourceMappingURL=gpuFormatToKTXBasisTranscoderFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ktxTranscoderUrls: () => (/* binding */ ktxTranscoderUrls),
/* harmony export */   setKTXTranscoderPath: () => (/* binding */ setKTXTranscoderPath)
/* harmony export */ });

const ktxTranscoderUrls = {
  jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js",
  wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm"
};
function setKTXTranscoderPath(config) {
  Object.assign(ktxTranscoderUrls, config);
}


//# sourceMappingURL=setKTXTranscoderPath.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   vkFormatToGPUFormat: () => (/* binding */ vkFormatToGPUFormat)
/* harmony export */ });

const vkFormatToGPUFormatMap = {
  23: "rgb8unorm",
  // VK_FORMAT_R8G8B8_UNORM
  37: "rgba8unorm",
  // VK_FORMAT_R8G8B8A8_UNORM
  43: "rgba8unorm-srgb"
  // VK_FORMAT_R8G8B8A8_SRGB
  // TODO add more!
};
function vkFormatToGPUFormat(vkFormat) {
  const format = vkFormatToGPUFormatMap[vkFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported VkFormat: ${vkFormat}`);
}


//# sourceMappingURL=vkFormatToGPUFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadKTX2onWorker: () => (/* binding */ loadKTX2onWorker)
/* harmony export */ });
/* harmony import */ var _virtual_ktx_worker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../_virtual/ktx.worker.mjs */ "./node_modules/pixi.js/lib/_virtual/ktx.worker.mjs");
/* harmony import */ var _utils_setKTXTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/setKTXTranscoderPath.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs");



"use strict";
let ktxWorker;
const urlHash = {};
function getKTX2Worker(supportedTextures) {
  if (!ktxWorker) {
    ktxWorker = new _virtual_ktx_worker_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]().worker;
    ktxWorker.onmessage = (messageEvent) => {
      const { success, url, textureOptions } = messageEvent.data;
      if (!success) {
        console.warn("Failed to load KTX texture", url);
      }
      urlHash[url](textureOptions);
    };
    ktxWorker.postMessage({
      type: "init",
      jsUrl: _utils_setKTXTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_1__.ktxTranscoderUrls.jsUrl,
      wasmUrl: _utils_setKTXTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_1__.ktxTranscoderUrls.wasmUrl,
      supportedTextures
    });
  }
  return ktxWorker;
}
function loadKTX2onWorker(url, supportedTextures) {
  const ktxWorker2 = getKTX2Worker(supportedTextures);
  return new Promise((resolve) => {
    urlHash[url] = resolve;
    ktxWorker2.postMessage({ type: "load", url });
  });
}


//# sourceMappingURL=loadKTX2onWorker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectCompressed: () => (/* binding */ detectCompressed)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getSupportedCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs");
/* harmony import */ var _utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/browser/isWebGLSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs");
/* harmony import */ var _utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/browser/isWebGPUSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs");
/* harmony import */ var _resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolveCompressedTextureUrl.mjs */ "./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs");






"use strict";
let compressedTextureExtensions;
const detectCompressed = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    if (await (0,_utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_1__.isWebGPUSupported)())
      return true;
    if ((0,_utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_2__.isWebGLSupported)())
      return true;
    return false;
  },
  add: async (formats) => {
    const supportedCompressedTextureFormats = await (0,_rendering_renderers_shared_texture_utils_getSupportedCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__.getSupportedCompressedTextureFormats)();
    compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats);
    return [...compressedTextureExtensions, ...formats];
  },
  remove: async (formats) => {
    if (compressedTextureExtensions) {
      return formats.filter((f) => !(f in compressedTextureExtensions));
    }
    return formats;
  }
};
function extractExtensionsForCompressedTextureFormats(formats) {
  const extensions = ["basis"];
  const dupeMap = {};
  formats.forEach((format) => {
    const extension = format.split("-")[0];
    if (extension && !dupeMap[extension]) {
      dupeMap[extension] = true;
      extensions.push(extension);
    }
  });
  extensions.sort((a, b) => {
    const aIndex = _resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_4__.validFormats.indexOf(a);
    const bIndex = _resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_4__.validFormats.indexOf(b);
    if (aIndex === -1) {
      return 1;
    }
    if (bIndex === -1) {
      return -1;
    }
    return aIndex - bIndex;
  });
  return extensions;
}


//# sourceMappingURL=detectCompressed.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveCompressedTextureUrl: () => (/* binding */ resolveCompressedTextureUrl),
/* harmony export */   validFormats: () => (/* binding */ validFormats)
/* harmony export */ });
/* harmony import */ var _assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/resolver/Resolver.mjs */ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs");
/* harmony import */ var _assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../assets/utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");




"use strict";
const validFormats = ["basis", "bc7", "bc6h", "astc", "etc2", "bc5", "bc4", "bc3", "bc2", "bc1", "eac"];
const resolveCompressedTextureUrl = {
  extension: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ResolveParser,
  test: (value) => (0,_assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_1__.checkExtension)(value, [".ktx", ".ktx2", ".dds"]),
  parse: (value) => {
    let format;
    const splitValue = value.split(".");
    if (splitValue.length > 2) {
      const newFormat = splitValue[splitValue.length - 2];
      if (validFormats.includes(newFormat)) {
        format = newFormat;
      }
    } else {
      format = splitValue[splitValue.length - 1];
    }
    return {
      resolution: parseFloat(_assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_2__.Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format,
      src: value
    };
  }
};


//# sourceMappingURL=resolveCompressedTextureUrl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/culling/Culler.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/culling/Culler.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Culler: () => (/* binding */ Culler)
/* harmony export */ });
/* harmony import */ var _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene/container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scene/container/bounds/getGlobalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs");



"use strict";
const tempBounds = new _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__.Bounds();
const _Culler = class _Culler {
  /**
   * Culls the children of a specific container based on the given view. This will also cull items that are not
   * being explicitly managed by the culler.
   * @param container - The container to cull.
   * @param view - The view rectangle.
   * @param skipUpdateTransform - Whether to skip updating the transform.
   */
  cull(container, view, skipUpdateTransform = true) {
    this._cullRecursive(container, view, skipUpdateTransform);
  }
  _cullRecursive(container, view, skipUpdateTransform = true) {
    if (container.cullable && container.measurable && container.includeInBuild) {
      const bounds = container.cullArea ?? (0,_scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.getGlobalBounds)(container, skipUpdateTransform, tempBounds);
      container.culled = bounds.x >= view.x + view.width || bounds.y >= view.y + view.height || bounds.x + bounds.width <= view.x || bounds.y + bounds.height <= view.y;
    } else {
      container.culled = false;
    }
    if (!container.cullableChildren || container.culled || !container.renderable || !container.measurable || !container.includeInBuild)
      return;
    for (let i = 0; i < container.children.length; i++) {
      this._cullRecursive(container.children[i], view, skipUpdateTransform);
    }
  }
};
/** A shared instance of the Culler class. */
_Culler.shared = new _Culler();
let Culler = _Culler;


//# sourceMappingURL=Culler.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/culling/CullerPlugin.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/culling/CullerPlugin.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CullerPlugin: () => (/* binding */ CullerPlugin)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _Culler_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Culler.mjs */ "./node_modules/pixi.js/lib/culling/Culler.mjs");



"use strict";
class CullerPlugin {
  static init() {
    this._renderRef = this.render.bind(this);
    this.render = () => {
      _Culler_mjs__WEBPACK_IMPORTED_MODULE_0__.Culler.shared.cull(this.stage, this.renderer.screen);
      this.renderer.render({ container: this.stage });
    };
  }
  static destroy() {
    this.render = this._renderRef;
  }
}
/** @ignore */
CullerPlugin.extension = {
  priority: 10,
  type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.Application,
  name: "culler"
};


//# sourceMappingURL=CullerPlugin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/culling/cullingMixin.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/culling/cullingMixin.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cullingMixin: () => (/* binding */ cullingMixin)
/* harmony export */ });

const cullingMixin = {
  cullArea: null,
  cullable: false,
  cullableChildren: true
};


//# sourceMappingURL=cullingMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/dom/DOMContainer.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/dom/DOMContainer.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOMContainer: () => (/* binding */ DOMContainer)
/* harmony export */ });
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _scene_view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene/view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");



"use strict";
class DOMContainer extends _scene_view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  /**
   * @param options - The options for creating the DOM container.
   */
  constructor(options = {}) {
    const { element, anchor, ...rest } = options;
    super({
      label: "DOMContainer",
      ...rest
    });
    /** @private */
    this.renderPipeId = "dom";
    /** @private */
    this.batched = false;
    this._anchor = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0);
    if (anchor) {
      this.anchor = anchor;
    }
    this.element = options.element || document.createElement("div");
  }
  /**
   * The anchor sets the origin point of the container.
   * The default is `(0,0)`, this means the container's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the container's origin is centered.
   * Setting the anchor to `(1,1)` would mean the container's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  set element(value) {
    if (this._element === value)
      return;
    this._element = value;
    this.onViewUpdate();
  }
  /** The DOM element that this container is using. */
  get element() {
    return this._element;
  }
  /** @private */
  updateBounds() {
    const bounds = this._bounds;
    const element = this._element;
    if (!element) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return;
    }
    const { offsetWidth, offsetHeight } = element;
    bounds.minX = 0;
    bounds.maxX = offsetWidth;
    bounds.minY = 0;
    bounds.maxY = offsetHeight;
  }
  /**
   * Destroys this DOM container.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   */
  destroy(options = false) {
    super.destroy(options);
    this._element?.parentNode?.removeChild(this._element);
    this._element = null;
    this._anchor = null;
  }
}


//# sourceMappingURL=DOMContainer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/dom/DOMPipe.mjs":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/dom/DOMPipe.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOMPipe: () => (/* binding */ DOMPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class DOMPipe {
  /**
   * Constructor for the DOMPipe class.
   * @param renderer - The renderer instance that this DOMPipe will be associated with.
   */
  constructor(renderer) {
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    /** Array to keep track of attached DOM elements */
    this._attachedDomElements = [];
    this._renderer = renderer;
    this._renderer.runners.postrender.add(this);
    this._domElement = document.createElement("div");
    this._domElement.style.position = "absolute";
    this._domElement.style.top = "0";
    this._domElement.style.left = "0";
    this._domElement.style.pointerEvents = "none";
    this._domElement.style.zIndex = "1000";
  }
  /**
   * Adds a renderable DOM container to the list of attached elements.
   * @param domContainer - The DOM container to be added.
   * @param _instructionSet - The instruction set (unused).
   */
  addRenderable(domContainer, _instructionSet) {
    if (!this._attachedDomElements.includes(domContainer)) {
      this._attachedDomElements.push(domContainer);
      domContainer.on("destroyed", this._destroyRenderableBound);
    }
  }
  /**
   * Updates a renderable DOM container.
   * @param _domContainer - The DOM container to be updated (unused).
   */
  updateRenderable(_domContainer) {
  }
  /**
   * Validates a renderable DOM container.
   * @param _domContainer - The DOM container to be validated (unused).
   * @returns Always returns true as validation is not required.
   */
  validateRenderable(_domContainer) {
    return true;
  }
  /**
   * Destroys a renderable DOM container, removing it from the list of attached elements.
   * @param domContainer - The DOM container to be destroyed.
   */
  destroyRenderable(domContainer) {
    const index = this._attachedDomElements.indexOf(domContainer);
    if (index !== -1) {
      this._attachedDomElements.splice(index, 1);
    }
    domContainer.off("destroyed", this._destroyRenderableBound);
  }
  /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */
  postrender() {
    const attachedDomElements = this._attachedDomElements;
    if (attachedDomElements.length === 0) {
      this._domElement.remove();
      return;
    }
    const canvas = this._renderer.view.canvas;
    if (this._domElement.parentNode !== canvas.parentNode) {
      canvas.parentNode?.appendChild(this._domElement);
    }
    this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px)`;
    for (let i = 0; i < attachedDomElements.length; i++) {
      const domContainer = attachedDomElements[i];
      const element = domContainer.element;
      if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {
        element.remove();
        attachedDomElements.splice(i, 1);
        i--;
      } else {
        if (!this._domElement.contains(element)) {
          element.style.position = "absolute";
          element.style.pointerEvents = "auto";
          this._domElement.appendChild(element);
        }
        const wt = domContainer.worldTransform;
        const anchor = domContainer._anchor;
        const ax = domContainer.width * anchor.x;
        const ay = domContainer.height * anchor.y;
        element.style.transformOrigin = `${ax}px ${ay}px`;
        element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;
        element.style.opacity = domContainer.groupAlpha.toString();
      }
    }
  }
  /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */
  destroy() {
    this._renderer.runners.postrender.remove(this);
    for (let i = 0; i < this._attachedDomElements.length; i++) {
      const domContainer = this._attachedDomElements[i];
      domContainer.off("destroyed", this._destroyRenderableBound);
      domContainer.element.remove();
    }
    this._attachedDomElements.length = 0;
    this._domElement.remove();
    this._renderer = null;
  }
}
/**
 * Static property defining the extension type and name for the DOMPipe.
 * This is used to register the DOMPipe with different rendering pipelines.
 */
DOMPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasPipes
  ],
  name: "dom"
};


//# sourceMappingURL=DOMPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserAdapter: () => (/* binding */ BrowserAdapter)
/* harmony export */ });

const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};


//# sourceMappingURL=BrowserAdapter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-browser/browserExt.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-browser/browserExt.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   browserExt: () => (/* binding */ browserExt)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const browserExt = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Environment,
    name: "browser",
    priority: -1
  },
  test: () => true,
  load: async () => {
    await __webpack_require__.e(/*! import() */ "node_modules_pixi_js_lib_environment-browser_browserAll_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./browserAll.mjs */ "./node_modules/pixi.js/lib/environment-browser/browserAll.mjs"));
  }
};


//# sourceMappingURL=browserExt.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebWorkerAdapter: () => (/* binding */ WebWorkerAdapter)
/* harmony export */ });
/* harmony import */ var _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @xmldom/xmldom */ "./node_modules/@xmldom/xmldom/lib/index.js");


"use strict";
const WebWorkerAdapter = {
  createCanvas: (width, height) => new OffscreenCanvas(width ?? 0, height ?? 0),
  getCanvasRenderingContext2D: () => OffscreenCanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => globalThis.location.href,
  getFontFaceSet: () => globalThis.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_0__.DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};


//# sourceMappingURL=WebWorkerAdapter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   webworkerExt: () => (/* binding */ webworkerExt)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const webworkerExt = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await __webpack_require__.e(/*! import() */ "node_modules_pixi_js_lib_environment-webworker_webworkerAll_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./webworkerAll.mjs */ "./node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"));
  }
};


//# sourceMappingURL=webworkerExt.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/environment/adapter.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment/adapter.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOMAdapter: () => (/* binding */ DOMAdapter)
/* harmony export */ });
/* harmony import */ var _environment_browser_BrowserAdapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../environment-browser/BrowserAdapter.mjs */ "./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs");


"use strict";
let currentAdapter = _environment_browser_BrowserAdapter_mjs__WEBPACK_IMPORTED_MODULE_0__.BrowserAdapter;
const DOMAdapter = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return currentAdapter;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(adapter) {
    currentAdapter = adapter;
  }
};


//# sourceMappingURL=adapter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autoDetectEnvironment: () => (/* binding */ autoDetectEnvironment),
/* harmony export */   loadEnvironmentExtensions: () => (/* binding */ loadEnvironmentExtensions)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const environments = [];
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions.handleByNamedList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Environment, environments);
async function loadEnvironmentExtensions(skip) {
  if (skip)
    return;
  for (let i = 0; i < environments.length; i++) {
    const env = environments[i];
    if (env.value.test()) {
      await env.value.load();
      return;
    }
  }
}
async function autoDetectEnvironment(add) {
  return loadEnvironmentExtensions(!add);
}


//# sourceMappingURL=autoDetectEnvironment.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/EventBoundary.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/EventBoundary.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventBoundary: () => (/* binding */ EventBoundary)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventTicker.mjs */ "./node_modules/pixi.js/lib/events/EventTicker.mjs");
/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FederatedMouseEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs");
/* harmony import */ var _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FederatedPointerEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs");
/* harmony import */ var _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FederatedWheelEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs");








"use strict";
const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
const tempLocalMapping = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
class EventBoundary {
  /**
   * @param rootTarget - The holder of the event boundary.
   */
  constructor(rootTarget) {
    /**
     * Emits events after they were dispatched into the scene graph.
     *
     * This can be used for global events listening, regardless of the scene graph being used. It should
     * not be used by interactive libraries for normal use.
     *
     * Special events that do not bubble all the way to the root target are not emitted from here,
     * e.g. pointerenter, pointerleave, click.
     */
    this.dispatch = new eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"]();
    /**
     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.
     *
     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of
     * the Pointer Event API's approach.
     */
    this.moveOnAll = false;
    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */
    this.enableGlobalMoveEvents = true;
    /**
     * State object for mapping methods.
     * @see EventBoundary#trackingData
     */
    this.mappingState = {
      trackingData: {}
    };
    /**
     * The event pool maps event constructors to an free pool of instances of those specific events.
     * @see EventBoundary#allocateEvent
     * @see EventBoundary#freeEvent
     */
    this.eventPool = /* @__PURE__ */ new Map();
    /** Every interactive element gathered from the scene. Only used in `pointermove` */
    this._allInteractiveElements = [];
    /** Every element that passed the hit test. Only used in `pointermove` */
    this._hitElements = [];
    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  /**
   * Adds an event mapping for the event `type` handled by `fn`.
   *
   * Event mappings can be used to implement additional or custom events. They take an event
   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
   *
   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
   * instead.
   * @param type - The type of upstream event to map.
   * @param fn - The mapping method. The context of this function must be bound manually, if desired.
   */
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  /**
   * Dispatches the given event
   * @param e - The event to dispatch.
   * @param type - The type of event to dispatch. Defaults to `e.type`.
   */
  dispatchEvent(e, type) {
    e.propagationStopped = false;
    e.propagationImmediatelyStopped = false;
    this.propagate(e, type);
    this.dispatch.emit(type || e.type, e);
  }
  /**
   * Maps the given upstream event through the event boundary and propagates it downstream.
   * @param e - The event to map.
   */
  mapEvent(e) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e.type];
    if (mappers) {
      for (let i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)(`[EventBoundary]: Event mapping not defined for ${e.type}`);
    }
  }
  /**
   * Finds the Container that is the target of a event at the given coordinates.
   *
   * The passed (x,y) coordinates are in the world space above this event boundary.
   * @param x - The x coordinate of the event.
   * @param y - The y coordinate of the event.
   */
  hitTest(x, y) {
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_3__.EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](
      this.rootTarget,
      this.rootTarget.eventMode,
      tempHitLocation.set(x, y),
      this.hitTestFn,
      this.hitPruneFn
    );
    return invertedPath && invertedPath[0];
  }
  /**
   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
   * target {@code e.target}.
   * @param e - The event to propagate.
   * @param type - The type of event to propagate. Defaults to `e.type`.
   */
  propagate(e, type) {
    if (!e.target) {
      return;
    }
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    for (let i = composedPath.length - 2; i >= 0; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
  }
  /**
   * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
   *
   * This is used in the `globalpointermove` event.
   * @param e - The emitted event.
   * @param type - The listeners to notify.
   * @param targets - The targets to notify.
   */
  all(e, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i = targets.length - 1; i >= 0; i--) {
      events.forEach((event) => {
        e.currentTarget = targets[i];
        this.notifyTarget(e, event);
      });
    }
  }
  /**
   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
   * {@code target}. The last element in the path is {@code target}.
   * @param target - The target to find the propagation path to.
   */
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_3__.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestMoveRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          location,
          testFn,
          pruneFn,
          ignore || pruneFn(currentTarget, location)
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  /**
   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
   * @param currentTarget - The Container that is to be hit tested.
   * @param eventMode - The event mode for the `currentTarget` or one of its parents.
   * @param location - The location that is being tested for overlap.
   * @param testFn - Callback that determines whether the target passes hit testing. This callback
   *  can assume that `pruneFn` failed to prune the container.
   * @param pruneFn - Callback that determiness whether the target and all of its children
   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
   *  of the scene graph.
   * @returns An array holding the hit testing target and all its ancestors in order. The first element
   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
   */
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_3__.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      const relativeLocation = location;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          relativeLocation,
          testFn,
          pruneFn
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(container) {
    if (!container || !container.visible || !container.renderable || !container.measurable) {
      return true;
    }
    if (container.eventMode === "none") {
      return true;
    }
    if (container.eventMode === "passive" && !container.interactiveChildren) {
      return true;
    }
    return false;
  }
  /**
   * Checks whether the container or any of its children cannot pass the hit test at all.
   *
   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
   * and {@link Container._maskEffect} for pruning.
   * @param container - The container to prune.
   * @param location - The location to test for overlap.
   */
  hitPruneFn(container, location) {
    if (container.hitArea) {
      container.worldTransform.applyInverse(location, tempLocalMapping);
      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (container.effects && container.effects.length) {
      for (let i = 0; i < container.effects.length; i++) {
        const effect = container.effects[i];
        if (effect.containsPoint) {
          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
          if (!effectContainsPoint) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Checks whether the container passes hit testing for the given location.
   * @param container - The container to test.
   * @param location - The location to test for overlap.
   * @returns - Whether `container` passes hit testing for `location`.
   */
  hitTestFn(container, location) {
    if (container.hitArea) {
      return true;
    }
    if (container?.containsPoint) {
      container.worldTransform.applyInverse(location, tempLocalMapping);
      return container.containsPoint(tempLocalMapping);
    }
    return false;
  }
  /**
   * Notify all the listeners to the event's `currentTarget`.
   *
   * If the `currentTarget` contains the property `on<type>`, then it is called here,
   * simulating the behavior from version 6.x and prior.
   * @param e - The event passed to the target.
   * @param type - The type of event to notify. Defaults to `e.type`.
   */
  notifyTarget(e, type) {
    if (!e.currentTarget.isInteractive()) {
      return;
    }
    type ?? (type = e.type);
    const handlerKey = `on${type}`;
    e.currentTarget[handlerKey]?.(e);
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this._notifyListeners(e, key);
    if (e.eventPhase === e.AT_TARGET) {
      this._notifyListeners(e, type);
    }
  }
  /**
   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
   *
   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
   * @param from - The upstream `pointerdown` event.
   */
  mapPointerDown(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerdown");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchstart");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e.composedPath();
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
   *
   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
   * @param from - The upstream `pointermove` event.
   */
  mapPointerMove(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
   *
   * The tracking data for the specific pointer gets a new `overTarget`.
   * @param from - The upstream `pointerover` event.
   */
  mapPointerOver(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e = this.createPointerEvent(from);
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    this.dispatchEvent(e, "pointerover");
    if (isMouse)
      this.dispatchEvent(e, "mouseover");
    if (e.pointerType === "mouse")
      this.cursor = e.target?.cursor;
    const enterEvent = this.clonePointerEvent(e, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
    this.freeEvent(enterEvent);
  }
  /**
   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
   *
   * The tracking data for the specific pointer is cleared of a `overTarget`.
   * @param from - The upstream `pointerout` event.
   */
  mapPointerOut(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  /**
   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
   * and `click`/`rightclick`/`pointertap` events, in that order.
   *
   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
   * specific pointer types.
   * @param from - The upstream `pointerup` event.
   */
  mapPointerUp(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerup");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchend");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e.composedPath().includes(currentTarget)) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
   * `pointerdown` target to `rootTarget`.
   *
   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
   *
   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
   * @param from - The upstream `pointerupoutside` event.
   */
  mapPointerUpOutside(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `wheel` event to a downstream `wheel` event.
   * @param from - The upstream `wheel` event.
   */
  mapWheel(from) {
    if (!(from instanceof _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_5__.FederatedWheelEvent)) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  /**
   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
   *
   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
   * or `pointerover` target was unmounted from the scene graph.
   * @param propagationPath - The propagation path was valid in the past.
   * @returns - The most specific event-target still mounted at the same location in the scene graph.
   */
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length; i++) {
      if (propagationPath[i].parent === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  /**
   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The {@code originalEvent} for the returned event.
   * @param [type=from.type] - The type of the returned event.
   * @param target - The target of the returned event.
   */
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(_FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  /**
   * Creates a wheel event whose {@code originalEvent} is {@code from}.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The upstream wheel event.
   */
  createWheelEvent(from) {
    const event = this.allocateEvent(_FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_5__.FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  /**
   * Clones the event {@code from}, with an optional {@code type} override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The event to clone.
   * @param [type=from.type] - The type of the returned event.
   */
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(_FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  /**
   * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + deltaMode
   * + deltaX
   * + deltaY
   * + deltaZ
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  /**
   * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + pointerId
   * + width
   * + height
   * + isPrimary
   * + pointerType
   * + pressure
   * + tangentialPressure
   * + tiltX
   * + tiltY
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyPointerData(from, to) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent && to instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedPointerEvent))
      return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  /**
   * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
   *
   * The following properties are copied:
   * + altKey
   * + button
   * + buttons
   * + clientX
   * + clientY
   * + metaKey
   * + movementX
   * + movementY
   * + pageX
   * + pageY
   * + x
   * + y
   * + screen
   * + shiftKey
   * + global
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyMouseData(from, to) {
    if (!(from instanceof _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_6__.FederatedMouseEvent && to instanceof _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_6__.FederatedMouseEvent))
      return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  /**
   * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
   *
   * The following properties are copied:
   * + isTrusted
   * + srcElement
   * + timeStamp
   * + type
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  /**
   * @param id - The pointer ID.
   * @returns The tracking data stored for the given pointer. If no data exists, a blank
   *  state will be created.
   */
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  /**
   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
   *
   * This allocation is constructor-agnostic, as long as it only takes one argument - this event
   * boundary.
   * @param constructor - The event's constructor.
   */
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.defaultPrevented = false;
    event.path = null;
    event.target = null;
    return event;
  }
  /**
   * Frees the event and puts it back into the event pool.
   *
   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
   *
   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
   * not be freed. This is because of the possibility that the same event is freed twice, which can cause
   * it to be allocated twice & result in overwriting.
   * @param event - The event to be freed.
   * @throws Error if the event is managed by another event boundary.
   */
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  /**
   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
   * is set on the event.
   * @param e - The event to call each listener with.
   * @param type - The event key.
   */
  _notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (!listeners)
      return;
    if ("fn" in listeners) {
      if (listeners.once)
        e.currentTarget.removeListener(type, listeners.fn, void 0, true);
      listeners.fn.call(listeners.context, e);
    } else {
      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once)
          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
        listeners[i].fn.call(listeners[i].context, e);
      }
    }
  }
}


//# sourceMappingURL=EventBoundary.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/EventSystem.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/EventSystem.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventSystem: () => (/* binding */ EventSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventBoundary.mjs */ "./node_modules/pixi.js/lib/events/EventBoundary.mjs");
/* harmony import */ var _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventTicker.mjs */ "./node_modules/pixi.js/lib/events/EventTicker.mjs");
/* harmony import */ var _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FederatedPointerEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs");
/* harmony import */ var _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FederatedWheelEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs");






"use strict";
const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class _EventSystem {
  /**
   * @param {Renderer} renderer
   */
  constructor(renderer) {
    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    /**
     * The DOM element to which the root event listeners are bound. This is automatically set to
     * the renderer's {@link Renderer#view view}.
     */
    this.domElement = null;
    /** The resolution used to convert between the DOM client space into world space. */
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new _EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_0__.EventBoundary(null);
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.init(this);
    this.autoPreventDefault = true;
    this._eventsAdded = false;
    this._rootPointerEvent = new _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_2__.FederatedPointerEvent(null);
    this._rootWheelEvent = new _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this._onPointerDown = this._onPointerDown.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerUp = this._onPointerUp.bind(this);
    this._onPointerOverOut = this._onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  /**
   * The default interaction mode for all display objects.
   * @see Container.eventMode
   * @type {EventMode}
   * @readonly
   * @since 7.2.0
   */
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(options) {
    const { canvas, resolution } = this.renderer;
    this.setTargetElement(canvas);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "passive";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  /**
   * Handle changing resolution.
   * @ignore
   */
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  /** Destroys all event listeners and detaches the renderer. */
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
    this._currentCursor = null;
  }
  /**
   * Sets the current cursor mode, handling any callbacks or CSS style changes.
   * @param mode - cursor mode, a key from the cursorStyles dictionary
   */
  setCursor(mode) {
    mode || (mode = "default");
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this._currentCursor === mode) {
      return;
    }
    this._currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  /**
   * The global pointer event.
   * Useful for getting the pointer position without listening to events.
   * @since 7.2.0
   */
  get pointer() {
    return this._rootPointerEvent;
  }
  /**
   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const events = this._normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i = 0, j = events.length; i < j; i++) {
      const nativeEvent2 = events[i];
      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch events.
   */
  _onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.pointerMoved();
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
   * @param nativeEvent - The native wheel event.
   */
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  /**
   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
   *
   * To deregister the current DOM element without setting a new one, pass {@code null}.
   * @param element - The new DOM element.
   */
  setTargetElement(element) {
    this._removeEvents();
    this.domElement = element;
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.domElement = element;
    this._addEvents();
  }
  /** Register event listeners on {@link Renderer#domElement this.domElement}. */
  _addEvents() {
    if (this._eventsAdded || !this.domElement) {
      return;
    }
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this._onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
      this.domElement.addEventListener("mousedown", this._onPointerDown, true);
      this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this._onPointerUp, true);
      if (this.supportsTouchEvents) {
        this.domElement.addEventListener("touchstart", this._onPointerDown, true);
        this.domElement.addEventListener("touchend", this._onPointerUp, true);
        this.domElement.addEventListener("touchmove", this._onPointerMove, true);
      }
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this._eventsAdded = true;
  }
  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
  _removeEvents() {
    if (!this._eventsAdded || !this.domElement) {
      return;
    }
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "";
        style.msTouchAction = "";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this._onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this._onPointerUp, true);
      if (this.supportsTouchEvents) {
        this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
        this.domElement.removeEventListener("touchend", this._onPointerUp, true);
        this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
      }
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this._eventsAdded = false;
  }
  /**
   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
   * resulting value is stored in the point. This takes into account the fact that the DOM
   * element could be scaled and positioned anywhere on the screen.
   * @param  {PointData} point - the point that the result will be stored in
   * @param  {number} x - the x coord of the position to map
   * @param  {number} y - the y coord of the position to map
   */
  mapPositionToPoint(point, x, y) {
    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: this.domElement.width,
      height: this.domElement.height,
      left: 0,
      top: 0
    };
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  /**
   * Ensures that the original event object contains all data that a regular pointer event would have
   * @param event - The original event data from a touch or mouse event
   * @returns An array containing a single normalized pointer event, in the case of a pointer
   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
   */
  _normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  /**
   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
   *
   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
   * multiple native wheel events.
   * @param nativeEvent - The native wheel event that occurred on the canvas.
   * @returns A federated wheel event.
   */
  normalizeWheelEvent(nativeEvent) {
    const event = this._rootWheelEvent;
    this._transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  /**
   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
   * @param event
   * @param nativeEvent
   */
  _bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this._transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  /**
   * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
   * @param event
   * @param nativeEvent
   */
  _transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
/** @ignore */
_EventSystem.extension = {
  name: "events",
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.CanvasSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGPUSystem
  ],
  priority: -1
};
/**
 * The event features that are enabled by the EventSystem
 * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.
 * @since 7.2.0
 */
_EventSystem.defaultEventFeatures = {
  /** Enables pointer events associated with pointer movement. */
  move: true,
  /** Enables global pointer move events. */
  globalMove: true,
  /** Enables pointer events associated with clicking. */
  click: true,
  /** Enables wheel events. */
  wheel: true
};
let EventSystem = _EventSystem;


//# sourceMappingURL=EventSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/EventTicker.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/EventTicker.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventsTicker: () => (/* binding */ EventsTicker)
/* harmony export */ });
/* harmony import */ var _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ticker/const.mjs */ "./node_modules/pixi.js/lib/ticker/const.mjs");
/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ticker/Ticker.mjs */ "./node_modules/pixi.js/lib/ticker/Ticker.mjs");



"use strict";
class EventsTickerClass {
  constructor() {
    /** The frequency that fake events will be fired. */
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
  /**
   * Initializes the event ticker.
   * @param events - The event system.
   */
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
  /** Whether to pause the update checks or not. */
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  /** Adds the ticker listener. */
  addTickerListener() {
    if (this._tickerAdded || !this.domElement) {
      return;
    }
    _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.add(this._tickerUpdate, this, _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY.INTERACTION);
    this._tickerAdded = true;
  }
  /** Removes the ticker listener. */
  removeTickerListener() {
    if (!this._tickerAdded) {
      return;
    }
    _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.remove(this._tickerUpdate, this);
    this._tickerAdded = false;
  }
  /** Sets flag to not fire extra events when the user has already moved there mouse */
  pointerMoved() {
    this._didMove = true;
  }
  /** Updates the state of interactive objects. */
  _update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["_rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY,
      pointerType: rootPointerEvent.pointerType,
      pointerId: rootPointerEvent.pointerId
    }));
  }
  /**
   * Updates the state of interactive objects if at least {@link interactionFrequency}
   * milliseconds have passed since the last invocation.
   *
   * Invoked by a throttled ticker update from {@link Ticker.system}.
   * @param ticker - The throttled ticker.
   */
  _tickerUpdate(ticker) {
    this._deltaTime += ticker.deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this._update();
  }
}
const EventsTicker = new EventsTickerClass();


//# sourceMappingURL=EventTicker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedEvent.mjs":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedEvent.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FederatedEvent: () => (/* binding */ FederatedEvent)
/* harmony export */ });
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");


"use strict";
class FederatedEvent {
  /**
   * @param manager - The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */
  constructor(manager) {
    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */
    this.bubbles = true;
    /** @deprecated since 7.0.0 */
    this.cancelBubble = true;
    /**
     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always
     * false (for now).
     */
    this.cancelable = false;
    /**
     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events
     * API.
     * @see https://dom.spec.whatwg.org/#dom-event-composed
     */
    this.composed = false;
    /** Flags whether the default response of the user agent was prevent through this event. */
    this.defaultPrevented = false;
    /**
     * The propagation phase.
     * @default {@link FederatedEvent.NONE}
     */
    this.eventPhase = FederatedEvent.prototype.NONE;
    /** Flags whether propagation was stopped. */
    this.propagationStopped = false;
    /** Flags whether propagation was immediately stopped. */
    this.propagationImmediatelyStopped = false;
    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */
    this.layer = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();
    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */
    this.page = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  /** @readonly */
  get layerX() {
    return this.layer.x;
  }
  /** @readonly */
  get layerY() {
    return this.layer.y;
  }
  /** @readonly */
  get pageX() {
    return this.page.x;
  }
  /** @readonly */
  get pageY() {
    return this.page.y;
  }
  /**
   * Fallback for the deprecated @code{InteractionEvent.data}.
   * @deprecated since 7.0.0
   */
  get data() {
    return this;
  }
  /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  /**
   * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
   * @deprecated
   * @param _type
   * @param _bubbles
   * @param _cancelable
   */
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /**
   * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
   * @deprecated
   * @param _typeArg
   * @param _bubblesArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   */
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /** Prevent default behavior of PixiJS and the user agent. */
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  /**
   * Stop this event from propagating to any addition listeners, including on the
   * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
   * event targets on the propagation path.
   */
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  /**
   * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
   * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
}


//# sourceMappingURL=FederatedEvent.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedEventTarget.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedEventTarget.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FederatedContainer: () => (/* binding */ FederatedContainer)
/* harmony export */ });
/* harmony import */ var _EventSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSystem.mjs */ "./node_modules/pixi.js/lib/events/EventSystem.mjs");
/* harmony import */ var _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FederatedEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedEvent.mjs");



"use strict";
const FederatedContainer = {
  /**
   * Property-based event handler for the `click` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onclick = (event) => {
   *  //some function here that happens on click
   * }
   */
  onclick: null,
  /**
   * Property-based event handler for the `mousedown` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmousedown = (event) => {
   *  //some function here that happens on mousedown
   * }
   */
  onmousedown: null,
  /**
   * Property-based event handler for the `mouseenter` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseenter = (event) => {
   *  //some function here that happens on mouseenter
   * }
   */
  onmouseenter: null,
  /**
   * Property-based event handler for the `mouseleave` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseleave = (event) => {
   *  //some function here that happens on mouseleave
   * }
   */
  onmouseleave: null,
  /**
   * Property-based event handler for the `mousemove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmousemove = (event) => {
   *  //some function here that happens on mousemove
   * }
   */
  onmousemove: null,
  /**
   * Property-based event handler for the `globalmousemove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onglobalmousemove = (event) => {
   *  //some function here that happens on globalmousemove
   * }
   */
  onglobalmousemove: null,
  /**
   * Property-based event handler for the `mouseout` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseout = (event) => {
   *  //some function here that happens on mouseout
   * }
   */
  onmouseout: null,
  /**
   * Property-based event handler for the `mouseover` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseover = (event) => {
   *  //some function here that happens on mouseover
   * }
   */
  onmouseover: null,
  /**
   * Property-based event handler for the `mouseup` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseup = (event) => {
   *  //some function here that happens on mouseup
   * }
   */
  onmouseup: null,
  /**
   * Property-based event handler for the `mouseupoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onmouseupoutside = (event) => {
   *  //some function here that happens on mouseupoutside
   * }
   */
  onmouseupoutside: null,
  /**
   * Property-based event handler for the `pointercancel` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointercancel = (event) => {
   *  //some function here that happens on pointercancel
   * }
   */
  onpointercancel: null,
  /**
   * Property-based event handler for the `pointerdown` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerdown = (event) => {
   *  //some function here that happens on pointerdown
   * }
   */
  onpointerdown: null,
  /**
   * Property-based event handler for the `pointerenter` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerenter = (event) => {
   *  //some function here that happens on pointerenter
   * }
   */
  onpointerenter: null,
  /**
   * Property-based event handler for the `pointerleave` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerleave = (event) => {
   *  //some function here that happens on pointerleave
   * }
   */
  onpointerleave: null,
  /**
   * Property-based event handler for the `pointermove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointermove = (event) => {
   *  //some function here that happens on pointermove
   * }
   */
  onpointermove: null,
  /**
   * Property-based event handler for the `globalpointermove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onglobalpointermove = (event) => {
   *  //some function here that happens on globalpointermove
   * }
   */
  onglobalpointermove: null,
  /**
   * Property-based event handler for the `pointerout` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerout = (event) => {
   *  //some function here that happens on pointerout
   * }
   */
  onpointerout: null,
  /**
   * Property-based event handler for the `pointerover` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerover = (event) => {
   *  //some function here that happens on pointerover
   * }
   */
  onpointerover: null,
  /**
   * Property-based event handler for the `pointertap` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointertap = (event) => {
   *  //some function here that happens on pointertap
   * }
   */
  onpointertap: null,
  /**
   * Property-based event handler for the `pointerup` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerup = (event) => {
   *  //some function here that happens on pointerup
   * }
   */
  onpointerup: null,
  /**
   * Property-based event handler for the `pointerupoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onpointerupoutside = (event) => {
   *  //some function here that happens on pointerupoutside
   * }
   */
  onpointerupoutside: null,
  /**
   * Property-based event handler for the `rightclick` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightclick = (event) => {
   *  //some function here that happens on rightclick
   * }
   */
  onrightclick: null,
  /**
   * Property-based event handler for the `rightdown` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightdown = (event) => {
   *  //some function here that happens on rightdown
   * }
   */
  onrightdown: null,
  /**
   * Property-based event handler for the `rightup` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightup = (event) => {
   *  //some function here that happens on rightup
   * }
   */
  onrightup: null,
  /**
   * Property-based event handler for the `rightupoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onrightupoutside = (event) => {
   *  //some function here that happens on rightupoutside
   * }
   */
  onrightupoutside: null,
  /**
   * Property-based event handler for the `tap` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontap = (event) => {
   *  //some function here that happens on tap
   * }
   */
  ontap: null,
  /**
   * Property-based event handler for the `touchcancel` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchcancel = (event) => {
   *  //some function here that happens on touchcancel
   * }
   */
  ontouchcancel: null,
  /**
   * Property-based event handler for the `touchend` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchend = (event) => {
   *  //some function here that happens on touchend
   * }
   */
  ontouchend: null,
  /**
   * Property-based event handler for the `touchendoutside` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchendoutside = (event) => {
   *  //some function here that happens on touchendoutside
   * }
   */
  ontouchendoutside: null,
  /**
   * Property-based event handler for the `touchmove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchmove = (event) => {
   *  //some function here that happens on touchmove
   * }
   */
  ontouchmove: null,
  /**
   * Property-based event handler for the `globaltouchmove` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onglobaltouchmove = (event) => {
   *  //some function here that happens on globaltouchmove
   * }
   */
  onglobaltouchmove: null,
  /**
   * Property-based event handler for the `touchstart` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.ontouchstart = (event) => {
   *  //some function here that happens on touchstart
   * }
   */
  ontouchstart: null,
  /**
   * Property-based event handler for the `wheel` event.
   * @memberof scene.Container#
   * @default null
   * @example
   * this.onwheel = (event) => {
   *  //some function here that happens on wheel
   * }
   */
  onwheel: null,
  /**
   * Enable interaction events for the Container. Touch, pointer and mouse
   * @memberof scene.Container#
   */
  get interactive() {
    return this.eventMode === "dynamic" || this.eventMode === "static";
  },
  set interactive(value) {
    this.eventMode = value ? "static" : "passive";
  },
  /**
   * @ignore
   */
  _internalEventMode: void 0,
  /**
   * Enable interaction events for the Container. Touch, pointer and mouse.
   * There are 5 types of interaction settings:
   * - `'none'`: Ignores all interaction events, even on its children.
   * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.
   * Interactive children will still emit events.
   * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
   * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
   * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
   * allow for interaction when the mouse isn't moving
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.on('tap', (event) => {
   *     // Handle event
   * });
   * @memberof scene.Container#
   * @since 7.2.0
   */
  get eventMode() {
    return this._internalEventMode ?? _EventSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalEventMode = value;
  },
  /**
   * Determines if the container is interactive or not
   * @returns {boolean} Whether the container is interactive or not
   * @memberof scene.Container#
   * @since 7.2.0
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.eventMode = 'static';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'dynamic';
   * sprite.isInteractive(); // true
   *
   * sprite.eventMode = 'none';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'passive';
   * sprite.isInteractive(); // false
   *
   * sprite.eventMode = 'auto';
   * sprite.isInteractive(); // false
   */
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  /**
   * Determines if the children to the container can be clicked/touched
   * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
   * @memberof scene.Container#
   */
  interactiveChildren: true,
  /**
   * Interaction shape. Children will be hit first, then this shape will be checked.
   * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
   * @example
   * import { Rectangle, Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite(texture);
   * sprite.interactive = true;
   * sprite.hitArea = new Rectangle(0, 0, 100, 100);
   * @member {IHitArea}
   * @memberof scene.Container#
   */
  hitArea: null,
  /**
   * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
   * seeks to be compatible with the DOM's `addEventListener` with support for options.
   * @memberof scene.Container
   * @param type - The type of event to listen to.
   * @param listener - The listener callback or object.
   * @param options - Listener options, used for capture phase.
   * @example
   * // Tell the user whether they did a single, double, triple, or nth click.
   * button.addEventListener('click', {
   *     handleEvent(e): {
   *         let prefix;
   *
   *         switch (e.detail) {
   *             case 1: prefix = 'single'; break;
   *             case 2: prefix = 'double'; break;
   *             case 3: prefix = 'triple'; break;
   *             default: prefix = e.detail + 'th'; break;
   *         }
   *
   *         console.log('That was a ' + prefix + 'click');
   *     }
   * });
   *
   * // But skip the first click!
   * button.parent.addEventListener('click', function blockClickOnce(e) {
   *     e.stopImmediatePropagation();
   *     button.parent.removeEventListener('click', blockClickOnce, true);
   * }, {
   *     capture: true,
   * });
   */
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const signal = typeof options === "object" ? options.signal : void 0;
    const once = typeof options === "object" ? options.once === true : false;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
    const emitter = this;
    if (signal) {
      signal.addEventListener("abort", () => {
        emitter.off(type, listenerFn, context);
      });
    }
    if (once) {
      emitter.once(type, listenerFn, context);
    } else {
      emitter.on(type, listenerFn, context);
    }
  },
  /**
   * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
   * seeks to be compatible with the DOM's `removeEventListener` with support for options.
   * @memberof scene.Container
   * @param type - The type of event the listener is bound to.
   * @param listener - The listener callback or object.
   * @param options - The original listener options. This is required to deregister a capture phase listener.
   */
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context);
  },
  /**
   * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
   *
   * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
   * @memberof scene.Container
   * @param e - The event to dispatch.
   * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
   * @example
   * // Reuse a click event!
   * button.dispatchEvent(clickEvent);
   */
  dispatchEvent(e) {
    if (!(e instanceof _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_1__.FederatedEvent)) {
      throw new Error("Container cannot propagate events outside of the Federated Events API");
    }
    e.defaultPrevented = false;
    e.path = null;
    e.target = this;
    e.manager.dispatchEvent(e);
    return !e.defaultPrevented;
  }
};


//# sourceMappingURL=FederatedEventTarget.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FederatedMouseEvent: () => (/* binding */ FederatedMouseEvent)
/* harmony export */ });
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FederatedEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedEvent.mjs");



"use strict";
class FederatedMouseEvent extends _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_0__.FederatedEvent {
  constructor() {
    super(...arguments);
    /** The coordinates of the mouse event relative to the canvas. */
    this.client = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
    /** The movement in this pointer relative to the last `mousemove` event. */
    this.movement = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */
    this.offset = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
    /** The pointer coordinates in world space. */
    this.global = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
    /**
     * The pointer coordinates in the renderer's {@link Renderer.screen screen}. This has slightly
     * different semantics than native PointerEvent screenX/screenY.
     */
    this.screen = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
  }
  /** @readonly */
  get clientX() {
    return this.client.x;
  }
  /** @readonly */
  get clientY() {
    return this.client.y;
  }
  /**
   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
   * @readonly
   */
  get x() {
    return this.clientX;
  }
  /**
   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
   * @readonly
   */
  get y() {
    return this.clientY;
  }
  /** @readonly */
  get movementX() {
    return this.movement.x;
  }
  /** @readonly */
  get movementY() {
    return this.movement.y;
  }
  /** @readonly */
  get offsetX() {
    return this.offset.x;
  }
  /** @readonly */
  get offsetY() {
    return this.offset.y;
  }
  /** @readonly */
  get globalX() {
    return this.global.x;
  }
  /** @readonly */
  get globalY() {
    return this.global.y;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
   * @readonly
   */
  get screenX() {
    return this.screen.x;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
   * @readonly
   */
  get screenY() {
    return this.screen.y;
  }
  /**
   * This will return the local coordinates of the specified container for this InteractionData
   * @param {Container} container - The Container that you would like the local
   *  coords off
   * @param {PointData} point - A Point object in which to store the value, optional (otherwise
   *  will create a new point)
   * @param {PointData} globalPos - A Point object containing your custom global coords, optional
   *  (otherwise will use the current global coords)
   * @returns - A point containing the coordinates of the InteractionData position relative
   *  to the Container
   */
  getLocalPosition(container, point, globalPos) {
    return container.worldTransform.applyInverse(globalPos || this.global, point);
  }
  /**
   * Whether the modifier key was pressed when this event natively occurred.
   * @param key - The modifier key.
   */
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  /**
   * Not supported.
   * @param _typeArg
   * @param _canBubbleArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   * @param _screenXArg
   * @param _screenYArg
   * @param _clientXArg
   * @param _clientYArg
   * @param _ctrlKeyArg
   * @param _altKeyArg
   * @param _shiftKeyArg
   * @param _metaKeyArg
   * @param _buttonArg
   * @param _relatedTargetArg
   * @deprecated since 7.0.0
   */
  // eslint-disable-next-line max-params
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}


//# sourceMappingURL=FederatedMouseEvent.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FederatedPointerEvent: () => (/* binding */ FederatedPointerEvent)
/* harmony export */ });
/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FederatedMouseEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs");


"use strict";
class FederatedPointerEvent extends _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     */
    this.width = 0;
    /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     */
    this.height = 0;
    /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     */
    this.isPrimary = false;
  }
  // Only included for completeness for now
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  // Only included for completeness for now
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}


//# sourceMappingURL=FederatedPointerEvent.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FederatedWheelEvent: () => (/* binding */ FederatedWheelEvent)
/* harmony export */ });
/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FederatedMouseEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs");


"use strict";
class FederatedWheelEvent extends _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    /** Units specified in pixels. */
    this.DOM_DELTA_PIXEL = 0;
    /** Units specified in lines. */
    this.DOM_DELTA_LINE = 1;
    /** Units specified in pages. */
    this.DOM_DELTA_PAGE = 2;
  }
}
/** Units specified in pixels. */
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
/** Units specified in lines. */
FederatedWheelEvent.DOM_DELTA_LINE = 1;
/** Units specified in pages. */
FederatedWheelEvent.DOM_DELTA_PAGE = 2;


//# sourceMappingURL=FederatedWheelEvent.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/extensions/Extensions.mjs":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/extensions/Extensions.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtensionType: () => (/* binding */ ExtensionType),
/* harmony export */   extensions: () => (/* binding */ extensions),
/* harmony export */   normalizeExtensionPriority: () => (/* binding */ normalizeExtensionPriority)
/* harmony export */ });

var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Application"] = "application";
  ExtensionType2["WebGLPipes"] = "webgl-pipes";
  ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
  ExtensionType2["WebGLSystem"] = "webgl-system";
  ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
  ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
  ExtensionType2["WebGPUSystem"] = "webgpu-system";
  ExtensionType2["CanvasSystem"] = "canvas-system";
  ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
  ExtensionType2["CanvasPipes"] = "canvas-pipes";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  ExtensionType2["MaskEffect"] = "mask-effect";
  ExtensionType2["BlendMode"] = "blend-mode";
  ExtensionType2["TextureSource"] = "texture-source";
  ExtensionType2["Environment"] = "environment";
  ExtensionType2["ShapeBuilder"] = "shape-builder";
  ExtensionType2["Batcher"] = "batcher";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
const normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {extensions} For chaining.
   */
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    });
    return this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {extensions} For chaining.
   */
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type]) {
          queue[type] = queue[type] || [];
          queue[type]?.push(ext);
        } else {
          handlers[type]?.(ext);
        }
      });
    });
    return this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns {extensions} For chaining.
   */
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue = this._queue;
    if (queue[type]) {
      queue[type]?.forEach((ext) => onAdd(ext));
      delete queue[type];
    }
    return this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {extensions} For chaining.
   */
  handleByMap(type, map) {
    return this.handle(
      type,
      (extension) => {
        if (extension.name) {
          map[extension.name] = extension.ref;
        }
      },
      (extension) => {
        if (extension.name) {
          delete map[extension.name];
        }
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns {extensions} For chaining.
   */
  handleByNamedList(type, map, defaultPriority = -1) {
    return this.handle(
      type,
      (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index >= 0)
          return;
        map.push({ name: extension.name, value: extension.ref });
        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));
      },
      (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index !== -1) {
          map.splice(index, 1);
        }
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {extensions} For chaining.
   */
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(
      type,
      (extension) => {
        if (list.includes(extension.ref)) {
          return;
        }
        list.push(extension.ref);
        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));
      },
      (extension) => {
        const index = list.indexOf(extension.ref);
        if (index !== -1) {
          list.splice(index, 1);
        }
      }
    );
  },
  /**
   * Mixin the source object into the target object.
   * @param Target - The target object to mix into.
   * @param sources - The source(s) object to mix from
   */
  mixin(Target, ...sources) {
    for (const source of sources) {
      Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));
    }
  }
};


//# sourceMappingURL=Extensions.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/Filter.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/Filter.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Filter: () => (/* binding */ Filter)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");





"use strict";
const _Filter = class _Filter extends _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__.Shader {
  /**
   * @param options - The optional parameters of this filter.
   */
  constructor(options) {
    options = { ..._Filter.defaultOptions, ...options };
    super(options);
    /** If enabled is true the filter is applied, if false it will not. */
    this.enabled = true;
    /**
     * The gpu state the filter requires to render.
     * @internal
     * @ignore
     */
    this._state = _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_1__.State.for2d();
    this.blendMode = options.blendMode;
    this.padding = options.padding;
    if (typeof options.antialias === "boolean") {
      this.antialias = options.antialias ? "on" : "off";
    } else {
      this.antialias = options.antialias;
    }
    this.resolution = options.resolution;
    this.blendRequired = options.blendRequired;
    this.clipToViewport = options.clipToViewport;
    this.addResource("uTexture", 0, 1);
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  apply(filterManager, input, output, clearMode) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Get the blend mode of the filter.
   * @default "normal"
   */
  get blendMode() {
    return this._state.blendMode;
  }
  /** Sets the blend mode of the filter. */
  set blendMode(value) {
    this._state.blendMode = value;
  }
  /**
   * A short hand function to create a filter based of a vertex and fragment shader src.
   * @param options
   * @returns A shiny new PixiJS filter!
   */
  static from(options) {
    const { gpu, gl, ...rest } = options;
    let gpuProgram;
    let glProgram;
    if (gpu) {
      gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.GpuProgram.from(gpu);
    }
    if (gl) {
      glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__.GlProgram.from(gl);
    }
    return new _Filter({
      gpuProgram,
      glProgram,
      ...rest
    });
  }
};
/**
 * The default filter settings
 * @static
 */
_Filter.defaultOptions = {
  blendMode: "normal",
  resolution: 1,
  padding: 0,
  antialias: "off",
  blendRequired: false,
  clipToViewport: true
};
let Filter = _Filter;


//# sourceMappingURL=Filter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/FilterEffect.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/FilterEffect.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilterEffect: () => (/* binding */ FilterEffect)
/* harmony export */ });

class FilterEffect {
  constructor() {
    /** the pipe that knows how to handle this effect */
    this.pipe = "filter";
    /** the priority of this effect */
    this.priority = 1;
  }
  destroy() {
    for (let i = 0; i < this.filters.length; i++) {
      this.filters[i].destroy();
    }
    this.filters = null;
    this.filterArea = null;
  }
}


//# sourceMappingURL=FilterEffect.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/FilterPipe.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/FilterPipe.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilterPipe: () => (/* binding */ FilterPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class FilterPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  push(filterEffect, container, instructionSet) {
    const renderPipes = this._renderer.renderPipes;
    renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      canBundle: false,
      action: "pushFilter",
      container,
      filterEffect
    });
  }
  pop(_filterEffect, _container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: false
    });
  }
  execute(instruction) {
    if (instruction.action === "pushFilter") {
      this._renderer.filter.push(instruction);
    } else if (instruction.action === "popFilter") {
      this._renderer.filter.pop();
    }
  }
  destroy() {
    this._renderer = null;
  }
}
FilterPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasPipes
  ],
  name: "filter"
};


//# sourceMappingURL=FilterPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/FilterSystem.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/FilterSystem.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FilterSystem: () => (/* binding */ FilterSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rendering/renderers/gpu/shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rendering/renderers/shared/geometry/Geometry.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rendering/renderers/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../scene/container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _scene_container_bounds_getRenderableBounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scene/container/bounds/getRenderableBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");













"use strict";
const quadGeometry = new _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__.Geometry({
  attributes: {
    aPosition: {
      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      format: "float32x2",
      stride: 2 * 4,
      offset: 0
    }
  },
  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
});
class FilterSystem {
  constructor(renderer) {
    this._filterStackIndex = 0;
    this._filterStack = [];
    this._filterGlobalUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.UniformGroup({
      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
    });
    this._globalFilterBindGroup = new _rendering_renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.BindGroup({});
    this.renderer = renderer;
  }
  /**
   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
   * @readonly
   */
  get activeBackTexture() {
    return this._activeFilterData?.backTexture;
  }
  push(instruction) {
    const renderer = this.renderer;
    const filters = instruction.filterEffect.filters;
    if (!this._filterStack[this._filterStackIndex]) {
      this._filterStack[this._filterStackIndex] = this._getFilterData();
    }
    const filterData = this._filterStack[this._filterStackIndex];
    this._filterStackIndex++;
    if (filters.length === 0) {
      filterData.skip = true;
      return;
    }
    const bounds = filterData.bounds;
    if (instruction.renderables) {
      (0,_scene_container_bounds_getRenderableBounds_mjs__WEBPACK_IMPORTED_MODULE_3__.getGlobalRenderableBounds)(instruction.renderables, bounds);
    } else if (instruction.filterEffect.filterArea) {
      bounds.clear();
      bounds.addRect(instruction.filterEffect.filterArea);
      bounds.applyMatrix(instruction.container.worldTransform);
    } else {
      instruction.container.getFastGlobalBounds(true, bounds);
    }
    if (instruction.container) {
      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
      const filterFrameTransform = renderGroup.cacheToLocalTransform;
      if (filterFrameTransform) {
        bounds.applyMatrix(filterFrameTransform);
      }
    }
    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
    let resolution = Infinity;
    let padding = 0;
    let antialias = true;
    let blendRequired = false;
    let enabled = false;
    let clipToViewport = true;
    for (let i = 0; i < filters.length; i++) {
      const filter = filters[i];
      resolution = Math.min(resolution, filter.resolution === "inherit" ? colorTextureSource._resolution : filter.resolution);
      padding += filter.padding;
      if (filter.antialias === "off") {
        antialias = false;
      } else if (filter.antialias === "inherit") {
        antialias && (antialias = colorTextureSource.antialias);
      }
      if (!filter.clipToViewport) {
        clipToViewport = false;
      }
      const isCompatible = !!(filter.compatibleRenderers & renderer.type);
      if (!isCompatible) {
        enabled = false;
        break;
      }
      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__.warn)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
        enabled = false;
        break;
      }
      enabled = filter.enabled || enabled;
      blendRequired || (blendRequired = filter.blendRequired);
    }
    if (!enabled) {
      filterData.skip = true;
      return;
    }
    if (clipToViewport) {
      const viewPort = renderer.renderTarget.rootViewPort;
      const rootResolution = renderer.renderTarget.renderTarget.resolution;
      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
    }
    bounds.scale(resolution).ceil().scale(1 / resolution).pad(padding | 0);
    if (!bounds.isPositive) {
      filterData.skip = true;
      return;
    }
    filterData.skip = false;
    filterData.bounds = bounds;
    filterData.blendRequired = blendRequired;
    filterData.container = instruction.container;
    filterData.filterEffect = instruction.filterEffect;
    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
    filterData.inputTexture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__.TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      resolution,
      antialias
    );
    renderer.renderTarget.bind(filterData.inputTexture, true);
    renderer.globalUniforms.push({
      offset: bounds
    });
  }
  pop() {
    const renderer = this.renderer;
    this._filterStackIndex--;
    const filterData = this._filterStack[this._filterStackIndex];
    if (filterData.skip) {
      return;
    }
    this._activeFilterData = filterData;
    const inputTexture = filterData.inputTexture;
    const bounds = filterData.bounds;
    let backTexture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_6__.Texture.EMPTY;
    renderer.renderTarget.finishRenderPass();
    if (filterData.blendRequired) {
      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
    }
    filterData.backTexture = backTexture;
    const filters = filterData.filterEffect.filters;
    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
    this._globalFilterBindGroup.setResource(backTexture.source, 3);
    renderer.globalUniforms.pop();
    if (filters.length === 1) {
      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__.TexturePool.returnTexture(inputTexture);
    } else {
      let flip = filterData.inputTexture;
      let flop = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__.TexturePool.getOptimalTexture(
        bounds.width,
        bounds.height,
        flip.source._resolution,
        false
      );
      let i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        const filter = filters[i];
        filter.apply(this, flip, flop, true);
        const t = flip;
        flip = flop;
        flop = t;
      }
      filters[i].apply(this, flip, filterData.previousRenderSurface, false);
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__.TexturePool.returnTexture(flip);
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__.TexturePool.returnTexture(flop);
    }
    if (filterData.blendRequired) {
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__.TexturePool.returnTexture(backTexture);
    }
  }
  getBackTexture(lastRenderSurface, bounds, previousBounds) {
    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
    const backTexture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_5__.TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      backgroundResolution,
      false
    );
    let x = bounds.minX;
    let y = bounds.minY;
    if (previousBounds) {
      x -= previousBounds.minX;
      y -= previousBounds.minY;
    }
    x = Math.floor(x * backgroundResolution);
    y = Math.floor(y * backgroundResolution);
    const width = Math.ceil(bounds.width * backgroundResolution);
    const height = Math.ceil(bounds.height * backgroundResolution);
    this.renderer.renderTarget.copyToTexture(
      lastRenderSurface,
      backTexture,
      { x, y },
      { width, height },
      { x: 0, y: 0 }
    );
    return backTexture;
  }
  applyFilter(filter, input, output, clear) {
    const renderer = this.renderer;
    const filterData = this._filterStack[this._filterStackIndex];
    const bounds = filterData.bounds;
    const offset = _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_7__.Point.shared;
    const previousRenderSurface = filterData.previousRenderSurface;
    const isFinalTarget = previousRenderSurface === output;
    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
    let currentIndex = this._filterStackIndex - 1;
    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
      --currentIndex;
    }
    if (currentIndex > 0) {
      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
    }
    const filterUniforms = this._filterGlobalUniforms;
    const uniforms = filterUniforms.uniforms;
    const outputFrame = uniforms.uOutputFrame;
    const inputSize = uniforms.uInputSize;
    const inputPixel = uniforms.uInputPixel;
    const inputClamp = uniforms.uInputClamp;
    const globalFrame = uniforms.uGlobalFrame;
    const outputTexture = uniforms.uOutputTexture;
    if (isFinalTarget) {
      let lastIndex = this._filterStackIndex;
      while (lastIndex > 0) {
        lastIndex--;
        const filterData2 = this._filterStack[this._filterStackIndex - 1];
        if (!filterData2.skip) {
          offset.x = filterData2.bounds.minX;
          offset.y = filterData2.bounds.minY;
          break;
        }
      }
      outputFrame[0] = bounds.minX - offset.x;
      outputFrame[1] = bounds.minY - offset.y;
    } else {
      outputFrame[0] = 0;
      outputFrame[1] = 0;
    }
    outputFrame[2] = input.frame.width;
    outputFrame[3] = input.frame.height;
    inputSize[0] = input.source.width;
    inputSize[1] = input.source.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = input.source.pixelWidth;
    inputPixel[1] = input.source.pixelHeight;
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
    globalFrame[0] = offset.x * resolution;
    globalFrame[1] = offset.y * resolution;
    globalFrame[2] = rootTexture.source.width * resolution;
    globalFrame[3] = rootTexture.source.height * resolution;
    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
    renderer.renderTarget.bind(output, !!clear);
    if (output instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_6__.Texture) {
      outputTexture[0] = output.frame.width;
      outputTexture[1] = output.frame.height;
    } else {
      outputTexture[0] = renderTarget.width;
      outputTexture[1] = renderTarget.height;
    }
    outputTexture[2] = renderTarget.isRoot ? -1 : 1;
    filterUniforms.update();
    if (renderer.renderPipes.uniformBatch) {
      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
      this._globalFilterBindGroup.setResource(batchUniforms, 0);
    } else {
      this._globalFilterBindGroup.setResource(filterUniforms, 0);
    }
    this._globalFilterBindGroup.setResource(input.source, 1);
    this._globalFilterBindGroup.setResource(input.source.style, 2);
    filter.groups[0] = this._globalFilterBindGroup;
    renderer.encoder.draw({
      geometry: quadGeometry,
      shader: filter,
      state: filter._state,
      topology: "triangle-list"
    });
    if (renderer.type === _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_8__.RendererType.WEBGL) {
      renderer.renderTarget.finishRenderPass();
    }
  }
  _getFilterData() {
    return {
      skip: false,
      inputTexture: null,
      bounds: new _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_9__.Bounds(),
      container: null,
      filterEffect: null,
      blendRequired: false,
      previousRenderSurface: null
    };
  }
  /**
   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
   *
   * Use `outputMatrix * vTextureCoord` in the shader.
   * @param outputMatrix - The matrix to output to.
   * @param {Sprite} sprite - The sprite to map to.
   * @returns The mapped matrix.
   */
  calculateSpriteMatrix(outputMatrix, sprite) {
    const data = this._activeFilterData;
    const mappedMatrix = outputMatrix.set(
      data.inputTexture._source.width,
      0,
      0,
      data.inputTexture._source.height,
      data.bounds.minX,
      data.bounds.minY
    );
    const worldTransform = sprite.worldTransform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_10__.Matrix.shared);
    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
    if (renderGroup && renderGroup.cacheToLocalTransform) {
      worldTransform.prepend(renderGroup.cacheToLocalTransform);
    }
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(
      1 / sprite.texture.frame.width,
      1 / sprite.texture.frame.height
    );
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
}
/** @ignore */
FilterSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__.ExtensionType.WebGPUSystem
  ],
  name: "filter"
};


//# sourceMappingURL=FilterSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BlendModeFilter: () => (/* binding */ BlendModeFilter)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _blend_template_frag_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./blend-template.frag.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs");
/* harmony import */ var _blend_template_vert_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./blend-template.vert.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs");
/* harmony import */ var _blend_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blend-template.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs");









"use strict";
class BlendModeFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(options) {
    const gpuOptions = options.gpu;
    const gpuSource = compileBlendModeShader({ source: _blend_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], ...gpuOptions });
    const gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.GpuProgram.from({
      vertex: {
        source: gpuSource,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: gpuSource,
        entryPoint: "mainFragment"
      }
    });
    const glOptions = options.gl;
    const glSource = compileBlendModeShader({ source: _blend_template_frag_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], ...glOptions });
    const glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.GlProgram.from({
      vertex: _blend_template_vert_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
      fragment: glSource
    });
    const uniformGroup = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__.UniformGroup({
      uBlend: {
        value: 1,
        type: "f32"
      }
    });
    super({
      gpuProgram,
      glProgram,
      blendRequired: true,
      resources: {
        blendUniforms: uniformGroup,
        uBackTexture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__.Texture.EMPTY
      }
    });
  }
}
function compileBlendModeShader(options) {
  const { source, functions, main } = options;
  return source.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
}


//# sourceMappingURL=BlendModeFilter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ blendTemplateFrag)
/* harmony export */ });
var blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uBlend;\n\nuniform sampler2D uTexture;\nuniform sampler2D uBackTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(uBackTexture, vTextureCoord);\n    vec4 front = texture(uTexture, vTextureCoord);\n    float blendedAlpha = front.a + back.a * (1.0 - front.a);\n    \n    {MAIN}\n}\n";


//# sourceMappingURL=blend-template.frag.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ blendTemplateVert)
/* harmony export */ });
var blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";


//# sourceMappingURL=blend-template.vert.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ blendTemplate)
/* harmony export */ });
var blendTemplate = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(0) @binding(3) var uBackTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(uBackTexture, uSampler, uv);\n   var front = textureSample(uTexture, uSampler, uv);\n   var blendedAlpha = front.a + back.a * (1.0 - front.a);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";


//# sourceMappingURL=blend-template.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hslgl: () => (/* binding */ hslgl)
/* harmony export */ });

const hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;


//# sourceMappingURL=GLhls.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hslgpu: () => (/* binding */ hslgpu)
/* harmony export */ });

const hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;


//# sourceMappingURL=GPUhls.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hsl)
/* harmony export */ });
var hsl = "fn getLuminosity(c: vec3<f32>) -> f32 {\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\n  let d: f32 = lum - getLuminosity(c);\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\n\n  // clip back into legal range\n  let newLum: f32 = getLuminosity(newColor);\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\n\n  let t1: f32 = newLum / (newLum - cMin);\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\n\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\n\n  return finalColor;\n}\n\nfn getSaturation(c: vec3<f32>) -> f32 {\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n}\n\n// Set saturation if color components are sorted in ascending order.\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\n  var result: vec3<f32>;\n  if (cSorted.z > cSorted.x) {\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\n    result = vec3<f32>(0.0, newY, s);\n  } else {\n    result = vec3<f32>(0.0, 0.0, 0.0);\n  }\n  return vec3<f32>(result.x, result.y, result.z);\n}\n\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\n    var result: vec3<f32> = c;\n\n    if (c.r <= c.g && c.r <= c.b) {\n        if (c.g <= c.b) {\n            result = setSaturationMinMidMax(result, s);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.r, temp.b, temp.g);\n        }\n    } else if (c.g <= c.r && c.g <= c.b) {\n        if (c.r <= c.b) {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.r, temp.b);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.b, temp.r);\n        }\n    } else {\n        if (c.r <= c.g) {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.r, temp.g);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.g, temp.r);\n        }\n    }\n\n    return result;\n}";


//# sourceMappingURL=hsl.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlphaFilter: () => (/* binding */ AlphaFilter)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaultFilter.vert.mjs */ "./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs");
/* harmony import */ var _alpha_frag_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./alpha.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs");
/* harmony import */ var _alpha_wgsl_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./alpha.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs");








"use strict";
const _AlphaFilter = class _AlphaFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(options) {
    options = { ..._AlphaFilter.defaultOptions, ...options };
    const gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuProgram.from({
      vertex: {
        source: _alpha_wgsl_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        entryPoint: "mainVertex"
      },
      fragment: {
        source: _alpha_wgsl_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        entryPoint: "mainFragment"
      }
    });
    const glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__.GlProgram.from({
      vertex: _defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
      fragment: _alpha_frag_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
      name: "alpha-filter"
    });
    const { alpha, ...rest } = options;
    const alphaUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__.UniformGroup({
      uAlpha: { value: alpha, type: "f32" }
    });
    super({
      ...rest,
      gpuProgram,
      glProgram,
      resources: {
        alphaUniforms
      }
    });
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.resources.alphaUniforms.uniforms.uAlpha;
  }
  set alpha(value) {
    this.resources.alphaUniforms.uniforms.uAlpha = value;
  }
};
/** Default filter options */
_AlphaFilter.defaultOptions = {
  /** Amount of alpha from 0 to 1, where 0 is transparent */
  alpha: 1
};
let AlphaFilter = _AlphaFilter;


//# sourceMappingURL=AlphaFilter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fragment)
/* harmony export */ });
var fragment = "\nin vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform float uAlpha;\nuniform sampler2D uTexture;\n\nvoid main()\n{\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\n}\n";


//# sourceMappingURL=alpha.frag.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ source)
/* harmony export */ });
var source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n \n    var sample = textureSample(uTexture, uSampler, uv);\n    \n    return sample * alphaUniforms.uAlpha;\n}";


//# sourceMappingURL=alpha.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BlurFilter: () => (/* binding */ BlurFilter)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/renderers/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BlurFilterPass.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs");






"use strict";
class BlurFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number") {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
      options = { strength: options };
      if (args[1] !== void 0)
        options.quality = args[1];
      if (args[2] !== void 0)
        options.resolution = args[2] || "inherit";
      if (args[3] !== void 0)
        options.kernelSize = args[3];
    }
    options = { ..._BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_2__.BlurFilterPass.defaultOptions, ...options };
    const { strength, strengthX, strengthY, quality, ...rest } = options;
    super({
      ...rest,
      compatibleRenderers: _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_3__.RendererType.BOTH,
      resources: {}
    });
    this._repeatEdgePixels = false;
    this.blurXFilter = new _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_2__.BlurFilterPass({ horizontal: true, ...options });
    this.blurYFilter = new _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_2__.BlurFilterPass({ horizontal: false, ...options });
    this.quality = quality;
    this.strengthX = strengthX ?? strength;
    this.strengthY = strengthY ?? strength;
    this.repeatEdgePixels = false;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const tempTexture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_4__.TexturePool.getSameSizeTexture(input);
      this.blurXFilter.blendMode = "normal";
      this.blurXFilter.apply(filterManager, input, tempTexture, true);
      this.blurYFilter.blendMode = this.blendMode;
      this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_4__.TexturePool.returnTexture(tempTexture);
    } else if (yStrength) {
      this.blurYFilter.blendMode = this.blendMode;
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.blendMode = this.blendMode;
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
    }
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 8
   */
  get strength() {
    if (this.strengthX !== this.strengthY) {
      throw new Error("BlurFilter's strengthX and strengthY are different");
    }
    return this.strengthX;
  }
  set strength(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value;
    this.updatePadding();
  }
  /**
   * Sets the number of passes for blur. More passes means higher quality bluring.
   * @default 1
   */
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  /**
   * Sets the strength of horizontal blur
   * @default 8
   */
  get strengthX() {
    return this.blurXFilter.blur;
  }
  set strengthX(value) {
    this.blurXFilter.blur = value;
    this.updatePadding();
  }
  /**
   * Sets the strength of the vertical blur
   * @default 8
   */
  get strengthY() {
    return this.blurYFilter.blur;
  }
  set strengthY(value) {
    this.blurYFilter.blur = value;
    this.updatePadding();
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strength
   */
  get blur() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
    return this.strength;
  }
  set blur(value) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
    this.strength = value;
  }
  /**
   * Sets the strength of the blurX property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthX
   */
  get blurX() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
    return this.strengthX;
  }
  set blurX(value) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
    this.strengthX = value;
  }
  /**
   * Sets the strength of the blurY property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthY
   */
  get blurY() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
    return this.strengthY;
  }
  set blurY(value) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
    this.strengthY = value;
  }
  /**
   * If set to true the edge of the target will be clamped
   * @default false
   */
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value;
    this.updatePadding();
  }
}
/** Default blur filter options */
BlurFilter.defaultOptions = {
  /** The strength of the blur filter. */
  strength: 8,
  /** The quality of the blur filter. */
  quality: 4,
  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
  kernelSize: 5
};


//# sourceMappingURL=BlurFilter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BlurFilterPass: () => (/* binding */ BlurFilterPass)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _gl_generateBlurGlProgram_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gl/generateBlurGlProgram.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs");
/* harmony import */ var _gpu_generateBlurProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gpu/generateBlurProgram.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs");






"use strict";
const _BlurFilterPass = class _BlurFilterPass extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  /**
   * @param options
   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
   * @param options.strength - The strength of the blur filter.
   * @param options.quality - The quality of the blur filter.
   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(options) {
    options = { ..._BlurFilterPass.defaultOptions, ...options };
    const glProgram = (0,_gl_generateBlurGlProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.generateBlurGlProgram)(options.horizontal, options.kernelSize);
    const gpuProgram = (0,_gpu_generateBlurProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.generateBlurProgram)(options.horizontal, options.kernelSize);
    super({
      glProgram,
      gpuProgram,
      resources: {
        blurUniforms: {
          uStrength: { value: 0, type: "f32" }
        }
      },
      ...options
    });
    this.horizontal = options.horizontal;
    this._quality = 0;
    this.quality = options.quality;
    this.blur = options.strength;
    this._uniforms = this.resources.blurUniforms.uniforms;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(filterManager, input, output, clearMode) {
    this._uniforms.uStrength = this.strength / this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const tempTexture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_3__.TexturePool.getSameSizeTexture(input);
      let flip = input;
      let flop = tempTexture;
      this._state.blend = false;
      const shouldClear = filterManager.renderer.type === _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_4__.RendererType.WEBGPU;
      for (let i = 0; i < this.passes - 1; i++) {
        filterManager.applyFilter(this, flip, flop, i === 0 ? true : shouldClear);
        const temp = flop;
        flop = flip;
        flip = temp;
      }
      this._state.blend = true;
      filterManager.applyFilter(this, flip, output, clearMode);
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_3__.TexturePool.returnTexture(tempTexture);
    }
  }
  /**
   * Sets the strength of both the blur.
   * @default 16
   */
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2;
    this.strength = value;
  }
  /**
   * Sets the quality of the blur by modifying the number of passes. More passes means higher
   * quality blurring but the lower the performance.
   * @default 4
   */
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.passes = value;
  }
};
/** Default blur filter pass options */
_BlurFilterPass.defaultOptions = {
  /** The strength of the blur filter. */
  strength: 8,
  /** The quality of the blur filter. */
  quality: 4,
  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
  kernelSize: 5
};
let BlurFilterPass = _BlurFilterPass;


//# sourceMappingURL=BlurFilterPass.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/const.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/const.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GAUSSIAN_VALUES: () => (/* binding */ GAUSSIAN_VALUES)
/* harmony export */ });

const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateBlurFragSource: () => (/* binding */ generateBlurFragSource)
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/const.mjs");


"use strict";
const fragTemplate = [
  "in vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uTexture;",
  "out vec4 finalColor;",
  "void main(void)",
  "{",
  "    finalColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate;
  let blurLoop = "";
  const template = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}


//# sourceMappingURL=generateBlurFragSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateBlurGlProgram: () => (/* binding */ generateBlurGlProgram)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _generateBlurFragSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateBlurFragSource.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs");
/* harmony import */ var _generateBlurVertSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generateBlurVertSource.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs");




"use strict";
function generateBlurGlProgram(horizontal, kernelSize) {
  const vertex = (0,_generateBlurVertSource_mjs__WEBPACK_IMPORTED_MODULE_0__.generateBlurVertSource)(kernelSize, horizontal);
  const fragment = (0,_generateBlurFragSource_mjs__WEBPACK_IMPORTED_MODULE_1__.generateBlurFragSource)(kernelSize);
  return _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.GlProgram.from({
    vertex,
    fragment,
    name: `blur-${horizontal ? "horizontal" : "vertical"}-pass-filter`
  });
}


//# sourceMappingURL=generateBlurGlProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateBlurVertSource: () => (/* binding */ generateBlurVertSource)
/* harmony export */ });

const vertTemplate = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
  }
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  vertSource = vertSource.replace("%dimension%", x ? "z" : "w");
  return vertSource;
}


//# sourceMappingURL=generateBlurVertSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ source)
/* harmony export */ });
var source = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}";


//# sourceMappingURL=blur-template.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateBlurProgram: () => (/* binding */ generateBlurProgram)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/const.mjs");
/* harmony import */ var _blur_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blur-template.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs");




"use strict";
function generateBlurProgram(horizontal, kernelSize) {
  const kernel = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  const blurStructSource = [];
  const blurOutSource = [];
  const blurSamplingSource = [];
  for (let i = 0; i < kernelSize; i++) {
    blurStructSource[i] = `@location(${i}) offset${i}: vec2<f32>,`;
    if (horizontal) {
      blurOutSource[i] = `filteredCord + vec2(${i - halfLength + 1} * pixelStrength, 0.0),`;
    } else {
      blurOutSource[i] = `filteredCord + vec2(0.0, ${i - halfLength + 1} * pixelStrength),`;
    }
    const kernelIndex = i < halfLength ? i : kernelSize - i - 1;
    const kernelValue = kernel[kernelIndex].toString();
    blurSamplingSource[i] = `finalColor += textureSample(uTexture, uSampler, offset${i}) * ${kernelValue};`;
  }
  const blurStruct = blurStructSource.join("\n");
  const blurOut = blurOutSource.join("\n");
  const blurSampling = blurSamplingSource.join("\n");
  const finalSource = _blur_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].replace("%blur-struct%", blurStruct).replace("%blur-vertex-out%", blurOut).replace("%blur-fragment-in%", blurStruct).replace("%blur-sampling%", blurSampling).replace("%dimension%", horizontal ? "z" : "w");
  return _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.GpuProgram.from({
    vertex: {
      source: finalSource,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: finalSource,
      entryPoint: "mainFragment"
    }
  });
}


//# sourceMappingURL=generateBlurProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorMatrixFilter: () => (/* binding */ ColorMatrixFilter)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../defaultFilter.vert.mjs */ "./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs");
/* harmony import */ var _colorMatrixFilter_frag_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorMatrixFilter.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs");
/* harmony import */ var _colorMatrixFilter_wgsl_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorMatrixFilter.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs");









"use strict";
class ColorMatrixFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(options = {}) {
    const colorMatrixUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.UniformGroup({
      uColorMatrix: {
        value: [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        type: "f32",
        size: 20
      },
      uAlpha: {
        value: 1,
        type: "f32"
      }
    });
    const gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.GpuProgram.from({
      vertex: {
        source: _colorMatrixFilter_wgsl_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
        entryPoint: "mainVertex"
      },
      fragment: {
        source: _colorMatrixFilter_wgsl_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
        entryPoint: "mainFragment"
      }
    });
    const glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.GlProgram.from({
      vertex: _defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
      fragment: _colorMatrixFilter_frag_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
      name: "color-matrix-filter"
    });
    super({
      ...options,
      gpuProgram,
      glProgram,
      resources: {
        colorMatrixUniforms
      }
    });
    this.alpha = 1;
  }
  /**
   * Transforms current matrix and set the new one
   * @param {number[]} matrix - 5x4 matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  _loadMatrix(matrix, multiply = false) {
    let newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.matrix, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;
    this.resources.colorMatrixUniforms.update();
  }
  /**
   * Multiplies two mat5's
   * @private
   * @param out - 5x4 matrix the receiving matrix
   * @param a - 5x4 matrix the first operand
   * @param b - 5x4 matrix the second operand
   * @returns {number[]} 5x4 matrix
   */
  _multiply(out, a, b) {
    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
    return out;
  }
  /**
   * Create a Float32 Array and normalize the offset component to 0-1
   * @param {number[]} matrix - 5x4 matrix
   * @returns {number[]} 5x4 matrix with all values between 0-1
   */
  _colorMatrix(matrix) {
    const m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;
    return m;
  }
  /**
   * Adjusts brightness
   * @param b - value of the brightness (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  brightness(b, multiply) {
    const matrix = [
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Sets each channel on the diagonal of the color matrix.
   * This can be used to achieve a tinting effect on Containers similar to the tint field of some
   * display objects like Sprite, Text, Graphics, and Mesh.
   * @param color - Color of the tint. This is a hex value.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  tint(color, multiply) {
    const [r, g, b] = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_7__.Color.shared.setValue(color).toArray();
    const matrix = [
      r,
      0,
      0,
      0,
      0,
      0,
      g,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the matrices in grey scales
   * @param scale - value of the grey (0-1, where 0 is black)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * for our american friends!
   * @param scale
   * @param multiply
   */
  grayscale(scale, multiply) {
    this.greyscale(scale, multiply);
  }
  /**
   * Set the black and white matrice.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the hue property of the color
   * @param rotation - in degrees
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w = 1 / 3;
    const sqrW = sqrt(w);
    const a00 = cosR + (1 - cosR) * w;
    const a01 = w * (1 - cosR) - sqrW * sinR;
    const a02 = w * (1 - cosR) + sqrW * sinR;
    const a10 = w * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w * (1 - cosR);
    const a12 = w * (1 - cosR) - sqrW * sinR;
    const a20 = w * (1 - cosR) - sqrW * sinR;
    const a21 = w * (1 - cosR) + sqrW * sinR;
    const a22 = cosR + w * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the contrast matrix, increase the separation between dark and bright
   * Increase contrast : shadows darker and highlights brighter
   * Decrease contrast : bring the shadows up and the highlights down
   * @param amount - value of the contrast (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  contrast(amount, multiply) {
    const v = (amount || 0) + 1;
    const o = -0.5 * (v - 1);
    const matrix = [
      v,
      0,
      0,
      0,
      o,
      0,
      v,
      0,
      0,
      o,
      0,
      0,
      v,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Set the saturation matrix, increase the separation between colors
   * Increase saturation : increase contrast, brightness, and sharpness
   * @param amount - The saturation amount (0-1)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  saturate(amount = 0, multiply) {
    const x = amount * 2 / 3 + 1;
    const y = (x - 1) * -0.5;
    const matrix = [
      x,
      y,
      y,
      0,
      0,
      y,
      x,
      y,
      0,
      0,
      y,
      y,
      x,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /** Desaturate image (remove color) Call the saturate function */
  desaturate() {
    this.saturate(-1);
  }
  /**
   * Negative image (inverse of classic rgb matrix)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Sepia image
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Polaroid filter
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Filter who transforms : Red -> Blue and Blue -> Red
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Brown delicious browni filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Vintage filter (thanks Dominic Szablewski)
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * We don't know exactly what it does, kind of gradient map, but funny to play with!
   * @param desaturation - Tone values.
   * @param toned - Tone values.
   * @param lightColor - Tone values, example: `0xFFE580`
   * @param darkColor - Tone values, example: `0xFFE580`
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation || (desaturation = 0.2);
    toned || (toned = 0.15);
    lightColor || (lightColor = 16770432);
    darkColor || (darkColor = 3375104);
    const temp = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_7__.Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Night effect
   * @param intensity - The intensity of the night effect.
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  night(intensity, multiply) {
    intensity || (intensity = 0.1);
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * Predator effect
   *
   * Erase the current matrix by setting a new independent one
   * @param amount - how much the predator feels his future victim
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  predator(amount, multiply) {
    const matrix = [
      // row 1
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      // row 2
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      // row 3
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      // row 4
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /**
   * LSD effect
   *
   * Multiply the current matrix
   * @param multiply - if true, current matrix and matrix are multiplied. If false,
   *  just set the current matrix with @param matrix
   */
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  /** Erase the current matrix by setting the default one. */
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  /**
   * The matrix of the color matrix filter
   * @member {number[]}
   * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
   */
  get matrix() {
    return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;
  }
  set matrix(value) {
    this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;
  }
  /**
   * The opacity value to use when mixing the original and resultant colors.
   *
   * When the value is 0, the original color is used without modification.
   * When the value is 1, the result color is used.
   * When in the range (0, 1) the color is interpolated between the original and result by this amount.
   * @default 1
   */
  get alpha() {
    return this.resources.colorMatrixUniforms.uniforms.uAlpha;
  }
  set alpha(value) {
    this.resources.colorMatrixUniforms.uniforms.uAlpha = value;
  }
}


//# sourceMappingURL=ColorMatrixFilter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fragment)
/* harmony export */ });
var fragment = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    if (uAlpha == 0.0) {\n        finalColor = color;\n        return;\n    }\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * color.r);\n        result.r += (uColorMatrix[1] * color.g);\n        result.r += (uColorMatrix[2] * color.b);\n        result.r += (uColorMatrix[3] * color.a);\n        result.r += uColorMatrix[4];\n\n    result.g = (uColorMatrix[5] * color.r);\n        result.g += (uColorMatrix[6] * color.g);\n        result.g += (uColorMatrix[7] * color.b);\n        result.g += (uColorMatrix[8] * color.a);\n        result.g += uColorMatrix[9];\n\n    result.b = (uColorMatrix[10] * color.r);\n       result.b += (uColorMatrix[11] * color.g);\n       result.b += (uColorMatrix[12] * color.b);\n       result.b += (uColorMatrix[13] * color.a);\n       result.b += uColorMatrix[14];\n\n    result.a = (uColorMatrix[15] * color.r);\n       result.a += (uColorMatrix[16] * color.g);\n       result.a += (uColorMatrix[17] * color.b);\n       result.a += (uColorMatrix[18] * color.a);\n       result.a += uColorMatrix[19];\n\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    finalColor = vec4(rgb, result.a);\n}\n";


//# sourceMappingURL=colorMatrixFilter.frag.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ source)
/* harmony export */ });
var source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array<vec4<f32>, 5>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n  \nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n  var c = textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha == 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.r /= c.a;\n      c.g /= c.a;\n      c.b /= c.a;\n    }\n\n    var cm = colorMatrixUniforms.uColorMatrix;\n\n\n    var result = vec4<f32>(0.);\n\n    result.r = (cm[0][0] * c.r);\n    result.r += (cm[0][1] * c.g);\n    result.r += (cm[0][2] * c.b);\n    result.r += (cm[0][3] * c.a);\n    result.r += cm[1][0];\n\n    result.g = (cm[1][1] * c.r);\n    result.g += (cm[1][2] * c.g);\n    result.g += (cm[1][3] * c.b);\n    result.g += (cm[2][0] * c.a);\n    result.g += cm[2][1];\n\n    result.b = (cm[2][2] * c.r);\n    result.b += (cm[2][3] * c.g);\n    result.b += (cm[3][0] * c.b);\n    result.b += (cm[3][1] * c.a);\n    result.b += cm[3][2];\n\n    result.a = (cm[3][3] * c.r);\n    result.a += (cm[4][0] * c.g);\n    result.a += (cm[4][1] * c.b);\n    result.a += (cm[4][2] * c.a);\n    result.a += cm[4][3];\n\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *= result.a;\n    rgb.g *= result.a;\n    rgb.b *= result.a;\n\n    return vec4(rgb, result.a);\n}";


//# sourceMappingURL=colorMatrixFilter.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vertex)
/* harmony export */ });
var vertex = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";


//# sourceMappingURL=defaultFilter.vert.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DisplacementFilter: () => (/* binding */ DisplacementFilter)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/sprite/Sprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _displacement_frag_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./displacement.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs");
/* harmony import */ var _displacement_vert_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./displacement.vert.mjs */ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs");
/* harmony import */ var _displacement_wgsl_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./displacement.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs");












"use strict";
class DisplacementFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(...args) {
    let options = args[0];
    if (options instanceof _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_1__.Sprite) {
      if (args[1]) {
        (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "DisplacementFilter now uses options object instead of params. {sprite, scale}");
      }
      options = { sprite: options, scale: args[1] };
    }
    const { sprite, scale: scaleOption, ...rest } = options;
    let scale = scaleOption ?? 20;
    if (typeof scale === "number") {
      scale = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(scale, scale);
    }
    const filterUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_4__.UniformGroup({
      uFilterMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__.Matrix(), type: "mat3x3<f32>" },
      uScale: { value: scale, type: "vec2<f32>" },
      uRotation: { value: new Float32Array([0, 0, 0, 0]), type: "mat2x2<f32>" }
    });
    const glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_6__.GlProgram.from({
      vertex: _displacement_vert_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
      fragment: _displacement_frag_mjs__WEBPACK_IMPORTED_MODULE_8__["default"],
      name: "displacement-filter"
    });
    const gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_9__.GpuProgram.from({
      vertex: {
        source: _displacement_wgsl_mjs__WEBPACK_IMPORTED_MODULE_10__["default"],
        entryPoint: "mainVertex"
      },
      fragment: {
        source: _displacement_wgsl_mjs__WEBPACK_IMPORTED_MODULE_10__["default"],
        entryPoint: "mainFragment"
      }
    });
    const textureSource = sprite.texture.source;
    super({
      ...rest,
      gpuProgram,
      glProgram,
      resources: {
        filterUniforms,
        uMapTexture: textureSource,
        uMapSampler: textureSource.style
      }
    });
    this._sprite = options.sprite;
    this._sprite.renderable = false;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - clearMode.
   */
  apply(filterManager, input, output, clearMode) {
    const uniforms = this.resources.filterUniforms.uniforms;
    filterManager.calculateSpriteMatrix(
      uniforms.uFilterMatrix,
      this._sprite
    );
    const wt = this._sprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      uniforms.uRotation[0] = wt.a / lenX;
      uniforms.uRotation[1] = wt.b / lenX;
      uniforms.uRotation[2] = wt.c / lenY;
      uniforms.uRotation[3] = wt.d / lenY;
    }
    this.resources.uMapTexture = this._sprite.texture.source;
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /** scaleX, scaleY for displacements */
  get scale() {
    return this.resources.filterUniforms.uniforms.uScale;
  }
}


//# sourceMappingURL=DisplacementFilter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fragment)
/* harmony export */ });
var fragment = "\nin vec2 vTextureCoord;\nin vec2 vFilterUv;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\n\nuniform vec4 uInputClamp;\nuniform highp vec4 uInputSize;\nuniform mat2 uRotation;\nuniform vec2 uScale;\n\nvoid main()\n{\n    vec4 map = texture(uMapTexture, vFilterUv);\n    \n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \n\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\n}\n";


//# sourceMappingURL=displacement.frag.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vertex)
/* harmony export */ });
var vertex = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterUv;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( void )\n{\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\n}\n\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterUv = getFilterCoord();\n}\n";


//# sourceMappingURL=displacement.vert.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ source)
/* harmony export */ });
var source = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct DisplacementUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uScale:vec2<f32>,\n  uRotation:mat2x2<f32>\n};\n\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\n\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \n   \n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n}";


//# sourceMappingURL=displacement.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoiseFilter: () => (/* binding */ NoiseFilter)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaultFilter.vert.mjs */ "./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs");
/* harmony import */ var _noise_frag_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./noise.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs");
/* harmony import */ var _noise_wgsl_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noise.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs");








"use strict";
const _NoiseFilter = class _NoiseFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  /**
   * @param options - The options of the noise filter.
   */
  constructor(options = {}) {
    options = { ..._NoiseFilter.defaultOptions, ...options };
    const gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuProgram.from({
      vertex: {
        source: _noise_wgsl_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        entryPoint: "mainVertex"
      },
      fragment: {
        source: _noise_wgsl_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        entryPoint: "mainFragment"
      }
    });
    const glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__.GlProgram.from({
      vertex: _defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
      fragment: _noise_frag_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
      name: "noise-filter"
    });
    const { noise, seed, ...rest } = options;
    super({
      ...rest,
      gpuProgram,
      glProgram,
      resources: {
        noiseUniforms: new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__.UniformGroup({
          uNoise: { value: 1, type: "f32" },
          uSeed: { value: 1, type: "f32" }
        })
      }
    });
    this.noise = noise;
    this.seed = seed ?? Math.random();
  }
  /**
   * The amount of noise to apply, this value should be in the range (0, 1].
   * @default 0.5
   */
  get noise() {
    return this.resources.noiseUniforms.uniforms.uNoise;
  }
  set noise(value) {
    this.resources.noiseUniforms.uniforms.uNoise = value;
  }
  /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
  get seed() {
    return this.resources.noiseUniforms.uniforms.uSeed;
  }
  set seed(value) {
    this.resources.noiseUniforms.uniforms.uSeed = value;
  }
};
_NoiseFilter.defaultOptions = {
  noise: 0.5
};
let NoiseFilter = _NoiseFilter;


//# sourceMappingURL=NoiseFilter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fragment)
/* harmony export */ });
var fragment = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) *  uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";


//# sourceMappingURL=noise.frag.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ source)
/* harmony export */ });
var source = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct NoiseUniforms {\n  uNoise:f32,\n  uSeed:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\nfn rand(co:vec2<f32>) -> f32\n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\n  \n    \n    var sample = textureSample(uTexture, uSampler, uv);\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\n  \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (sample.a > 0.0) {\n      sample.r /= sample.a;\n      sample.g /= sample.a;\n      sample.b /= sample.a;\n    }\n\n    sample.r += diff;\n    sample.g += diff;\n    sample.b += diff;\n\n    // Premultiply alpha again.\n    sample.r *= sample.a;\n    sample.g *= sample.a;\n    sample.b *= sample.a;\n    \n    return sample;\n}";


//# sourceMappingURL=noise.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MaskFilter: () => (/* binding */ MaskFilter)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TextureMatrix.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _mask_frag_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mask.frag.mjs */ "./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs");
/* harmony import */ var _mask_vert_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mask.vert.mjs */ "./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs");
/* harmony import */ var _mask_wgsl_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mask.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs");










"use strict";
class MaskFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(options) {
    const { sprite, ...rest } = options;
    const textureMatrix = new _rendering_renderers_shared_texture_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureMatrix(sprite.texture);
    const filterUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.UniformGroup({
      uFilterMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__.Matrix(), type: "mat3x3<f32>" },
      uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
      uAlpha: { value: 1, type: "f32" },
      uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
    });
    const gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.GpuProgram.from({
      vertex: {
        source: _mask_wgsl_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
        entryPoint: "mainVertex"
      },
      fragment: {
        source: _mask_wgsl_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
        entryPoint: "mainFragment"
      }
    });
    const glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_6__.GlProgram.from({
      vertex: _mask_vert_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
      fragment: _mask_frag_mjs__WEBPACK_IMPORTED_MODULE_8__["default"],
      name: "mask-filter"
    });
    super({
      ...rest,
      gpuProgram,
      glProgram,
      resources: {
        filterUniforms,
        uMaskTexture: sprite.texture.source
      }
    });
    this.sprite = sprite;
    this._textureMatrix = textureMatrix;
  }
  set inverse(value) {
    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
  }
  get inverse() {
    return this.resources.filterUniforms.uniforms.uInverse === 1;
  }
  apply(filterManager, input, output, clearMode) {
    this._textureMatrix.texture = this.sprite.texture;
    filterManager.calculateSpriteMatrix(
      this.resources.filterUniforms.uniforms.uFilterMatrix,
      this.sprite
    ).prepend(this._textureMatrix.mapCoord);
    this.resources.uMaskTexture = this.sprite.texture.source;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}


//# sourceMappingURL=MaskFilter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fragment)
/* harmony export */ });
var fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";


//# sourceMappingURL=mask.frag.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vertex)
/* harmony export */ });
var vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";


//# sourceMappingURL=mask.vert.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ source)
/* harmony export */ });
var source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";


//# sourceMappingURL=mask.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/pixi.js/lib/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractBitmapFont: () => (/* reexport safe */ _scene_text_bitmap_AbstractBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_476__.AbstractBitmapFont),
/* harmony export */   AbstractRenderer: () => (/* reexport safe */ _rendering_renderers_shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_328__.AbstractRenderer),
/* harmony export */   AbstractText: () => (/* reexport safe */ _scene_text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_502__.AbstractText),
/* harmony export */   AccessibilitySystem: () => (/* reexport safe */ _accessibility_AccessibilitySystem_mjs__WEBPACK_IMPORTED_MODULE_3__.AccessibilitySystem),
/* harmony export */   AlphaFilter: () => (/* reexport safe */ _filters_defaults_alpha_AlphaFilter_mjs__WEBPACK_IMPORTED_MODULE_122__.AlphaFilter),
/* harmony export */   AlphaMask: () => (/* reexport safe */ _rendering_mask_alpha_AlphaMask_mjs__WEBPACK_IMPORTED_MODULE_184__.AlphaMask),
/* harmony export */   AlphaMaskPipe: () => (/* reexport safe */ _rendering_mask_alpha_AlphaMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_185__.AlphaMaskPipe),
/* harmony export */   AnimatedSprite: () => (/* reexport safe */ _scene_sprite_animated_AnimatedSprite_mjs__WEBPACK_IMPORTED_MODULE_461__.AnimatedSprite),
/* harmony export */   Application: () => (/* reexport safe */ _app_Application_mjs__WEBPACK_IMPORTED_MODULE_26__.Application),
/* harmony export */   ApplicationInitHook: () => (/* reexport safe */ _utils_global_globalHooks_mjs__WEBPACK_IMPORTED_MODULE_537__.ApplicationInitHook),
/* harmony export */   Assets: () => (/* reexport safe */ _assets_Assets_mjs__WEBPACK_IMPORTED_MODULE_29__.Assets),
/* harmony export */   AssetsClass: () => (/* reexport safe */ _assets_Assets_mjs__WEBPACK_IMPORTED_MODULE_29__.AssetsClass),
/* harmony export */   BLEND_TO_NPM: () => (/* reexport safe */ _rendering_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_325__.BLEND_TO_NPM),
/* harmony export */   BUFFER_TYPE: () => (/* reexport safe */ _rendering_renderers_gl_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_195__.BUFFER_TYPE),
/* harmony export */   BackgroundLoader: () => (/* reexport safe */ _assets_BackgroundLoader_mjs__WEBPACK_IMPORTED_MODULE_30__.BackgroundLoader),
/* harmony export */   BackgroundSystem: () => (/* reexport safe */ _rendering_renderers_shared_background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_293__.BackgroundSystem),
/* harmony export */   Batch: () => (/* reexport safe */ _rendering_batcher_shared_Batcher_mjs__WEBPACK_IMPORTED_MODULE_163__.Batch),
/* harmony export */   BatchGeometry: () => (/* reexport safe */ _rendering_batcher_shared_BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_165__.BatchGeometry),
/* harmony export */   BatchTextureArray: () => (/* reexport safe */ _rendering_batcher_shared_BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_166__.BatchTextureArray),
/* harmony export */   BatchableGraphics: () => (/* reexport safe */ _scene_graphics_shared_BatchableGraphics_mjs__WEBPACK_IMPORTED_MODULE_398__.BatchableGraphics),
/* harmony export */   BatchableMesh: () => (/* reexport safe */ _scene_mesh_shared_BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_444__.BatchableMesh),
/* harmony export */   BatchableSprite: () => (/* reexport safe */ _scene_sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_473__.BatchableSprite),
/* harmony export */   Batcher: () => (/* reexport safe */ _rendering_batcher_shared_Batcher_mjs__WEBPACK_IMPORTED_MODULE_163__.Batcher),
/* harmony export */   BatcherPipe: () => (/* reexport safe */ _rendering_batcher_shared_BatcherPipe_mjs__WEBPACK_IMPORTED_MODULE_164__.BatcherPipe),
/* harmony export */   BigPool: () => (/* reexport safe */ _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_547__.BigPool),
/* harmony export */   BindGroup: () => (/* reexport safe */ _rendering_renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_271__.BindGroup),
/* harmony export */   BindGroupSystem: () => (/* reexport safe */ _rendering_renderers_gpu_BindGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_256__.BindGroupSystem),
/* harmony export */   BitmapFont: () => (/* reexport safe */ _scene_text_bitmap_BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_481__.BitmapFont),
/* harmony export */   BitmapFontManager: () => (/* reexport safe */ _scene_text_bitmap_BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_482__.BitmapFontManager),
/* harmony export */   BitmapText: () => (/* reexport safe */ _scene_text_bitmap_BitmapText_mjs__WEBPACK_IMPORTED_MODULE_483__.BitmapText),
/* harmony export */   BitmapTextPipe: () => (/* reexport safe */ _scene_text_bitmap_BitmapTextPipe_mjs__WEBPACK_IMPORTED_MODULE_484__.BitmapTextPipe),
/* harmony export */   BlendModeFilter: () => (/* reexport safe */ _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_119__.BlendModeFilter),
/* harmony export */   BlendModePipe: () => (/* reexport safe */ _rendering_renderers_shared_blendModes_BlendModePipe_mjs__WEBPACK_IMPORTED_MODULE_294__.BlendModePipe),
/* harmony export */   BlurFilter: () => (/* reexport safe */ _filters_defaults_blur_BlurFilter_mjs__WEBPACK_IMPORTED_MODULE_123__.BlurFilter),
/* harmony export */   BlurFilterPass: () => (/* reexport safe */ _filters_defaults_blur_BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_124__.BlurFilterPass),
/* harmony export */   Bounds: () => (/* reexport safe */ _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_359__.Bounds),
/* harmony export */   BrowserAdapter: () => (/* reexport safe */ _environment_browser_BrowserAdapter_mjs__WEBPACK_IMPORTED_MODULE_91__.BrowserAdapter),
/* harmony export */   Buffer: () => (/* reexport safe */ _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_295__.Buffer),
/* harmony export */   BufferImageSource: () => (/* reexport safe */ _rendering_renderers_shared_texture_sources_BufferImageSource_mjs__WEBPACK_IMPORTED_MODULE_335__.BufferImageSource),
/* harmony export */   BufferResource: () => (/* reexport safe */ _rendering_renderers_shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_296__.BufferResource),
/* harmony export */   BufferUsage: () => (/* reexport safe */ _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_297__.BufferUsage),
/* harmony export */   CLEAR: () => (/* reexport safe */ _rendering_renderers_gl_const_mjs__WEBPACK_IMPORTED_MODULE_198__.CLEAR),
/* harmony export */   Cache: () => (/* reexport safe */ _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_31__.Cache),
/* harmony export */   CanvasPool: () => (/* reexport safe */ _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_331__.CanvasPool),
/* harmony export */   CanvasPoolClass: () => (/* reexport safe */ _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_331__.CanvasPoolClass),
/* harmony export */   CanvasSource: () => (/* reexport safe */ _rendering_renderers_shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_336__.CanvasSource),
/* harmony export */   CanvasTextMetrics: () => (/* reexport safe */ _scene_text_canvas_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_503__.CanvasTextMetrics),
/* harmony export */   CanvasTextPipe: () => (/* reexport safe */ _scene_text_canvas_CanvasTextPipe_mjs__WEBPACK_IMPORTED_MODULE_504__.CanvasTextPipe),
/* harmony export */   CanvasTextSystem: () => (/* reexport safe */ _scene_text_canvas_CanvasTextSystem_mjs__WEBPACK_IMPORTED_MODULE_505__.CanvasTextSystem),
/* harmony export */   Circle: () => (/* reexport safe */ _maths_shapes_Circle_mjs__WEBPACK_IMPORTED_MODULE_146__.Circle),
/* harmony export */   Color: () => (/* reexport safe */ _color_Color_mjs__WEBPACK_IMPORTED_MODULE_60__.Color),
/* harmony export */   ColorBlend: () => (/* reexport safe */ _advanced_blend_modes_ColorBlend_mjs__WEBPACK_IMPORTED_MODULE_5__.ColorBlend),
/* harmony export */   ColorBurnBlend: () => (/* reexport safe */ _advanced_blend_modes_ColorBurnBlend_mjs__WEBPACK_IMPORTED_MODULE_6__.ColorBurnBlend),
/* harmony export */   ColorDodgeBlend: () => (/* reexport safe */ _advanced_blend_modes_ColorDodgeBlend_mjs__WEBPACK_IMPORTED_MODULE_7__.ColorDodgeBlend),
/* harmony export */   ColorMask: () => (/* reexport safe */ _rendering_mask_color_ColorMask_mjs__WEBPACK_IMPORTED_MODULE_186__.ColorMask),
/* harmony export */   ColorMaskPipe: () => (/* reexport safe */ _rendering_mask_color_ColorMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_187__.ColorMaskPipe),
/* harmony export */   ColorMatrixFilter: () => (/* reexport safe */ _filters_defaults_color_matrix_ColorMatrixFilter_mjs__WEBPACK_IMPORTED_MODULE_130__.ColorMatrixFilter),
/* harmony export */   CompressedSource: () => (/* reexport safe */ _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_337__.CompressedSource),
/* harmony export */   Container: () => (/* reexport safe */ _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_376__.Container),
/* harmony export */   Culler: () => (/* reexport safe */ _culling_Culler_mjs__WEBPACK_IMPORTED_MODULE_84__.Culler),
/* harmony export */   CullerPlugin: () => (/* reexport safe */ _culling_CullerPlugin_mjs__WEBPACK_IMPORTED_MODULE_85__.CullerPlugin),
/* harmony export */   CustomRenderPipe: () => (/* reexport safe */ _scene_container_CustomRenderPipe_mjs__WEBPACK_IMPORTED_MODULE_377__.CustomRenderPipe),
/* harmony export */   D3D10_RESOURCE_DIMENSION: () => (/* reexport safe */ _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__.D3D10_RESOURCE_DIMENSION),
/* harmony export */   D3DFMT: () => (/* reexport safe */ _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__.D3DFMT),
/* harmony export */   DATA_URI: () => (/* reexport safe */ _utils_const_mjs__WEBPACK_IMPORTED_MODULE_530__.DATA_URI),
/* harmony export */   DDS: () => (/* reexport safe */ _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__.DDS),
/* harmony export */   DEG_TO_RAD: () => (/* reexport safe */ _maths_misc_const_mjs__WEBPACK_IMPORTED_MODULE_140__.DEG_TO_RAD),
/* harmony export */   DEPRECATED_SCALE_MODES: () => (/* reexport safe */ _rendering_renderers_shared_texture_const_mjs__WEBPACK_IMPORTED_MODULE_332__.DEPRECATED_SCALE_MODES),
/* harmony export */   DEPRECATED_WRAP_MODES: () => (/* reexport safe */ _rendering_renderers_shared_texture_const_mjs__WEBPACK_IMPORTED_MODULE_332__.DEPRECATED_WRAP_MODES),
/* harmony export */   DOMAdapter: () => (/* reexport safe */ _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_89__.DOMAdapter),
/* harmony export */   DOMContainer: () => (/* reexport safe */ _dom_DOMContainer_mjs__WEBPACK_IMPORTED_MODULE_87__.DOMContainer),
/* harmony export */   DOMPipe: () => (/* reexport safe */ _dom_DOMPipe_mjs__WEBPACK_IMPORTED_MODULE_88__.DOMPipe),
/* harmony export */   DRAW_MODES: () => (/* reexport safe */ _rendering_renderers_shared_geometry_const_mjs__WEBPACK_IMPORTED_MODULE_301__.DRAW_MODES),
/* harmony export */   DXGI_FORMAT: () => (/* reexport safe */ _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__.DXGI_FORMAT),
/* harmony export */   DXGI_TO_TEXTURE_FORMAT: () => (/* reexport safe */ _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__.DXGI_TO_TEXTURE_FORMAT),
/* harmony export */   DarkenBlend: () => (/* reexport safe */ _advanced_blend_modes_DarkenBlend_mjs__WEBPACK_IMPORTED_MODULE_8__.DarkenBlend),
/* harmony export */   DefaultBatcher: () => (/* reexport safe */ _rendering_batcher_shared_DefaultBatcher_mjs__WEBPACK_IMPORTED_MODULE_167__.DefaultBatcher),
/* harmony export */   DefaultShader: () => (/* reexport safe */ _rendering_batcher_shared_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_168__.DefaultShader),
/* harmony export */   DifferenceBlend: () => (/* reexport safe */ _advanced_blend_modes_DifferenceBlend_mjs__WEBPACK_IMPORTED_MODULE_9__.DifferenceBlend),
/* harmony export */   DisplacementFilter: () => (/* reexport safe */ _filters_defaults_displacement_DisplacementFilter_mjs__WEBPACK_IMPORTED_MODULE_131__.DisplacementFilter),
/* harmony export */   DivideBlend: () => (/* reexport safe */ _advanced_blend_modes_DivideBlend_mjs__WEBPACK_IMPORTED_MODULE_10__.DivideBlend),
/* harmony export */   DynamicBitmapFont: () => (/* reexport safe */ _scene_text_bitmap_DynamicBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_485__.DynamicBitmapFont),
/* harmony export */   Ellipse: () => (/* reexport safe */ _maths_shapes_Ellipse_mjs__WEBPACK_IMPORTED_MODULE_147__.Ellipse),
/* harmony export */   EventBoundary: () => (/* reexport safe */ _events_EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_93__.EventBoundary),
/* harmony export */   EventEmitter: () => (/* reexport safe */ eventemitter3__WEBPACK_IMPORTED_MODULE_531__["default"]),
/* harmony export */   EventSystem: () => (/* reexport safe */ _events_EventSystem_mjs__WEBPACK_IMPORTED_MODULE_94__.EventSystem),
/* harmony export */   EventsTicker: () => (/* reexport safe */ _events_EventTicker_mjs__WEBPACK_IMPORTED_MODULE_95__.EventsTicker),
/* harmony export */   ExclusionBlend: () => (/* reexport safe */ _advanced_blend_modes_ExclusionBlend_mjs__WEBPACK_IMPORTED_MODULE_11__.ExclusionBlend),
/* harmony export */   ExtensionType: () => (/* reexport safe */ _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType),
/* harmony export */   ExtractSystem: () => (/* reexport safe */ _rendering_renderers_shared_extract_ExtractSystem_mjs__WEBPACK_IMPORTED_MODULE_299__.ExtractSystem),
/* harmony export */   FOURCC_TO_TEXTURE_FORMAT: () => (/* reexport safe */ _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__.FOURCC_TO_TEXTURE_FORMAT),
/* harmony export */   FederatedContainer: () => (/* reexport safe */ _events_FederatedEventTarget_mjs__WEBPACK_IMPORTED_MODULE_97__.FederatedContainer),
/* harmony export */   FederatedEvent: () => (/* reexport safe */ _events_FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_96__.FederatedEvent),
/* harmony export */   FederatedMouseEvent: () => (/* reexport safe */ _events_FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_98__.FederatedMouseEvent),
/* harmony export */   FederatedPointerEvent: () => (/* reexport safe */ _events_FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_99__.FederatedPointerEvent),
/* harmony export */   FederatedWheelEvent: () => (/* reexport safe */ _events_FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_100__.FederatedWheelEvent),
/* harmony export */   FillGradient: () => (/* reexport safe */ _scene_graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_411__.FillGradient),
/* harmony export */   FillPattern: () => (/* reexport safe */ _scene_graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_412__.FillPattern),
/* harmony export */   Filter: () => (/* reexport safe */ _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_133__.Filter),
/* harmony export */   FilterEffect: () => (/* reexport safe */ _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_134__.FilterEffect),
/* harmony export */   FilterPipe: () => (/* reexport safe */ _filters_FilterPipe_mjs__WEBPACK_IMPORTED_MODULE_135__.FilterPipe),
/* harmony export */   FilterSystem: () => (/* reexport safe */ _filters_FilterSystem_mjs__WEBPACK_IMPORTED_MODULE_136__.FilterSystem),
/* harmony export */   FontStylePromiseCache: () => (/* reexport safe */ _scene_text_html_utils_getFontCss_mjs__WEBPACK_IMPORTED_MODULE_494__.FontStylePromiseCache),
/* harmony export */   GAUSSIAN_VALUES: () => (/* reexport safe */ _filters_defaults_blur_const_mjs__WEBPACK_IMPORTED_MODULE_125__.GAUSSIAN_VALUES),
/* harmony export */   GL_FORMATS: () => (/* reexport safe */ _rendering_renderers_gl_texture_const_mjs__WEBPACK_IMPORTED_MODULE_241__.GL_FORMATS),
/* harmony export */   GL_INTERNAL_FORMAT: () => (/* reexport safe */ _compressed_textures_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_72__.GL_INTERNAL_FORMAT),
/* harmony export */   GL_TARGETS: () => (/* reexport safe */ _rendering_renderers_gl_texture_const_mjs__WEBPACK_IMPORTED_MODULE_241__.GL_TARGETS),
/* harmony export */   GL_TYPES: () => (/* reexport safe */ _rendering_renderers_gl_texture_const_mjs__WEBPACK_IMPORTED_MODULE_241__.GL_TYPES),
/* harmony export */   GL_WRAP_MODES: () => (/* reexport safe */ _rendering_renderers_gl_texture_const_mjs__WEBPACK_IMPORTED_MODULE_241__.GL_WRAP_MODES),
/* harmony export */   GenerateTextureSystem: () => (/* reexport safe */ _rendering_renderers_shared_extract_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_300__.GenerateTextureSystem),
/* harmony export */   Geometry: () => (/* reexport safe */ _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_302__.Geometry),
/* harmony export */   GlBackBufferSystem: () => (/* reexport safe */ _rendering_renderers_gl_GlBackBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_202__.GlBackBufferSystem),
/* harmony export */   GlBatchAdaptor: () => (/* reexport safe */ _rendering_batcher_gl_GlBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_156__.GlBatchAdaptor),
/* harmony export */   GlBuffer: () => (/* reexport safe */ _rendering_renderers_gl_buffer_GlBuffer_mjs__WEBPACK_IMPORTED_MODULE_196__.GlBuffer),
/* harmony export */   GlBufferSystem: () => (/* reexport safe */ _rendering_renderers_gl_buffer_GlBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_197__.GlBufferSystem),
/* harmony export */   GlColorMaskSystem: () => (/* reexport safe */ _rendering_renderers_gl_GlColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_203__.GlColorMaskSystem),
/* harmony export */   GlContextSystem: () => (/* reexport safe */ _rendering_renderers_gl_context_GlContextSystem_mjs__WEBPACK_IMPORTED_MODULE_199__.GlContextSystem),
/* harmony export */   GlEncoderSystem: () => (/* reexport safe */ _rendering_renderers_gl_GlEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_204__.GlEncoderSystem),
/* harmony export */   GlGeometrySystem: () => (/* reexport safe */ _rendering_renderers_gl_geometry_GlGeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_200__.GlGeometrySystem),
/* harmony export */   GlGraphicsAdaptor: () => (/* reexport safe */ _scene_graphics_gl_GlGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_395__.GlGraphicsAdaptor),
/* harmony export */   GlMeshAdaptor: () => (/* reexport safe */ _scene_mesh_gl_GlMeshAdaptor_mjs__WEBPACK_IMPORTED_MODULE_442__.GlMeshAdaptor),
/* harmony export */   GlParticleContainerAdaptor: () => (/* reexport safe */ _scene_particle_container_gl_GlParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_449__.GlParticleContainerAdaptor),
/* harmony export */   GlParticleContainerPipe: () => (/* reexport safe */ _scene_particle_container_shared_GlParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_451__.GlParticleContainerPipe),
/* harmony export */   GlProgram: () => (/* reexport safe */ _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_212__.GlProgram),
/* harmony export */   GlProgramData: () => (/* reexport safe */ _rendering_renderers_gl_shader_GlProgramData_mjs__WEBPACK_IMPORTED_MODULE_213__.GlProgramData),
/* harmony export */   GlRenderTarget: () => (/* reexport safe */ _rendering_renderers_gl_GlRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_205__.GlRenderTarget),
/* harmony export */   GlRenderTargetAdaptor: () => (/* reexport safe */ _rendering_renderers_gl_renderTarget_GlRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_208__.GlRenderTargetAdaptor),
/* harmony export */   GlRenderTargetSystem: () => (/* reexport safe */ _rendering_renderers_gl_renderTarget_GlRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_209__.GlRenderTargetSystem),
/* harmony export */   GlShaderSystem: () => (/* reexport safe */ _rendering_renderers_gl_shader_GlShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_214__.GlShaderSystem),
/* harmony export */   GlStateSystem: () => (/* reexport safe */ _rendering_renderers_gl_state_GlStateSystem_mjs__WEBPACK_IMPORTED_MODULE_239__.GlStateSystem),
/* harmony export */   GlStencilSystem: () => (/* reexport safe */ _rendering_renderers_gl_GlStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_206__.GlStencilSystem),
/* harmony export */   GlTexture: () => (/* reexport safe */ _rendering_renderers_gl_texture_GlTexture_mjs__WEBPACK_IMPORTED_MODULE_242__.GlTexture),
/* harmony export */   GlTextureSystem: () => (/* reexport safe */ _rendering_renderers_gl_texture_GlTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_243__.GlTextureSystem),
/* harmony export */   GlUboSystem: () => (/* reexport safe */ _rendering_renderers_gl_GlUboSystem_mjs__WEBPACK_IMPORTED_MODULE_207__.GlUboSystem),
/* harmony export */   GlUniformGroupSystem: () => (/* reexport safe */ _rendering_renderers_gl_shader_GlUniformGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_215__.GlUniformGroupSystem),
/* harmony export */   GlobalUniformSystem: () => (/* reexport safe */ _rendering_renderers_shared_renderTarget_GlobalUniformSystem_mjs__WEBPACK_IMPORTED_MODULE_309__.GlobalUniformSystem),
/* harmony export */   GpuBatchAdaptor: () => (/* reexport safe */ _rendering_batcher_gpu_GpuBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_162__.GpuBatchAdaptor),
/* harmony export */   GpuBlendModesToPixi: () => (/* reexport safe */ _rendering_renderers_gpu_state_GpuBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_282__.GpuBlendModesToPixi),
/* harmony export */   GpuBufferSystem: () => (/* reexport safe */ _rendering_renderers_gpu_buffer_GpuBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_257__.GpuBufferSystem),
/* harmony export */   GpuColorMaskSystem: () => (/* reexport safe */ _rendering_renderers_gpu_GpuColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_260__.GpuColorMaskSystem),
/* harmony export */   GpuDeviceSystem: () => (/* reexport safe */ _rendering_renderers_gpu_GpuDeviceSystem_mjs__WEBPACK_IMPORTED_MODULE_261__.GpuDeviceSystem),
/* harmony export */   GpuEncoderSystem: () => (/* reexport safe */ _rendering_renderers_gpu_GpuEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_262__.GpuEncoderSystem),
/* harmony export */   GpuGraphicsAdaptor: () => (/* reexport safe */ _scene_graphics_gpu_GpuGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_397__.GpuGraphicsAdaptor),
/* harmony export */   GpuGraphicsContext: () => (/* reexport safe */ _scene_graphics_shared_GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_415__.GpuGraphicsContext),
/* harmony export */   GpuMeshAdapter: () => (/* reexport safe */ _scene_mesh_gpu_GpuMeshAdapter_mjs__WEBPACK_IMPORTED_MODULE_443__.GpuMeshAdapter),
/* harmony export */   GpuMipmapGenerator: () => (/* reexport safe */ _rendering_renderers_gpu_texture_utils_GpuMipmapGenerator_mjs__WEBPACK_IMPORTED_MODULE_291__.GpuMipmapGenerator),
/* harmony export */   GpuParticleContainerAdaptor: () => (/* reexport safe */ _scene_particle_container_gpu_GpuParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_450__.GpuParticleContainerAdaptor),
/* harmony export */   GpuParticleContainerPipe: () => (/* reexport safe */ _scene_particle_container_shared_GpuParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_452__.GpuParticleContainerPipe),
/* harmony export */   GpuProgram: () => (/* reexport safe */ _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_272__.GpuProgram),
/* harmony export */   GpuReadBuffer: () => (/* reexport safe */ _rendering_renderers_gpu_buffer_GpuReadBuffer_mjs__WEBPACK_IMPORTED_MODULE_258__.GpuReadBuffer),
/* harmony export */   GpuRenderTarget: () => (/* reexport safe */ _rendering_renderers_gpu_renderTarget_GpuRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_268__.GpuRenderTarget),
/* harmony export */   GpuRenderTargetAdaptor: () => (/* reexport safe */ _rendering_renderers_gpu_renderTarget_GpuRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_269__.GpuRenderTargetAdaptor),
/* harmony export */   GpuRenderTargetSystem: () => (/* reexport safe */ _rendering_renderers_gpu_renderTarget_GpuRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_270__.GpuRenderTargetSystem),
/* harmony export */   GpuShaderSystem: () => (/* reexport safe */ _rendering_renderers_gpu_shader_GpuShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_273__.GpuShaderSystem),
/* harmony export */   GpuStateSystem: () => (/* reexport safe */ _rendering_renderers_gpu_state_GpuStateSystem_mjs__WEBPACK_IMPORTED_MODULE_283__.GpuStateSystem),
/* harmony export */   GpuStencilModesToPixi: () => (/* reexport safe */ _rendering_renderers_gpu_state_GpuStencilModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_284__.GpuStencilModesToPixi),
/* harmony export */   GpuStencilSystem: () => (/* reexport safe */ _rendering_renderers_gpu_GpuStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_263__.GpuStencilSystem),
/* harmony export */   GpuTextureSystem: () => (/* reexport safe */ _rendering_renderers_gpu_texture_GpuTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_285__.GpuTextureSystem),
/* harmony export */   GpuUboSystem: () => (/* reexport safe */ _rendering_renderers_gpu_GpuUboSystem_mjs__WEBPACK_IMPORTED_MODULE_264__.GpuUboSystem),
/* harmony export */   GpuUniformBatchPipe: () => (/* reexport safe */ _rendering_renderers_gpu_GpuUniformBatchPipe_mjs__WEBPACK_IMPORTED_MODULE_265__.GpuUniformBatchPipe),
/* harmony export */   Graphics: () => (/* reexport safe */ _scene_graphics_shared_Graphics_mjs__WEBPACK_IMPORTED_MODULE_413__.Graphics),
/* harmony export */   GraphicsContext: () => (/* reexport safe */ _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_414__.GraphicsContext),
/* harmony export */   GraphicsContextRenderData: () => (/* reexport safe */ _scene_graphics_shared_GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_415__.GraphicsContextRenderData),
/* harmony export */   GraphicsContextSystem: () => (/* reexport safe */ _scene_graphics_shared_GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_415__.GraphicsContextSystem),
/* harmony export */   GraphicsPath: () => (/* reexport safe */ _scene_graphics_shared_path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_417__.GraphicsPath),
/* harmony export */   GraphicsPipe: () => (/* reexport safe */ _scene_graphics_shared_GraphicsPipe_mjs__WEBPACK_IMPORTED_MODULE_416__.GraphicsPipe),
/* harmony export */   HTMLText: () => (/* reexport safe */ _scene_text_html_HTMLText_mjs__WEBPACK_IMPORTED_MODULE_488__.HTMLText),
/* harmony export */   HTMLTextPipe: () => (/* reexport safe */ _scene_text_html_HTMLTextPipe_mjs__WEBPACK_IMPORTED_MODULE_489__.HTMLTextPipe),
/* harmony export */   HTMLTextRenderData: () => (/* reexport safe */ _scene_text_html_HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_490__.HTMLTextRenderData),
/* harmony export */   HTMLTextStyle: () => (/* reexport safe */ _scene_text_html_HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_491__.HTMLTextStyle),
/* harmony export */   HTMLTextSystem: () => (/* reexport safe */ _scene_text_html_HTMLTextSystem_mjs__WEBPACK_IMPORTED_MODULE_492__.HTMLTextSystem),
/* harmony export */   HardLightBlend: () => (/* reexport safe */ _advanced_blend_modes_HardLightBlend_mjs__WEBPACK_IMPORTED_MODULE_12__.HardLightBlend),
/* harmony export */   HardMixBlend: () => (/* reexport safe */ _advanced_blend_modes_HardMixBlend_mjs__WEBPACK_IMPORTED_MODULE_13__.HardMixBlend),
/* harmony export */   HelloSystem: () => (/* reexport safe */ _rendering_renderers_shared_startup_HelloSystem_mjs__WEBPACK_IMPORTED_MODULE_324__.HelloSystem),
/* harmony export */   IGLUniformData: () => (/* reexport safe */ _rendering_renderers_gl_shader_GlProgramData_mjs__WEBPACK_IMPORTED_MODULE_213__.IGLUniformData),
/* harmony export */   ImageSource: () => (/* reexport safe */ _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_338__.ImageSource),
/* harmony export */   InstructionSet: () => (/* reexport safe */ _rendering_renderers_shared_instructions_InstructionSet_mjs__WEBPACK_IMPORTED_MODULE_308__.InstructionSet),
/* harmony export */   KTX: () => (/* reexport safe */ _compressed_textures_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_72__.KTX),
/* harmony export */   LightenBlend: () => (/* reexport safe */ _advanced_blend_modes_LightenBlend_mjs__WEBPACK_IMPORTED_MODULE_14__.LightenBlend),
/* harmony export */   LinearBurnBlend: () => (/* reexport safe */ _advanced_blend_modes_LinearBurnBlend_mjs__WEBPACK_IMPORTED_MODULE_15__.LinearBurnBlend),
/* harmony export */   LinearDodgeBlend: () => (/* reexport safe */ _advanced_blend_modes_LinearDodgeBlend_mjs__WEBPACK_IMPORTED_MODULE_16__.LinearDodgeBlend),
/* harmony export */   LinearLightBlend: () => (/* reexport safe */ _advanced_blend_modes_LinearLightBlend_mjs__WEBPACK_IMPORTED_MODULE_17__.LinearLightBlend),
/* harmony export */   Loader: () => (/* reexport safe */ _assets_loader_Loader_mjs__WEBPACK_IMPORTED_MODULE_41__.Loader),
/* harmony export */   LoaderParserPriority: () => (/* reexport safe */ _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_42__.LoaderParserPriority),
/* harmony export */   LuminosityBlend: () => (/* reexport safe */ _advanced_blend_modes_LuminosityBlend_mjs__WEBPACK_IMPORTED_MODULE_18__.LuminosityBlend),
/* harmony export */   MSAA_QUALITY: () => (/* reexport safe */ _rendering_renderers_shared_texture_const_mjs__WEBPACK_IMPORTED_MODULE_332__.MSAA_QUALITY),
/* harmony export */   MaskEffectManager: () => (/* reexport safe */ _rendering_mask_MaskEffectManager_mjs__WEBPACK_IMPORTED_MODULE_188__.MaskEffectManager),
/* harmony export */   MaskEffectManagerClass: () => (/* reexport safe */ _rendering_mask_MaskEffectManager_mjs__WEBPACK_IMPORTED_MODULE_188__.MaskEffectManagerClass),
/* harmony export */   MaskFilter: () => (/* reexport safe */ _filters_mask_MaskFilter_mjs__WEBPACK_IMPORTED_MODULE_137__.MaskFilter),
/* harmony export */   Matrix: () => (/* reexport safe */ _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_139__.Matrix),
/* harmony export */   Mesh: () => (/* reexport safe */ _scene_mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_446__.Mesh),
/* harmony export */   MeshGeometry: () => (/* reexport safe */ _scene_mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_447__.MeshGeometry),
/* harmony export */   MeshPipe: () => (/* reexport safe */ _scene_mesh_shared_MeshPipe_mjs__WEBPACK_IMPORTED_MODULE_448__.MeshPipe),
/* harmony export */   MeshPlane: () => (/* reexport safe */ _scene_mesh_plane_MeshPlane_mjs__WEBPACK_IMPORTED_MODULE_437__.MeshPlane),
/* harmony export */   MeshRope: () => (/* reexport safe */ _scene_mesh_simple_MeshRope_mjs__WEBPACK_IMPORTED_MODULE_439__.MeshRope),
/* harmony export */   MeshSimple: () => (/* reexport safe */ _scene_mesh_simple_MeshSimple_mjs__WEBPACK_IMPORTED_MODULE_440__.MeshSimple),
/* harmony export */   NOOP: () => (/* reexport safe */ _utils_misc_NOOP_mjs__WEBPACK_IMPORTED_MODULE_542__.NOOP),
/* harmony export */   NegationBlend: () => (/* reexport safe */ _advanced_blend_modes_NegationBlend_mjs__WEBPACK_IMPORTED_MODULE_19__.NegationBlend),
/* harmony export */   NineSliceGeometry: () => (/* reexport safe */ _scene_sprite_nine_slice_NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_462__.NineSliceGeometry),
/* harmony export */   NineSlicePlane: () => (/* reexport safe */ _scene_sprite_nine_slice_NineSliceSprite_mjs__WEBPACK_IMPORTED_MODULE_463__.NineSlicePlane),
/* harmony export */   NineSliceSprite: () => (/* reexport safe */ _scene_sprite_nine_slice_NineSliceSprite_mjs__WEBPACK_IMPORTED_MODULE_463__.NineSliceSprite),
/* harmony export */   NineSliceSpritePipe: () => (/* reexport safe */ _scene_sprite_nine_slice_NineSliceSpritePipe_mjs__WEBPACK_IMPORTED_MODULE_464__.NineSliceSpritePipe),
/* harmony export */   NoiseFilter: () => (/* reexport safe */ _filters_defaults_noise_NoiseFilter_mjs__WEBPACK_IMPORTED_MODULE_132__.NoiseFilter),
/* harmony export */   ObservablePoint: () => (/* reexport safe */ _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_143__.ObservablePoint),
/* harmony export */   OverlayBlend: () => (/* reexport safe */ _advanced_blend_modes_OverlayBlend_mjs__WEBPACK_IMPORTED_MODULE_20__.OverlayBlend),
/* harmony export */   PI_2: () => (/* reexport safe */ _maths_misc_const_mjs__WEBPACK_IMPORTED_MODULE_140__.PI_2),
/* harmony export */   Particle: () => (/* reexport safe */ _scene_particle_container_shared_Particle_mjs__WEBPACK_IMPORTED_MODULE_453__.Particle),
/* harmony export */   ParticleBuffer: () => (/* reexport safe */ _scene_particle_container_shared_ParticleBuffer_mjs__WEBPACK_IMPORTED_MODULE_454__.ParticleBuffer),
/* harmony export */   ParticleContainer: () => (/* reexport safe */ _scene_particle_container_shared_ParticleContainer_mjs__WEBPACK_IMPORTED_MODULE_455__.ParticleContainer),
/* harmony export */   ParticleContainerPipe: () => (/* reexport safe */ _scene_particle_container_shared_ParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_456__.ParticleContainerPipe),
/* harmony export */   ParticleShader: () => (/* reexport safe */ _scene_particle_container_shared_shader_ParticleShader_mjs__WEBPACK_IMPORTED_MODULE_458__.ParticleShader),
/* harmony export */   PerspectiveMesh: () => (/* reexport safe */ _scene_mesh_perspective_PerspectiveMesh_mjs__WEBPACK_IMPORTED_MODULE_433__.PerspectiveMesh),
/* harmony export */   PerspectivePlaneGeometry: () => (/* reexport safe */ _scene_mesh_perspective_PerspectivePlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_434__.PerspectivePlaneGeometry),
/* harmony export */   PinLightBlend: () => (/* reexport safe */ _advanced_blend_modes_PinLightBlend_mjs__WEBPACK_IMPORTED_MODULE_21__.PinLightBlend),
/* harmony export */   PipelineSystem: () => (/* reexport safe */ _rendering_renderers_gpu_pipeline_PipelineSystem_mjs__WEBPACK_IMPORTED_MODULE_266__.PipelineSystem),
/* harmony export */   PlaneGeometry: () => (/* reexport safe */ _scene_mesh_plane_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_438__.PlaneGeometry),
/* harmony export */   Point: () => (/* reexport safe */ _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_144__.Point),
/* harmony export */   Polygon: () => (/* reexport safe */ _maths_shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_148__.Polygon),
/* harmony export */   Pool: () => (/* reexport safe */ _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_546__.Pool),
/* harmony export */   PoolGroupClass: () => (/* reexport safe */ _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_547__.PoolGroupClass),
/* harmony export */   PrepareBase: () => (/* reexport safe */ _prepare_PrepareBase_mjs__WEBPACK_IMPORTED_MODULE_152__.PrepareBase),
/* harmony export */   PrepareQueue: () => (/* reexport safe */ _prepare_PrepareQueue_mjs__WEBPACK_IMPORTED_MODULE_153__.PrepareQueue),
/* harmony export */   PrepareSystem: () => (/* reexport safe */ _prepare_PrepareSystem_mjs__WEBPACK_IMPORTED_MODULE_154__.PrepareSystem),
/* harmony export */   PrepareUpload: () => (/* reexport safe */ _prepare_PrepareUpload_mjs__WEBPACK_IMPORTED_MODULE_155__.PrepareUpload),
/* harmony export */   QuadGeometry: () => (/* reexport safe */ _scene_sprite_tiling_utils_QuadGeometry_mjs__WEBPACK_IMPORTED_MODULE_470__.QuadGeometry),
/* harmony export */   RAD_TO_DEG: () => (/* reexport safe */ _maths_misc_const_mjs__WEBPACK_IMPORTED_MODULE_140__.RAD_TO_DEG),
/* harmony export */   Rectangle: () => (/* reexport safe */ _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_149__.Rectangle),
/* harmony export */   RenderContainer: () => (/* reexport safe */ _scene_container_RenderContainer_mjs__WEBPACK_IMPORTED_MODULE_378__.RenderContainer),
/* harmony export */   RenderGroup: () => (/* reexport safe */ _scene_container_RenderGroup_mjs__WEBPACK_IMPORTED_MODULE_379__.RenderGroup),
/* harmony export */   RenderGroupPipe: () => (/* reexport safe */ _scene_container_RenderGroupPipe_mjs__WEBPACK_IMPORTED_MODULE_380__.RenderGroupPipe),
/* harmony export */   RenderGroupSystem: () => (/* reexport safe */ _scene_container_RenderGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_381__.RenderGroupSystem),
/* harmony export */   RenderLayer: () => (/* reexport safe */ _scene_layers_RenderLayer_mjs__WEBPACK_IMPORTED_MODULE_432__.RenderLayer),
/* harmony export */   RenderLayerClass: () => (/* reexport safe */ _scene_layers_RenderLayer_mjs__WEBPACK_IMPORTED_MODULE_432__.RenderLayerClass),
/* harmony export */   RenderTarget: () => (/* reexport safe */ _rendering_renderers_shared_renderTarget_RenderTarget_mjs__WEBPACK_IMPORTED_MODULE_311__.RenderTarget),
/* harmony export */   RenderTargetSystem: () => (/* reexport safe */ _rendering_renderers_shared_renderTarget_RenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_312__.RenderTargetSystem),
/* harmony export */   RenderTexture: () => (/* reexport safe */ _rendering_renderers_shared_texture_RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_334__.RenderTexture),
/* harmony export */   RenderableGCSystem: () => (/* reexport safe */ _rendering_renderers_shared_texture_RenderableGCSystem_mjs__WEBPACK_IMPORTED_MODULE_333__.RenderableGCSystem),
/* harmony export */   RendererInitHook: () => (/* reexport safe */ _utils_global_globalHooks_mjs__WEBPACK_IMPORTED_MODULE_537__.RendererInitHook),
/* harmony export */   RendererType: () => (/* reexport safe */ _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_355__.RendererType),
/* harmony export */   ResizePlugin: () => (/* reexport safe */ _app_ResizePlugin_mjs__WEBPACK_IMPORTED_MODULE_27__.ResizePlugin),
/* harmony export */   Resolver: () => (/* reexport safe */ _assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_53__.Resolver),
/* harmony export */   RopeGeometry: () => (/* reexport safe */ _scene_mesh_simple_RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_441__.RopeGeometry),
/* harmony export */   RoundedRectangle: () => (/* reexport safe */ _maths_shapes_RoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_150__.RoundedRectangle),
/* harmony export */   SCALE_MODES: () => (/* reexport safe */ _rendering_renderers_shared_texture_const_mjs__WEBPACK_IMPORTED_MODULE_332__.SCALE_MODES),
/* harmony export */   STENCIL_MODES: () => (/* reexport safe */ _rendering_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_325__.STENCIL_MODES),
/* harmony export */   SVGParser: () => (/* reexport safe */ _scene_graphics_shared_svg_SVGParser_mjs__WEBPACK_IMPORTED_MODULE_424__.SVGParser),
/* harmony export */   SaturationBlend: () => (/* reexport safe */ _advanced_blend_modes_SaturationBlend_mjs__WEBPACK_IMPORTED_MODULE_22__.SaturationBlend),
/* harmony export */   SchedulerSystem: () => (/* reexport safe */ _rendering_renderers_shared_SchedulerSystem_mjs__WEBPACK_IMPORTED_MODULE_314__.SchedulerSystem),
/* harmony export */   ScissorMask: () => (/* reexport safe */ _rendering_mask_scissor_ScissorMask_mjs__WEBPACK_IMPORTED_MODULE_189__.ScissorMask),
/* harmony export */   SdfShader: () => (/* reexport safe */ _scene_text_sdfShader_SdfShader_mjs__WEBPACK_IMPORTED_MODULE_508__.SdfShader),
/* harmony export */   Shader: () => (/* reexport safe */ _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_316__.Shader),
/* harmony export */   ShaderStage: () => (/* reexport safe */ _rendering_renderers_shared_shader_const_mjs__WEBPACK_IMPORTED_MODULE_315__.ShaderStage),
/* harmony export */   ShapePath: () => (/* reexport safe */ _scene_graphics_shared_path_ShapePath_mjs__WEBPACK_IMPORTED_MODULE_419__.ShapePath),
/* harmony export */   SharedRenderPipes: () => (/* reexport safe */ _rendering_renderers_shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_329__.SharedRenderPipes),
/* harmony export */   SharedSystems: () => (/* reexport safe */ _rendering_renderers_shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_329__.SharedSystems),
/* harmony export */   SoftLightBlend: () => (/* reexport safe */ _advanced_blend_modes_SoftLightBlend_mjs__WEBPACK_IMPORTED_MODULE_23__.SoftLightBlend),
/* harmony export */   Sprite: () => (/* reexport safe */ _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_474__.Sprite),
/* harmony export */   SpritePipe: () => (/* reexport safe */ _scene_sprite_SpritePipe_mjs__WEBPACK_IMPORTED_MODULE_475__.SpritePipe),
/* harmony export */   Spritesheet: () => (/* reexport safe */ _spritesheet_Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_518__.Spritesheet),
/* harmony export */   State: () => (/* reexport safe */ _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_327__.State),
/* harmony export */   StencilMask: () => (/* reexport safe */ _rendering_mask_stencil_StencilMask_mjs__WEBPACK_IMPORTED_MODULE_190__.StencilMask),
/* harmony export */   StencilMaskPipe: () => (/* reexport safe */ _rendering_mask_stencil_StencilMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_191__.StencilMaskPipe),
/* harmony export */   SubtractBlend: () => (/* reexport safe */ _advanced_blend_modes_SubtractBlend_mjs__WEBPACK_IMPORTED_MODULE_24__.SubtractBlend),
/* harmony export */   SystemRunner: () => (/* reexport safe */ _rendering_renderers_shared_system_SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_330__.SystemRunner),
/* harmony export */   TEXTURE_FORMAT_BLOCK_SIZE: () => (/* reexport safe */ _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__.TEXTURE_FORMAT_BLOCK_SIZE),
/* harmony export */   Text: () => (/* reexport safe */ _scene_text_Text_mjs__WEBPACK_IMPORTED_MODULE_511__.Text),
/* harmony export */   TextStyle: () => (/* reexport safe */ _scene_text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_512__.TextStyle),
/* harmony export */   Texture: () => (/* reexport safe */ _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_341__.Texture),
/* harmony export */   TextureGCSystem: () => (/* reexport safe */ _rendering_renderers_shared_texture_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_342__.TextureGCSystem),
/* harmony export */   TextureMatrix: () => (/* reexport safe */ _rendering_renderers_shared_texture_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_343__.TextureMatrix),
/* harmony export */   TexturePool: () => (/* reexport safe */ _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_344__.TexturePool),
/* harmony export */   TexturePoolClass: () => (/* reexport safe */ _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_344__.TexturePoolClass),
/* harmony export */   TextureSource: () => (/* reexport safe */ _rendering_renderers_shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_339__.TextureSource),
/* harmony export */   TextureStyle: () => (/* reexport safe */ _rendering_renderers_shared_texture_TextureStyle_mjs__WEBPACK_IMPORTED_MODULE_345__.TextureStyle),
/* harmony export */   TextureUvs: () => (/* reexport safe */ _rendering_renderers_shared_texture_TextureUvs_mjs__WEBPACK_IMPORTED_MODULE_346__.TextureUvs),
/* harmony export */   Ticker: () => (/* reexport safe */ _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_521__.Ticker),
/* harmony export */   TickerListener: () => (/* reexport safe */ _ticker_TickerListener_mjs__WEBPACK_IMPORTED_MODULE_522__.TickerListener),
/* harmony export */   TickerPlugin: () => (/* reexport safe */ _app_TickerPlugin_mjs__WEBPACK_IMPORTED_MODULE_28__.TickerPlugin),
/* harmony export */   TilingSprite: () => (/* reexport safe */ _scene_sprite_tiling_TilingSprite_mjs__WEBPACK_IMPORTED_MODULE_467__.TilingSprite),
/* harmony export */   TilingSpritePipe: () => (/* reexport safe */ _scene_sprite_tiling_TilingSpritePipe_mjs__WEBPACK_IMPORTED_MODULE_468__.TilingSpritePipe),
/* harmony export */   TilingSpriteShader: () => (/* reexport safe */ _scene_sprite_tiling_shader_TilingSpriteShader_mjs__WEBPACK_IMPORTED_MODULE_466__.TilingSpriteShader),
/* harmony export */   Transform: () => (/* reexport safe */ _utils_misc_Transform_mjs__WEBPACK_IMPORTED_MODULE_543__.Transform),
/* harmony export */   Triangle: () => (/* reexport safe */ _maths_shapes_Triangle_mjs__WEBPACK_IMPORTED_MODULE_151__.Triangle),
/* harmony export */   UNIFORM_TO_ARRAY_SETTERS: () => (/* reexport safe */ _rendering_renderers_gl_shader_utils_generateUniformsSyncTypes_mjs__WEBPACK_IMPORTED_MODULE_238__.UNIFORM_TO_ARRAY_SETTERS),
/* harmony export */   UNIFORM_TO_SINGLE_SETTERS: () => (/* reexport safe */ _rendering_renderers_gl_shader_utils_generateUniformsSyncTypes_mjs__WEBPACK_IMPORTED_MODULE_238__.UNIFORM_TO_SINGLE_SETTERS),
/* harmony export */   UNIFORM_TYPES_MAP: () => (/* reexport safe */ _rendering_renderers_shared_shader_types_mjs__WEBPACK_IMPORTED_MODULE_317__.UNIFORM_TYPES_MAP),
/* harmony export */   UNIFORM_TYPES_VALUES: () => (/* reexport safe */ _rendering_renderers_shared_shader_types_mjs__WEBPACK_IMPORTED_MODULE_317__.UNIFORM_TYPES_VALUES),
/* harmony export */   UPDATE_BLEND: () => (/* reexport safe */ _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_376__.UPDATE_BLEND),
/* harmony export */   UPDATE_COLOR: () => (/* reexport safe */ _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_376__.UPDATE_COLOR),
/* harmony export */   UPDATE_PRIORITY: () => (/* reexport safe */ _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_520__.UPDATE_PRIORITY),
/* harmony export */   UPDATE_TRANSFORM: () => (/* reexport safe */ _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_376__.UPDATE_TRANSFORM),
/* harmony export */   UPDATE_VISIBLE: () => (/* reexport safe */ _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_376__.UPDATE_VISIBLE),
/* harmony export */   UboBatch: () => (/* reexport safe */ _rendering_renderers_gpu_buffer_UboBatch_mjs__WEBPACK_IMPORTED_MODULE_259__.UboBatch),
/* harmony export */   UboSystem: () => (/* reexport safe */ _rendering_renderers_shared_shader_UboSystem_mjs__WEBPACK_IMPORTED_MODULE_318__.UboSystem),
/* harmony export */   UniformGroup: () => (/* reexport safe */ _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_319__.UniformGroup),
/* harmony export */   VERSION: () => (/* reexport safe */ _utils_const_mjs__WEBPACK_IMPORTED_MODULE_530__.VERSION),
/* harmony export */   VideoSource: () => (/* reexport safe */ _rendering_renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_340__.VideoSource),
/* harmony export */   ViewContainer: () => (/* reexport safe */ _scene_view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_517__.ViewContainer),
/* harmony export */   ViewSystem: () => (/* reexport safe */ _rendering_renderers_shared_view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_354__.ViewSystem),
/* harmony export */   ViewableBuffer: () => (/* reexport safe */ _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_536__.ViewableBuffer),
/* harmony export */   VividLightBlend: () => (/* reexport safe */ _advanced_blend_modes_VividLightBlend_mjs__WEBPACK_IMPORTED_MODULE_25__.VividLightBlend),
/* harmony export */   WGSL_ALIGN_SIZE_DATA: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_createUboElementsWGSL_mjs__WEBPACK_IMPORTED_MODULE_274__.WGSL_ALIGN_SIZE_DATA),
/* harmony export */   WGSL_TO_STD40_SIZE: () => (/* reexport safe */ _rendering_renderers_gl_shader_utils_createUboElementsSTD40_mjs__WEBPACK_IMPORTED_MODULE_234__.WGSL_TO_STD40_SIZE),
/* harmony export */   WRAP_MODES: () => (/* reexport safe */ _rendering_renderers_shared_texture_const_mjs__WEBPACK_IMPORTED_MODULE_332__.WRAP_MODES),
/* harmony export */   WebGLRenderer: () => (/* reexport safe */ _rendering_renderers_gl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_255__.WebGLRenderer),
/* harmony export */   WebGPURenderer: () => (/* reexport safe */ _rendering_renderers_gpu_WebGPURenderer_mjs__WEBPACK_IMPORTED_MODULE_292__.WebGPURenderer),
/* harmony export */   WebWorkerAdapter: () => (/* reexport safe */ _environment_webworker_WebWorkerAdapter_mjs__WEBPACK_IMPORTED_MODULE_92__.WebWorkerAdapter),
/* harmony export */   WorkerManager: () => (/* reexport safe */ _assets_loader_workers_WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_50__.WorkerManager),
/* harmony export */   _getGlobalBounds: () => (/* reexport safe */ _scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_361__._getGlobalBounds),
/* harmony export */   accessibilityTarget: () => (/* reexport safe */ _accessibility_accessibilityTarget_mjs__WEBPACK_IMPORTED_MODULE_4__.accessibilityTarget),
/* harmony export */   addBits: () => (/* reexport safe */ _rendering_high_shader_compiler_utils_addBits_mjs__WEBPACK_IMPORTED_MODULE_171__.addBits),
/* harmony export */   addMaskBounds: () => (/* reexport safe */ _rendering_mask_utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_192__.addMaskBounds),
/* harmony export */   addMaskLocalBounds: () => (/* reexport safe */ _rendering_mask_utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_193__.addMaskLocalBounds),
/* harmony export */   addProgramDefines: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_preprocessors_addProgramDefines_mjs__WEBPACK_IMPORTED_MODULE_229__.addProgramDefines),
/* harmony export */   alphaFrag: () => (/* reexport safe */ _filters_defaults_alpha_alpha_frag_mjs__WEBPACK_IMPORTED_MODULE_105__["default"]),
/* harmony export */   alphaWgsl: () => (/* reexport safe */ _filters_defaults_alpha_alpha_wgsl_mjs__WEBPACK_IMPORTED_MODULE_106__["default"]),
/* harmony export */   applyMatrix: () => (/* reexport safe */ _scene_sprite_tiling_utils_applyMatrix_mjs__WEBPACK_IMPORTED_MODULE_469__.applyMatrix),
/* harmony export */   applyProjectiveTransformationToPlane: () => (/* reexport safe */ _scene_mesh_perspective_utils_applyProjectiveTransformationToPlane_mjs__WEBPACK_IMPORTED_MODULE_435__.applyProjectiveTransformationToPlane),
/* harmony export */   applyStyleParams: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_applyStyleParams_mjs__WEBPACK_IMPORTED_MODULE_248__.applyStyleParams),
/* harmony export */   assignWithIgnore: () => (/* reexport safe */ _scene_container_utils_assignWithIgnore_mjs__WEBPACK_IMPORTED_MODULE_382__.assignWithIgnore),
/* harmony export */   autoDetectEnvironment: () => (/* reexport safe */ _environment_autoDetectEnvironment_mjs__WEBPACK_IMPORTED_MODULE_90__.autoDetectEnvironment),
/* harmony export */   autoDetectRenderer: () => (/* reexport safe */ _rendering_renderers_autoDetectRenderer_mjs__WEBPACK_IMPORTED_MODULE_194__.autoDetectRenderer),
/* harmony export */   autoDetectSource: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_textureFrom_mjs__WEBPACK_IMPORTED_MODULE_351__.autoDetectSource),
/* harmony export */   basisTranscoderUrls: () => (/* reexport safe */ _compressed_textures_basis_utils_setBasisTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_65__.basisTranscoderUrls),
/* harmony export */   bgr2rgb: () => (/* reexport safe */ _scene_container_container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_371__.bgr2rgb),
/* harmony export */   bitmapFontCachePlugin: () => (/* reexport safe */ _scene_text_bitmap_asset_loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_480__.bitmapFontCachePlugin),
/* harmony export */   bitmapFontTextParser: () => (/* reexport safe */ _scene_text_bitmap_asset_bitmapFontTextParser_mjs__WEBPACK_IMPORTED_MODULE_477__.bitmapFontTextParser),
/* harmony export */   bitmapFontXMLParser: () => (/* reexport safe */ _scene_text_bitmap_asset_bitmapFontXMLParser_mjs__WEBPACK_IMPORTED_MODULE_478__.bitmapFontXMLParser),
/* harmony export */   bitmapFontXMLStringParser: () => (/* reexport safe */ _scene_text_bitmap_asset_bitmapFontXMLStringParser_mjs__WEBPACK_IMPORTED_MODULE_479__.bitmapFontXMLStringParser),
/* harmony export */   blendTemplateFrag: () => (/* reexport safe */ _filters_blend_modes_blend_template_frag_mjs__WEBPACK_IMPORTED_MODULE_101__["default"]),
/* harmony export */   blendTemplateVert: () => (/* reexport safe */ _filters_blend_modes_blend_template_vert_mjs__WEBPACK_IMPORTED_MODULE_102__["default"]),
/* harmony export */   blendTemplateWgsl: () => (/* reexport safe */ _filters_blend_modes_blend_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_103__["default"]),
/* harmony export */   blockDataMap: () => (/* reexport safe */ _rendering_renderers_gpu_texture_uploaders_gpuUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_287__.blockDataMap),
/* harmony export */   blurTemplateWgsl: () => (/* reexport safe */ _filters_defaults_blur_gpu_blur_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_107__["default"]),
/* harmony export */   boundsPool: () => (/* reexport safe */ _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_364__.boundsPool),
/* harmony export */   browserExt: () => (/* reexport safe */ _environment_browser_browserExt_mjs__WEBPACK_IMPORTED_MODULE_550__.browserExt),
/* harmony export */   buildAdaptiveBezier: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildAdaptiveBezier_mjs__WEBPACK_IMPORTED_MODULE_399__.buildAdaptiveBezier),
/* harmony export */   buildAdaptiveQuadratic: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildAdaptiveQuadratic_mjs__WEBPACK_IMPORTED_MODULE_400__.buildAdaptiveQuadratic),
/* harmony export */   buildArc: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildArc_mjs__WEBPACK_IMPORTED_MODULE_401__.buildArc),
/* harmony export */   buildArcTo: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildArcTo_mjs__WEBPACK_IMPORTED_MODULE_402__.buildArcTo),
/* harmony export */   buildArcToSvg: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildArcToSvg_mjs__WEBPACK_IMPORTED_MODULE_403__.buildArcToSvg),
/* harmony export */   buildCircle: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_404__.buildCircle),
/* harmony export */   buildContextBatches: () => (/* reexport safe */ _scene_graphics_shared_utils_buildContextBatches_mjs__WEBPACK_IMPORTED_MODULE_426__.buildContextBatches),
/* harmony export */   buildEllipse: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_404__.buildEllipse),
/* harmony export */   buildGeometryFromPath: () => (/* reexport safe */ _scene_graphics_shared_utils_buildGeometryFromPath_mjs__WEBPACK_IMPORTED_MODULE_427__.buildGeometryFromPath),
/* harmony export */   buildLine: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildLine_mjs__WEBPACK_IMPORTED_MODULE_405__.buildLine),
/* harmony export */   buildPixelLine: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildPixelLine_mjs__WEBPACK_IMPORTED_MODULE_406__.buildPixelLine),
/* harmony export */   buildPolygon: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildPolygon_mjs__WEBPACK_IMPORTED_MODULE_407__.buildPolygon),
/* harmony export */   buildRectangle: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_408__.buildRectangle),
/* harmony export */   buildRoundedRectangle: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_404__.buildRoundedRectangle),
/* harmony export */   buildSimpleUvs: () => (/* reexport safe */ _rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_303__.buildSimpleUvs),
/* harmony export */   buildTriangle: () => (/* reexport safe */ _scene_graphics_shared_buildCommands_buildTriangle_mjs__WEBPACK_IMPORTED_MODULE_409__.buildTriangle),
/* harmony export */   buildUvs: () => (/* reexport safe */ _rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_303__.buildUvs),
/* harmony export */   cacheAsTextureMixin: () => (/* reexport safe */ _scene_container_container_mixins_cacheAsTextureMixin_mjs__WEBPACK_IMPORTED_MODULE_365__.cacheAsTextureMixin),
/* harmony export */   cacheTextureArray: () => (/* reexport safe */ _assets_cache_parsers_cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_32__.cacheTextureArray),
/* harmony export */   calculateProjection: () => (/* reexport safe */ _rendering_renderers_gpu_renderTarget_calculateProjection_mjs__WEBPACK_IMPORTED_MODULE_267__.calculateProjection),
/* harmony export */   checkChildrenDidChange: () => (/* reexport safe */ _scene_container_utils_checkChildrenDidChange_mjs__WEBPACK_IMPORTED_MODULE_383__.checkChildrenDidChange),
/* harmony export */   checkDataUrl: () => (/* reexport safe */ _assets_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_54__.checkDataUrl),
/* harmony export */   checkExtension: () => (/* reexport safe */ _assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_55__.checkExtension),
/* harmony export */   checkMaxIfStatementsInShader: () => (/* reexport safe */ _rendering_batcher_gl_utils_checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_157__.checkMaxIfStatementsInShader),
/* harmony export */   childrenHelperMixin: () => (/* reexport safe */ _scene_container_container_mixins_childrenHelperMixin_mjs__WEBPACK_IMPORTED_MODULE_366__.childrenHelperMixin),
/* harmony export */   cleanArray: () => (/* reexport safe */ _utils_data_clean_mjs__WEBPACK_IMPORTED_MODULE_532__.cleanArray),
/* harmony export */   cleanHash: () => (/* reexport safe */ _utils_data_clean_mjs__WEBPACK_IMPORTED_MODULE_532__.cleanHash),
/* harmony export */   clearList: () => (/* reexport safe */ _scene_container_utils_clearList_mjs__WEBPACK_IMPORTED_MODULE_384__.clearList),
/* harmony export */   closePointEps: () => (/* reexport safe */ _scene_graphics_shared_const_mjs__WEBPACK_IMPORTED_MODULE_410__.closePointEps),
/* harmony export */   collectAllRenderables: () => (/* reexport safe */ _scene_container_utils_collectAllRenderables_mjs__WEBPACK_IMPORTED_MODULE_385__.collectAllRenderables),
/* harmony export */   collectRenderablesMixin: () => (/* reexport safe */ _scene_container_container_mixins_collectRenderablesMixin_mjs__WEBPACK_IMPORTED_MODULE_367__.collectRenderablesMixin),
/* harmony export */   color32BitToUniform: () => (/* reexport safe */ _scene_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_396__.color32BitToUniform),
/* harmony export */   colorBit: () => (/* reexport safe */ _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_178__.colorBit),
/* harmony export */   colorBitGl: () => (/* reexport safe */ _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_178__.colorBitGl),
/* harmony export */   colorMatrixFilterFrag: () => (/* reexport safe */ _filters_defaults_color_matrix_colorMatrixFilter_frag_mjs__WEBPACK_IMPORTED_MODULE_108__["default"]),
/* harmony export */   colorMatrixFilterWgsl: () => (/* reexport safe */ _filters_defaults_color_matrix_colorMatrixFilter_wgsl_mjs__WEBPACK_IMPORTED_MODULE_109__["default"]),
/* harmony export */   colorToUniform: () => (/* reexport safe */ _scene_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_396__.colorToUniform),
/* harmony export */   compareModeToGlCompare: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_253__.compareModeToGlCompare),
/* harmony export */   compileHighShader: () => (/* reexport safe */ _rendering_high_shader_compiler_compileHighShader_mjs__WEBPACK_IMPORTED_MODULE_170__.compileHighShader),
/* harmony export */   compileHighShaderGl: () => (/* reexport safe */ _rendering_high_shader_compiler_compileHighShader_mjs__WEBPACK_IMPORTED_MODULE_170__.compileHighShaderGl),
/* harmony export */   compileHighShaderGlProgram: () => (/* reexport safe */ _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_169__.compileHighShaderGlProgram),
/* harmony export */   compileHighShaderGpuProgram: () => (/* reexport safe */ _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_169__.compileHighShaderGpuProgram),
/* harmony export */   compileHooks: () => (/* reexport safe */ _rendering_high_shader_compiler_utils_compileHooks_mjs__WEBPACK_IMPORTED_MODULE_172__.compileHooks),
/* harmony export */   compileInputs: () => (/* reexport safe */ _rendering_high_shader_compiler_utils_compileInputs_mjs__WEBPACK_IMPORTED_MODULE_173__.compileInputs),
/* harmony export */   compileOutputs: () => (/* reexport safe */ _rendering_high_shader_compiler_utils_compileOutputs_mjs__WEBPACK_IMPORTED_MODULE_174__.compileOutputs),
/* harmony export */   compileShader: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_compileShader_mjs__WEBPACK_IMPORTED_MODULE_217__.compileShader),
/* harmony export */   compute2DProjection: () => (/* reexport safe */ _scene_mesh_perspective_utils_compute2DProjections_mjs__WEBPACK_IMPORTED_MODULE_436__.compute2DProjection),
/* harmony export */   convertFormatIfRequired: () => (/* reexport safe */ _compressed_textures_ktx2_utils_convertFormatIfRequired_mjs__WEBPACK_IMPORTED_MODULE_74__.convertFormatIfRequired),
/* harmony export */   convertToList: () => (/* reexport safe */ _assets_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_56__.convertToList),
/* harmony export */   copySearchParams: () => (/* reexport safe */ _assets_utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_57__.copySearchParams),
/* harmony export */   createIdFromString: () => (/* reexport safe */ _rendering_renderers_shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_352__.createIdFromString),
/* harmony export */   createIndicesForQuads: () => (/* reexport safe */ _scene_particle_container_shared_utils_createIndicesForQuads_mjs__WEBPACK_IMPORTED_MODULE_459__.createIndicesForQuads),
/* harmony export */   createLevelBuffers: () => (/* reexport safe */ _compressed_textures_basis_utils_createLevelBuffers_mjs__WEBPACK_IMPORTED_MODULE_63__.createLevelBuffers),
/* harmony export */   createLevelBuffersFromKTX: () => (/* reexport safe */ _compressed_textures_ktx2_utils_createLevelBuffersFromKTX_mjs__WEBPACK_IMPORTED_MODULE_75__.createLevelBuffersFromKTX),
/* harmony export */   createStringVariations: () => (/* reexport safe */ _assets_utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_58__.createStringVariations),
/* harmony export */   createTexture: () => (/* reexport safe */ _assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_49__.createTexture),
/* harmony export */   createUboElementsSTD40: () => (/* reexport safe */ _rendering_renderers_gl_shader_utils_createUboElementsSTD40_mjs__WEBPACK_IMPORTED_MODULE_234__.createUboElementsSTD40),
/* harmony export */   createUboElementsWGSL: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_createUboElementsWGSL_mjs__WEBPACK_IMPORTED_MODULE_274__.createUboElementsWGSL),
/* harmony export */   createUboSyncFunction: () => (/* reexport safe */ _rendering_renderers_shared_shader_utils_createUboSyncFunction_mjs__WEBPACK_IMPORTED_MODULE_320__.createUboSyncFunction),
/* harmony export */   createUboSyncFunctionSTD40: () => (/* reexport safe */ _rendering_renderers_gl_shader_utils_createUboSyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_235__.createUboSyncFunctionSTD40),
/* harmony export */   createUboSyncFunctionWGSL: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_createUboSyncFunctionWGSL_mjs__WEBPACK_IMPORTED_MODULE_275__.createUboSyncFunctionWGSL),
/* harmony export */   crossOrigin: () => (/* reexport safe */ _assets_loader_parsers_textures_loadVideoTextures_mjs__WEBPACK_IMPORTED_MODULE_48__.crossOrigin),
/* harmony export */   cullingMixin: () => (/* reexport safe */ _culling_cullingMixin_mjs__WEBPACK_IMPORTED_MODULE_86__.cullingMixin),
/* harmony export */   curveEps: () => (/* reexport safe */ _scene_graphics_shared_const_mjs__WEBPACK_IMPORTED_MODULE_410__.curveEps),
/* harmony export */   defaultFilterVert: () => (/* reexport safe */ _filters_defaults_defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_110__["default"]),
/* harmony export */   defaultValue: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_defaultValue_mjs__WEBPACK_IMPORTED_MODULE_218__.defaultValue),
/* harmony export */   definedProps: () => (/* reexport safe */ _scene_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_386__.definedProps),
/* harmony export */   deprecation: () => (/* reexport safe */ _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_538__.deprecation),
/* harmony export */   detectAvif: () => (/* reexport safe */ _assets_detections_parsers_detectAvif_mjs__WEBPACK_IMPORTED_MODULE_33__.detectAvif),
/* harmony export */   detectBasis: () => (/* reexport safe */ _compressed_textures_basis_detectBasis_mjs__WEBPACK_IMPORTED_MODULE_61__.detectBasis),
/* harmony export */   detectCompressed: () => (/* reexport safe */ _compressed_textures_shared_detectCompressed_mjs__WEBPACK_IMPORTED_MODULE_82__.detectCompressed),
/* harmony export */   detectDefaults: () => (/* reexport safe */ _assets_detections_parsers_detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_34__.detectDefaults),
/* harmony export */   detectMp4: () => (/* reexport safe */ _assets_detections_parsers_detectMp4_mjs__WEBPACK_IMPORTED_MODULE_35__.detectMp4),
/* harmony export */   detectOgv: () => (/* reexport safe */ _assets_detections_parsers_detectOgv_mjs__WEBPACK_IMPORTED_MODULE_36__.detectOgv),
/* harmony export */   detectVideoAlphaMode: () => (/* reexport safe */ _utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_523__.detectVideoAlphaMode),
/* harmony export */   detectWebm: () => (/* reexport safe */ _assets_detections_parsers_detectWebm_mjs__WEBPACK_IMPORTED_MODULE_37__.detectWebm),
/* harmony export */   detectWebp: () => (/* reexport safe */ _assets_detections_parsers_detectWebp_mjs__WEBPACK_IMPORTED_MODULE_38__.detectWebp),
/* harmony export */   determineCrossOrigin: () => (/* reexport safe */ _assets_loader_parsers_textures_loadVideoTextures_mjs__WEBPACK_IMPORTED_MODULE_48__.determineCrossOrigin),
/* harmony export */   displacementFrag: () => (/* reexport safe */ _filters_defaults_displacement_displacement_frag_mjs__WEBPACK_IMPORTED_MODULE_111__["default"]),
/* harmony export */   displacementVert: () => (/* reexport safe */ _filters_defaults_displacement_displacement_vert_mjs__WEBPACK_IMPORTED_MODULE_112__["default"]),
/* harmony export */   displacementWgsl: () => (/* reexport safe */ _filters_defaults_displacement_displacement_wgsl_mjs__WEBPACK_IMPORTED_MODULE_113__["default"]),
/* harmony export */   earcut: () => (/* reexport default export from named module */ earcut__WEBPACK_IMPORTED_MODULE_549__),
/* harmony export */   effectsMixin: () => (/* reexport safe */ _scene_container_container_mixins_effectsMixin_mjs__WEBPACK_IMPORTED_MODULE_368__.effectsMixin),
/* harmony export */   ensureAttributes: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_ensureAttributes_mjs__WEBPACK_IMPORTED_MODULE_219__.ensureAttributes),
/* harmony export */   ensureIsBuffer: () => (/* reexport safe */ _rendering_renderers_shared_geometry_utils_ensureIsBuffer_mjs__WEBPACK_IMPORTED_MODULE_304__.ensureIsBuffer),
/* harmony export */   ensurePrecision: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_preprocessors_ensurePrecision_mjs__WEBPACK_IMPORTED_MODULE_230__.ensurePrecision),
/* harmony export */   ensureTextOptions: () => (/* reexport safe */ _scene_text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_502__.ensureTextOptions),
/* harmony export */   ensureTextStyle: () => (/* reexport safe */ _scene_text_utils_ensureTextStyle_mjs__WEBPACK_IMPORTED_MODULE_513__.ensureTextStyle),
/* harmony export */   executeInstructions: () => (/* reexport safe */ _scene_container_utils_executeInstructions_mjs__WEBPACK_IMPORTED_MODULE_387__.executeInstructions),
/* harmony export */   extensions: () => (/* reexport safe */ _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions),
/* harmony export */   extractAttributesFromGlProgram: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_extractAttributesFromGlProgram_mjs__WEBPACK_IMPORTED_MODULE_220__.extractAttributesFromGlProgram),
/* harmony export */   extractAttributesFromGpuProgram: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_extractAttributesFromGpuProgram_mjs__WEBPACK_IMPORTED_MODULE_276__.extractAttributesFromGpuProgram),
/* harmony export */   extractFontFamilies: () => (/* reexport safe */ _scene_text_html_utils_extractFontFamilies_mjs__WEBPACK_IMPORTED_MODULE_493__.extractFontFamilies),
/* harmony export */   extractStructAndGroups: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_extractStructAndGroups_mjs__WEBPACK_IMPORTED_MODULE_277__.extractStructAndGroups),
/* harmony export */   extractSvgUrlId: () => (/* reexport safe */ _scene_graphics_shared_svg_utils_extractSvgUrlId_mjs__WEBPACK_IMPORTED_MODULE_425__.extractSvgUrlId),
/* harmony export */   fastCopy: () => (/* reexport safe */ _rendering_renderers_shared_buffer_utils_fastCopy_mjs__WEBPACK_IMPORTED_MODULE_298__.fastCopy),
/* harmony export */   findHooksRx: () => (/* reexport safe */ _rendering_high_shader_compiler_utils_compileHooks_mjs__WEBPACK_IMPORTED_MODULE_172__.findHooksRx),
/* harmony export */   findMixin: () => (/* reexport safe */ _scene_container_container_mixins_findMixin_mjs__WEBPACK_IMPORTED_MODULE_369__.findMixin),
/* harmony export */   fontStringFromTextStyle: () => (/* reexport safe */ _scene_text_canvas_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_506__.fontStringFromTextStyle),
/* harmony export */   formatShader: () => (/* reexport safe */ _rendering_high_shader_compiler_utils_formatShader_mjs__WEBPACK_IMPORTED_MODULE_175__.formatShader),
/* harmony export */   fragmentGPUTemplate: () => (/* reexport safe */ _rendering_high_shader_defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_177__.fragmentGPUTemplate),
/* harmony export */   fragmentGlTemplate: () => (/* reexport safe */ _rendering_high_shader_defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_177__.fragmentGlTemplate),
/* harmony export */   generateArraySyncSTD40: () => (/* reexport safe */ _rendering_renderers_gl_shader_utils_generateArraySyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_236__.generateArraySyncSTD40),
/* harmony export */   generateArraySyncWGSL: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_generateArraySyncWGSL_mjs__WEBPACK_IMPORTED_MODULE_278__.generateArraySyncWGSL),
/* harmony export */   generateBlurFragSource: () => (/* reexport safe */ _filters_defaults_blur_gl_generateBlurFragSource_mjs__WEBPACK_IMPORTED_MODULE_126__.generateBlurFragSource),
/* harmony export */   generateBlurGlProgram: () => (/* reexport safe */ _filters_defaults_blur_gl_generateBlurGlProgram_mjs__WEBPACK_IMPORTED_MODULE_127__.generateBlurGlProgram),
/* harmony export */   generateBlurProgram: () => (/* reexport safe */ _filters_defaults_blur_gpu_generateBlurProgram_mjs__WEBPACK_IMPORTED_MODULE_129__.generateBlurProgram),
/* harmony export */   generateBlurVertSource: () => (/* reexport safe */ _filters_defaults_blur_gl_generateBlurVertSource_mjs__WEBPACK_IMPORTED_MODULE_128__.generateBlurVertSource),
/* harmony export */   generateGPULayout: () => (/* reexport safe */ _rendering_batcher_gpu_generateGPULayout_mjs__WEBPACK_IMPORTED_MODULE_159__.generateGPULayout),
/* harmony export */   generateGpuLayoutGroups: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_generateGpuLayoutGroups_mjs__WEBPACK_IMPORTED_MODULE_279__.generateGpuLayoutGroups),
/* harmony export */   generateLayout: () => (/* reexport safe */ _rendering_batcher_gpu_generateLayout_mjs__WEBPACK_IMPORTED_MODULE_160__.generateLayout),
/* harmony export */   generateLayoutHash: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_generateLayoutHash_mjs__WEBPACK_IMPORTED_MODULE_280__.generateLayoutHash),
/* harmony export */   generateParticleUpdateFunction: () => (/* reexport safe */ _scene_particle_container_shared_utils_generateParticleUpdateFunction_mjs__WEBPACK_IMPORTED_MODULE_460__.generateParticleUpdateFunction),
/* harmony export */   generateProgram: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_221__.generateProgram),
/* harmony export */   generateShaderSyncCode: () => (/* reexport safe */ _rendering_renderers_gl_shader_GenerateShaderSyncCode_mjs__WEBPACK_IMPORTED_MODULE_210__.generateShaderSyncCode),
/* harmony export */   generateTextStyleKey: () => (/* reexport safe */ _scene_text_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_514__.generateTextStyleKey),
/* harmony export */   generateTextureBatchBit: () => (/* reexport safe */ _rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_179__.generateTextureBatchBit),
/* harmony export */   generateTextureBatchBitGl: () => (/* reexport safe */ _rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_179__.generateTextureBatchBitGl),
/* harmony export */   generateTextureMatrix: () => (/* reexport safe */ _scene_graphics_shared_utils_generateTextureFillMatrix_mjs__WEBPACK_IMPORTED_MODULE_429__.generateTextureMatrix),
/* harmony export */   generateUID: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_generateUID_mjs__WEBPACK_IMPORTED_MODULE_347__.generateUID),
/* harmony export */   generateUniformsSync: () => (/* reexport safe */ _rendering_renderers_gl_shader_utils_generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_237__.generateUniformsSync),
/* harmony export */   getAdjustedBlendModeBlend: () => (/* reexport safe */ _rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_326__.getAdjustedBlendModeBlend),
/* harmony export */   getAttributeInfoFromFormat: () => (/* reexport safe */ _rendering_renderers_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_305__.getAttributeInfoFromFormat),
/* harmony export */   getBatchSamplersUniformGroup: () => (/* reexport safe */ _rendering_renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_211__.getBatchSamplersUniformGroup),
/* harmony export */   getBitmapTextLayout: () => (/* reexport safe */ _scene_text_bitmap_utils_getBitmapTextLayout_mjs__WEBPACK_IMPORTED_MODULE_486__.getBitmapTextLayout),
/* harmony export */   getCanvasBoundingBox: () => (/* reexport safe */ _utils_canvas_getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_529__.getCanvasBoundingBox),
/* harmony export */   getCanvasFillStyle: () => (/* reexport safe */ _scene_text_canvas_utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_507__.getCanvasFillStyle),
/* harmony export */   getCanvasTexture: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_getCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_348__.getCanvasTexture),
/* harmony export */   getDefaultUniformValue: () => (/* reexport safe */ _rendering_renderers_shared_shader_utils_getDefaultUniformValue_mjs__WEBPACK_IMPORTED_MODULE_321__.getDefaultUniformValue),
/* harmony export */   getFastGlobalBounds: () => (/* reexport safe */ _scene_container_bounds_getFastGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_360__.getFastGlobalBounds),
/* harmony export */   getFastGlobalBoundsMixin: () => (/* reexport safe */ _scene_container_container_mixins_getFastGlobalBoundsMixin_mjs__WEBPACK_IMPORTED_MODULE_370__.getFastGlobalBoundsMixin),
/* harmony export */   getFontCss: () => (/* reexport safe */ _scene_text_html_utils_getFontCss_mjs__WEBPACK_IMPORTED_MODULE_494__.getFontCss),
/* harmony export */   getFontFamilyName: () => (/* reexport safe */ _assets_loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_45__.getFontFamilyName),
/* harmony export */   getGeometryBounds: () => (/* reexport safe */ _rendering_renderers_shared_geometry_utils_getGeometryBounds_mjs__WEBPACK_IMPORTED_MODULE_306__.getGeometryBounds),
/* harmony export */   getGlTypeFromFormat: () => (/* reexport safe */ _rendering_renderers_gl_geometry_utils_getGlTypeFromFormat_mjs__WEBPACK_IMPORTED_MODULE_201__.getGlTypeFromFormat),
/* harmony export */   getGlobalBounds: () => (/* reexport safe */ _scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_361__.getGlobalBounds),
/* harmony export */   getGlobalMixin: () => (/* reexport safe */ _scene_container_container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_371__.getGlobalMixin),
/* harmony export */   getGlobalRenderableBounds: () => (/* reexport safe */ _scene_container_bounds_getRenderableBounds_mjs__WEBPACK_IMPORTED_MODULE_363__.getGlobalRenderableBounds),
/* harmony export */   getLocalBounds: () => (/* reexport safe */ _scene_container_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_362__.getLocalBounds),
/* harmony export */   getMatrixRelativeToParent: () => (/* reexport safe */ _rendering_mask_utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_193__.getMatrixRelativeToParent),
/* harmony export */   getMaxFragmentPrecision: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_222__.getMaxFragmentPrecision),
/* harmony export */   getMaxTexturesPerBatch: () => (/* reexport safe */ _rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_158__.getMaxTexturesPerBatch),
/* harmony export */   getOrientationOfPoints: () => (/* reexport safe */ _scene_graphics_shared_utils_getOrientationOfPoints_mjs__WEBPACK_IMPORTED_MODULE_430__.getOrientationOfPoints),
/* harmony export */   getParent: () => (/* reexport safe */ _scene_container_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_362__.getParent),
/* harmony export */   getPo2TextureFromSource: () => (/* reexport safe */ _scene_text_utils_getPo2TextureFromSource_mjs__WEBPACK_IMPORTED_MODULE_515__.getPo2TextureFromSource),
/* harmony export */   getResolutionOfUrl: () => (/* reexport safe */ _utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_544__.getResolutionOfUrl),
/* harmony export */   getSVGUrl: () => (/* reexport safe */ _scene_text_html_utils_getSVGUrl_mjs__WEBPACK_IMPORTED_MODULE_495__.getSVGUrl),
/* harmony export */   getSupportedCompressedTextureFormats: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_getSupportedCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_349__.getSupportedCompressedTextureFormats),
/* harmony export */   getSupportedGPUCompressedTextureFormats: () => (/* reexport safe */ _rendering_renderers_gpu_texture_utils_getSupportedGPUCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_290__.getSupportedGPUCompressedTextureFormats),
/* harmony export */   getSupportedGlCompressedTextureFormats: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_getSupportedGlCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_249__.getSupportedGlCompressedTextureFormats),
/* harmony export */   getSupportedTextureFormats: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_350__.getSupportedTextureFormats),
/* harmony export */   getTemporaryCanvasFromImage: () => (/* reexport safe */ _scene_text_html_utils_getTemporaryCanvasFromImage_mjs__WEBPACK_IMPORTED_MODULE_496__.getTemporaryCanvasFromImage),
/* harmony export */   getTestContext: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_223__.getTestContext),
/* harmony export */   getTextureBatchBindGroup: () => (/* reexport safe */ _rendering_batcher_gpu_getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_161__.getTextureBatchBindGroup),
/* harmony export */   getTextureDefaultMatrix: () => (/* reexport safe */ _scene_mesh_shared_getTextureDefaultMatrix_mjs__WEBPACK_IMPORTED_MODULE_445__.getTextureDefaultMatrix),
/* harmony export */   getTextureFormatFromKTXTexture: () => (/* reexport safe */ _compressed_textures_ktx2_utils_getTextureFormatFromKTXTexture_mjs__WEBPACK_IMPORTED_MODULE_76__.getTextureFormatFromKTXTexture),
/* harmony export */   getUboData: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_getUboData_mjs__WEBPACK_IMPORTED_MODULE_224__.getUboData),
/* harmony export */   getUniformData: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_getUniformData_mjs__WEBPACK_IMPORTED_MODULE_225__.getUniformData),
/* harmony export */   getUrlExtension: () => (/* reexport safe */ _assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_53__.getUrlExtension),
/* harmony export */   glFormatToGPUFormat: () => (/* reexport safe */ _compressed_textures_ktx2_utils_glFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_77__.glFormatToGPUFormat),
/* harmony export */   glUploadBufferImageResource: () => (/* reexport safe */ _rendering_renderers_gl_texture_uploaders_glUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_244__.glUploadBufferImageResource),
/* harmony export */   glUploadCompressedTextureResource: () => (/* reexport safe */ _rendering_renderers_gl_texture_uploaders_glUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_245__.glUploadCompressedTextureResource),
/* harmony export */   glUploadImageResource: () => (/* reexport safe */ _rendering_renderers_gl_texture_uploaders_glUploadImageResource_mjs__WEBPACK_IMPORTED_MODULE_246__.glUploadImageResource),
/* harmony export */   glUploadVideoResource: () => (/* reexport safe */ _rendering_renderers_gl_texture_uploaders_glUploadVideoResource_mjs__WEBPACK_IMPORTED_MODULE_247__.glUploadVideoResource),
/* harmony export */   globalUniformsBit: () => (/* reexport safe */ _rendering_high_shader_shader_bits_globalUniformsBit_mjs__WEBPACK_IMPORTED_MODULE_180__.globalUniformsBit),
/* harmony export */   globalUniformsBitGl: () => (/* reexport safe */ _rendering_high_shader_shader_bits_globalUniformsBit_mjs__WEBPACK_IMPORTED_MODULE_180__.globalUniformsBitGl),
/* harmony export */   globalUniformsUBOBitGl: () => (/* reexport safe */ _rendering_high_shader_shader_bits_globalUniformsBit_mjs__WEBPACK_IMPORTED_MODULE_180__.globalUniformsUBOBitGl),
/* harmony export */   gpuFormatToBasisTranscoderFormat: () => (/* reexport safe */ _compressed_textures_basis_utils_gpuFormatToBasisTranscoderFormat_mjs__WEBPACK_IMPORTED_MODULE_64__.gpuFormatToBasisTranscoderFormat),
/* harmony export */   gpuFormatToKTXBasisTranscoderFormat: () => (/* reexport safe */ _compressed_textures_ktx2_utils_gpuFormatToKTXBasisTranscoderFormat_mjs__WEBPACK_IMPORTED_MODULE_78__.gpuFormatToKTXBasisTranscoderFormat),
/* harmony export */   gpuUploadBufferImageResource: () => (/* reexport safe */ _rendering_renderers_gpu_texture_uploaders_gpuUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_286__.gpuUploadBufferImageResource),
/* harmony export */   gpuUploadCompressedTextureResource: () => (/* reexport safe */ _rendering_renderers_gpu_texture_uploaders_gpuUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_287__.gpuUploadCompressedTextureResource),
/* harmony export */   gpuUploadImageResource: () => (/* reexport safe */ _rendering_renderers_gpu_texture_uploaders_gpuUploadImageSource_mjs__WEBPACK_IMPORTED_MODULE_288__.gpuUploadImageResource),
/* harmony export */   gpuUploadVideoResource: () => (/* reexport safe */ _rendering_renderers_gpu_texture_uploaders_gpuUploadVideoSource_mjs__WEBPACK_IMPORTED_MODULE_289__.gpuUploadVideoResource),
/* harmony export */   groupD8: () => (/* reexport safe */ _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_138__.groupD8),
/* harmony export */   hasCachedCanvasTexture: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_getCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_348__.hasCachedCanvasTexture),
/* harmony export */   hslWgsl: () => (/* reexport safe */ _filters_blend_modes_hsl_wgsl_mjs__WEBPACK_IMPORTED_MODULE_104__["default"]),
/* harmony export */   hslgl: () => (/* reexport safe */ _filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_120__.hslgl),
/* harmony export */   hslgpu: () => (/* reexport safe */ _filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_121__.hslgpu),
/* harmony export */   injectBits: () => (/* reexport safe */ _rendering_high_shader_compiler_utils_injectBits_mjs__WEBPACK_IMPORTED_MODULE_176__.injectBits),
/* harmony export */   insertVersion: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_preprocessors_insertVersion_mjs__WEBPACK_IMPORTED_MODULE_231__.insertVersion),
/* harmony export */   isMobile: () => (/* reexport safe */ _utils_browser_isMobile_mjs__WEBPACK_IMPORTED_MODULE_524__.isMobile),
/* harmony export */   isPow2: () => (/* reexport safe */ _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_141__.isPow2),
/* harmony export */   isRenderingToScreen: () => (/* reexport safe */ _rendering_renderers_shared_renderTarget_isRenderingToScreen_mjs__WEBPACK_IMPORTED_MODULE_310__.isRenderingToScreen),
/* harmony export */   isSafari: () => (/* reexport safe */ _utils_browser_isSafari_mjs__WEBPACK_IMPORTED_MODULE_525__.isSafari),
/* harmony export */   isSingleItem: () => (/* reexport safe */ _assets_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_59__.isSingleItem),
/* harmony export */   isWebGLSupported: () => (/* reexport safe */ _utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_526__.isWebGLSupported),
/* harmony export */   isWebGPUSupported: () => (/* reexport safe */ _utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_527__.isWebGPUSupported),
/* harmony export */   ktxTranscoderUrls: () => (/* reexport safe */ _compressed_textures_ktx2_utils_setKTXTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_79__.ktxTranscoderUrls),
/* harmony export */   loadBasis: () => (/* reexport safe */ _compressed_textures_basis_loadBasis_mjs__WEBPACK_IMPORTED_MODULE_62__.loadBasis),
/* harmony export */   loadBasisOnWorker: () => (/* reexport safe */ _compressed_textures_basis_worker_loadBasisOnWorker_mjs__WEBPACK_IMPORTED_MODULE_66__.loadBasisOnWorker),
/* harmony export */   loadBitmapFont: () => (/* reexport safe */ _scene_text_bitmap_asset_loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_480__.loadBitmapFont),
/* harmony export */   loadDDS: () => (/* reexport safe */ _compressed_textures_dds_loadDDS_mjs__WEBPACK_IMPORTED_MODULE_68__.loadDDS),
/* harmony export */   loadEnvironmentExtensions: () => (/* reexport safe */ _environment_autoDetectEnvironment_mjs__WEBPACK_IMPORTED_MODULE_90__.loadEnvironmentExtensions),
/* harmony export */   loadFontAsBase64: () => (/* reexport safe */ _scene_text_html_utils_loadFontAsBase64_mjs__WEBPACK_IMPORTED_MODULE_497__.loadFontAsBase64),
/* harmony export */   loadFontCSS: () => (/* reexport safe */ _scene_text_html_utils_loadFontCSS_mjs__WEBPACK_IMPORTED_MODULE_498__.loadFontCSS),
/* harmony export */   loadImageBitmap: () => (/* reexport safe */ _assets_loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_47__.loadImageBitmap),
/* harmony export */   loadJson: () => (/* reexport safe */ _assets_loader_parsers_loadJson_mjs__WEBPACK_IMPORTED_MODULE_43__.loadJson),
/* harmony export */   loadKTX: () => (/* reexport safe */ _compressed_textures_ktx_loadKTX_mjs__WEBPACK_IMPORTED_MODULE_70__.loadKTX),
/* harmony export */   loadKTX2: () => (/* reexport safe */ _compressed_textures_ktx2_loadKTX2_mjs__WEBPACK_IMPORTED_MODULE_73__.loadKTX2),
/* harmony export */   loadKTX2onWorker: () => (/* reexport safe */ _compressed_textures_ktx2_worker_loadKTX2onWorker_mjs__WEBPACK_IMPORTED_MODULE_81__.loadKTX2onWorker),
/* harmony export */   loadSVGImage: () => (/* reexport safe */ _scene_text_html_utils_loadSVGImage_mjs__WEBPACK_IMPORTED_MODULE_499__.loadSVGImage),
/* harmony export */   loadSvg: () => (/* reexport safe */ _assets_loader_parsers_textures_loadSVG_mjs__WEBPACK_IMPORTED_MODULE_46__.loadSvg),
/* harmony export */   loadTextures: () => (/* reexport safe */ _assets_loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_47__.loadTextures),
/* harmony export */   loadTxt: () => (/* reexport safe */ _assets_loader_parsers_loadTxt_mjs__WEBPACK_IMPORTED_MODULE_44__.loadTxt),
/* harmony export */   loadVideoTextures: () => (/* reexport safe */ _assets_loader_parsers_textures_loadVideoTextures_mjs__WEBPACK_IMPORTED_MODULE_48__.loadVideoTextures),
/* harmony export */   loadWebFont: () => (/* reexport safe */ _assets_loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_45__.loadWebFont),
/* harmony export */   localUniformBit: () => (/* reexport safe */ _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_181__.localUniformBit),
/* harmony export */   localUniformBitGl: () => (/* reexport safe */ _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_181__.localUniformBitGl),
/* harmony export */   localUniformBitGroup2: () => (/* reexport safe */ _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_181__.localUniformBitGroup2),
/* harmony export */   localUniformMSDFBit: () => (/* reexport safe */ _scene_text_sdfShader_shader_bits_localUniformMSDFBit_mjs__WEBPACK_IMPORTED_MODULE_509__.localUniformMSDFBit),
/* harmony export */   localUniformMSDFBitGl: () => (/* reexport safe */ _scene_text_sdfShader_shader_bits_localUniformMSDFBit_mjs__WEBPACK_IMPORTED_MODULE_509__.localUniformMSDFBitGl),
/* harmony export */   log2: () => (/* reexport safe */ _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_141__.log2),
/* harmony export */   logDebugTexture: () => (/* reexport safe */ _utils_logging_logDebugTexture_mjs__WEBPACK_IMPORTED_MODULE_539__.logDebugTexture),
/* harmony export */   logProgramError: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_logProgramError_mjs__WEBPACK_IMPORTED_MODULE_226__.logProgramError),
/* harmony export */   logRenderGroupScene: () => (/* reexport safe */ _utils_logging_logScene_mjs__WEBPACK_IMPORTED_MODULE_540__.logRenderGroupScene),
/* harmony export */   logScene: () => (/* reexport safe */ _utils_logging_logScene_mjs__WEBPACK_IMPORTED_MODULE_540__.logScene),
/* harmony export */   mSDFBit: () => (/* reexport safe */ _scene_text_sdfShader_shader_bits_mSDFBit_mjs__WEBPACK_IMPORTED_MODULE_510__.mSDFBit),
/* harmony export */   mSDFBitGl: () => (/* reexport safe */ _scene_text_sdfShader_shader_bits_mSDFBit_mjs__WEBPACK_IMPORTED_MODULE_510__.mSDFBitGl),
/* harmony export */   mapFormatToGlFormat: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_mapFormatToGlFormat_mjs__WEBPACK_IMPORTED_MODULE_250__.mapFormatToGlFormat),
/* harmony export */   mapFormatToGlInternalFormat: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_mapFormatToGlInternalFormat_mjs__WEBPACK_IMPORTED_MODULE_251__.mapFormatToGlInternalFormat),
/* harmony export */   mapFormatToGlType: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_mapFormatToGlType_mjs__WEBPACK_IMPORTED_MODULE_252__.mapFormatToGlType),
/* harmony export */   mapGlToVertexFormat: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_mapType_mjs__WEBPACK_IMPORTED_MODULE_228__.mapGlToVertexFormat),
/* harmony export */   mapSize: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_mapSize_mjs__WEBPACK_IMPORTED_MODULE_227__.mapSize),
/* harmony export */   mapType: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_mapType_mjs__WEBPACK_IMPORTED_MODULE_228__.mapType),
/* harmony export */   mapWebGLBlendModesToPixi: () => (/* reexport safe */ _rendering_renderers_gl_state_mapWebGLBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_240__.mapWebGLBlendModesToPixi),
/* harmony export */   maskFrag: () => (/* reexport safe */ _filters_mask_mask_frag_mjs__WEBPACK_IMPORTED_MODULE_116__["default"]),
/* harmony export */   maskVert: () => (/* reexport safe */ _filters_mask_mask_vert_mjs__WEBPACK_IMPORTED_MODULE_117__["default"]),
/* harmony export */   maskWgsl: () => (/* reexport safe */ _filters_mask_mask_wgsl_mjs__WEBPACK_IMPORTED_MODULE_118__["default"]),
/* harmony export */   matrixPool: () => (/* reexport safe */ _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_364__.matrixPool),
/* harmony export */   measureHtmlText: () => (/* reexport safe */ _scene_text_html_utils_measureHtmlText_mjs__WEBPACK_IMPORTED_MODULE_500__.measureHtmlText),
/* harmony export */   measureMixin: () => (/* reexport safe */ _scene_container_container_mixins_measureMixin_mjs__WEBPACK_IMPORTED_MODULE_372__.measureMixin),
/* harmony export */   migrateFragmentFromV7toV8: () => (/* reexport safe */ _rendering_renderers_gl_shader_migrateFragmentFromV7toV8_mjs__WEBPACK_IMPORTED_MODULE_216__.migrateFragmentFromV7toV8),
/* harmony export */   mipmapScaleModeToGlFilter: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_253__.mipmapScaleModeToGlFilter),
/* harmony export */   mixHexColors: () => (/* reexport safe */ _scene_container_utils_mixHexColors_mjs__WEBPACK_IMPORTED_MODULE_388__.mixHexColors),
/* harmony export */   multiplyColors: () => (/* reexport safe */ _scene_container_utils_multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_389__.multiplyColors),
/* harmony export */   multiplyHexColors: () => (/* reexport safe */ _scene_container_utils_multiplyHexColors_mjs__WEBPACK_IMPORTED_MODULE_390__.multiplyHexColors),
/* harmony export */   nextPow2: () => (/* reexport safe */ _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_141__.nextPow2),
/* harmony export */   noiseFrag: () => (/* reexport safe */ _filters_defaults_noise_noise_frag_mjs__WEBPACK_IMPORTED_MODULE_114__["default"]),
/* harmony export */   noiseWgsl: () => (/* reexport safe */ _filters_defaults_noise_noise_wgsl_mjs__WEBPACK_IMPORTED_MODULE_115__["default"]),
/* harmony export */   nonCompressedFormats: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_350__.nonCompressedFormats),
/* harmony export */   normalizeExtensionPriority: () => (/* reexport safe */ _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeExtensionPriority),
/* harmony export */   nssvg: () => (/* reexport safe */ _scene_text_html_HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_490__.nssvg),
/* harmony export */   nsxhtml: () => (/* reexport safe */ _scene_text_html_HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_490__.nsxhtml),
/* harmony export */   onRenderMixin: () => (/* reexport safe */ _scene_container_container_mixins_onRenderMixin_mjs__WEBPACK_IMPORTED_MODULE_373__.onRenderMixin),
/* harmony export */   parseAttribute: () => (/* reexport safe */ _scene_graphics_shared_svg_parseSVGStyle_mjs__WEBPACK_IMPORTED_MODULE_423__.parseAttribute),
/* harmony export */   parseDDS: () => (/* reexport safe */ _compressed_textures_dds_parseDDS_mjs__WEBPACK_IMPORTED_MODULE_69__.parseDDS),
/* harmony export */   parseFunctionBody: () => (/* reexport safe */ _rendering_renderers_shared_utils_parseFunctionBody_mjs__WEBPACK_IMPORTED_MODULE_353__.parseFunctionBody),
/* harmony export */   parseKTX: () => (/* reexport safe */ _compressed_textures_ktx_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_71__.parseKTX),
/* harmony export */   parseSVGDefinitions: () => (/* reexport safe */ _scene_graphics_shared_svg_parseSVGDefinitions_mjs__WEBPACK_IMPORTED_MODULE_420__.parseSVGDefinitions),
/* harmony export */   parseSVGFloatAttribute: () => (/* reexport safe */ _scene_graphics_shared_svg_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_421__.parseSVGFloatAttribute),
/* harmony export */   parseSVGPath: () => (/* reexport safe */ _scene_graphics_shared_svg_parseSVGPath_mjs__WEBPACK_IMPORTED_MODULE_422__.parseSVGPath),
/* harmony export */   parseSVGStyle: () => (/* reexport safe */ _scene_graphics_shared_svg_parseSVGStyle_mjs__WEBPACK_IMPORTED_MODULE_423__.parseSVGStyle),
/* harmony export */   particleData: () => (/* reexport safe */ _scene_particle_container_shared_particleData_mjs__WEBPACK_IMPORTED_MODULE_457__.particleData),
/* harmony export */   particlesFrag: () => (/* reexport safe */ _scene_particle_container_shared_shader_particles_frag_mjs__WEBPACK_IMPORTED_MODULE_356__["default"]),
/* harmony export */   particlesVert: () => (/* reexport safe */ _scene_particle_container_shared_shader_particles_vert_mjs__WEBPACK_IMPORTED_MODULE_357__["default"]),
/* harmony export */   particlesWgsl: () => (/* reexport safe */ _scene_particle_container_shared_shader_particles_wgsl_mjs__WEBPACK_IMPORTED_MODULE_358__["default"]),
/* harmony export */   path: () => (/* reexport safe */ _utils_path_mjs__WEBPACK_IMPORTED_MODULE_545__.path),
/* harmony export */   pointInTriangle: () => (/* reexport safe */ _maths_point_pointInTriangle_mjs__WEBPACK_IMPORTED_MODULE_145__.pointInTriangle),
/* harmony export */   preloadVideo: () => (/* reexport safe */ _assets_loader_parsers_textures_loadVideoTextures_mjs__WEBPACK_IMPORTED_MODULE_48__.preloadVideo),
/* harmony export */   removeItems: () => (/* reexport safe */ _utils_data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_533__.removeItems),
/* harmony export */   removeStructAndGroupDuplicates: () => (/* reexport safe */ _rendering_renderers_gpu_shader_utils_removeStructAndGroupDuplicates_mjs__WEBPACK_IMPORTED_MODULE_281__.removeStructAndGroupDuplicates),
/* harmony export */   resetUids: () => (/* reexport safe */ _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_534__.resetUids),
/* harmony export */   resolveCharacters: () => (/* reexport safe */ _scene_text_bitmap_utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_487__.resolveCharacters),
/* harmony export */   resolveCompressedTextureUrl: () => (/* reexport safe */ _compressed_textures_shared_resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_83__.resolveCompressedTextureUrl),
/* harmony export */   resolveJsonUrl: () => (/* reexport safe */ _assets_resolver_parsers_resolveJsonUrl_mjs__WEBPACK_IMPORTED_MODULE_51__.resolveJsonUrl),
/* harmony export */   resolveTextureUrl: () => (/* reexport safe */ _assets_resolver_parsers_resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_52__.resolveTextureUrl),
/* harmony export */   resourceToTexture: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_textureFrom_mjs__WEBPACK_IMPORTED_MODULE_351__.resourceToTexture),
/* harmony export */   roundPixelsBit: () => (/* reexport safe */ _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_182__.roundPixelsBit),
/* harmony export */   roundPixelsBitGl: () => (/* reexport safe */ _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_182__.roundPixelsBitGl),
/* harmony export */   roundedShapeArc: () => (/* reexport safe */ _scene_graphics_shared_path_roundShape_mjs__WEBPACK_IMPORTED_MODULE_418__.roundedShapeArc),
/* harmony export */   roundedShapeQuadraticCurve: () => (/* reexport safe */ _scene_graphics_shared_path_roundShape_mjs__WEBPACK_IMPORTED_MODULE_418__.roundedShapeQuadraticCurve),
/* harmony export */   sayHello: () => (/* reexport safe */ _utils_sayHello_mjs__WEBPACK_IMPORTED_MODULE_548__.sayHello),
/* harmony export */   scaleModeToGlFilter: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_253__.scaleModeToGlFilter),
/* harmony export */   setBasisTranscoderPath: () => (/* reexport safe */ _compressed_textures_basis_utils_setBasisTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_65__.setBasisTranscoderPath),
/* harmony export */   setKTXTranscoderPath: () => (/* reexport safe */ _compressed_textures_ktx2_utils_setKTXTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_79__.setKTXTranscoderPath),
/* harmony export */   setPositions: () => (/* reexport safe */ _scene_sprite_tiling_utils_setPositions_mjs__WEBPACK_IMPORTED_MODULE_471__.setPositions),
/* harmony export */   setProgramName: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_preprocessors_setProgramName_mjs__WEBPACK_IMPORTED_MODULE_232__.setProgramName),
/* harmony export */   setUvs: () => (/* reexport safe */ _scene_sprite_tiling_utils_setUvs_mjs__WEBPACK_IMPORTED_MODULE_472__.setUvs),
/* harmony export */   shapeBuilders: () => (/* reexport safe */ _scene_graphics_shared_utils_buildContextBatches_mjs__WEBPACK_IMPORTED_MODULE_426__.shapeBuilders),
/* harmony export */   sortMixin: () => (/* reexport safe */ _scene_container_container_mixins_sortMixin_mjs__WEBPACK_IMPORTED_MODULE_374__.sortMixin),
/* harmony export */   spritesheetAsset: () => (/* reexport safe */ _spritesheet_spritesheetAsset_mjs__WEBPACK_IMPORTED_MODULE_519__.spritesheetAsset),
/* harmony export */   squaredDistanceToLineSegment: () => (/* reexport safe */ _maths_misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_142__.squaredDistanceToLineSegment),
/* harmony export */   stripVersion: () => (/* reexport safe */ _rendering_renderers_gl_shader_program_preprocessors_stripVersion_mjs__WEBPACK_IMPORTED_MODULE_233__.stripVersion),
/* harmony export */   styleAttributes: () => (/* reexport safe */ _scene_graphics_shared_svg_parseSVGStyle_mjs__WEBPACK_IMPORTED_MODULE_423__.styleAttributes),
/* harmony export */   testImageFormat: () => (/* reexport safe */ _assets_detections_utils_testImageFormat_mjs__WEBPACK_IMPORTED_MODULE_39__.testImageFormat),
/* harmony export */   testVideoFormat: () => (/* reexport safe */ _assets_detections_utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_40__.testVideoFormat),
/* harmony export */   textStyleToCSS: () => (/* reexport safe */ _scene_text_html_utils_textStyleToCSS_mjs__WEBPACK_IMPORTED_MODULE_501__.textStyleToCSS),
/* harmony export */   textureBit: () => (/* reexport safe */ _rendering_high_shader_shader_bits_textureBit_mjs__WEBPACK_IMPORTED_MODULE_183__.textureBit),
/* harmony export */   textureBitGl: () => (/* reexport safe */ _rendering_high_shader_shader_bits_textureBit_mjs__WEBPACK_IMPORTED_MODULE_183__.textureBitGl),
/* harmony export */   textureFrom: () => (/* reexport safe */ _rendering_renderers_shared_texture_utils_textureFrom_mjs__WEBPACK_IMPORTED_MODULE_351__.textureFrom),
/* harmony export */   tilingBit: () => (/* reexport safe */ _scene_sprite_tiling_shader_tilingBit_mjs__WEBPACK_IMPORTED_MODULE_465__.tilingBit),
/* harmony export */   tilingBitGl: () => (/* reexport safe */ _scene_sprite_tiling_shader_tilingBit_mjs__WEBPACK_IMPORTED_MODULE_465__.tilingBitGl),
/* harmony export */   toFillStyle: () => (/* reexport safe */ _scene_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_428__.toFillStyle),
/* harmony export */   toLocalGlobalMixin: () => (/* reexport safe */ _scene_container_container_mixins_toLocalGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_375__.toLocalGlobalMixin),
/* harmony export */   toStrokeStyle: () => (/* reexport safe */ _scene_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_428__.toStrokeStyle),
/* harmony export */   transformVertices: () => (/* reexport safe */ _rendering_renderers_shared_geometry_utils_transformVertices_mjs__WEBPACK_IMPORTED_MODULE_307__.transformVertices),
/* harmony export */   triangulateWithHoles: () => (/* reexport safe */ _scene_graphics_shared_utils_triangulateWithHoles_mjs__WEBPACK_IMPORTED_MODULE_431__.triangulateWithHoles),
/* harmony export */   uboSyncFunctionsSTD40: () => (/* reexport safe */ _rendering_renderers_shared_shader_utils_uboSyncFunctions_mjs__WEBPACK_IMPORTED_MODULE_322__.uboSyncFunctionsSTD40),
/* harmony export */   uboSyncFunctionsWGSL: () => (/* reexport safe */ _rendering_renderers_shared_shader_utils_uboSyncFunctions_mjs__WEBPACK_IMPORTED_MODULE_322__.uboSyncFunctionsWGSL),
/* harmony export */   uid: () => (/* reexport safe */ _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_534__.uid),
/* harmony export */   uniformParsers: () => (/* reexport safe */ _rendering_renderers_shared_shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_323__.uniformParsers),
/* harmony export */   unpremultiplyAlpha: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_unpremultiplyAlpha_mjs__WEBPACK_IMPORTED_MODULE_254__.unpremultiplyAlpha),
/* harmony export */   unsafeEvalSupported: () => (/* reexport safe */ _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_528__.unsafeEvalSupported),
/* harmony export */   updateLocalTransform: () => (/* reexport safe */ _scene_container_utils_updateLocalTransform_mjs__WEBPACK_IMPORTED_MODULE_391__.updateLocalTransform),
/* harmony export */   updateQuadBounds: () => (/* reexport safe */ _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_535__.updateQuadBounds),
/* harmony export */   updateRenderGroupTransform: () => (/* reexport safe */ _scene_container_utils_updateRenderGroupTransforms_mjs__WEBPACK_IMPORTED_MODULE_392__.updateRenderGroupTransform),
/* harmony export */   updateRenderGroupTransforms: () => (/* reexport safe */ _scene_container_utils_updateRenderGroupTransforms_mjs__WEBPACK_IMPORTED_MODULE_392__.updateRenderGroupTransforms),
/* harmony export */   updateTextBounds: () => (/* reexport safe */ _scene_text_utils_updateTextBounds_mjs__WEBPACK_IMPORTED_MODULE_516__.updateTextBounds),
/* harmony export */   updateTransformAndChildren: () => (/* reexport safe */ _scene_container_utils_updateRenderGroupTransforms_mjs__WEBPACK_IMPORTED_MODULE_392__.updateTransformAndChildren),
/* harmony export */   updateTransformBackwards: () => (/* reexport safe */ _scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_361__.updateTransformBackwards),
/* harmony export */   updateWorldTransform: () => (/* reexport safe */ _scene_container_utils_updateWorldTransform_mjs__WEBPACK_IMPORTED_MODULE_393__.updateWorldTransform),
/* harmony export */   v8_0_0: () => (/* reexport safe */ _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_538__.v8_0_0),
/* harmony export */   v8_3_4: () => (/* reexport safe */ _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_538__.v8_3_4),
/* harmony export */   validFormats: () => (/* reexport safe */ _compressed_textures_shared_resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_83__.validFormats),
/* harmony export */   validateRenderables: () => (/* reexport safe */ _scene_container_utils_validateRenderables_mjs__WEBPACK_IMPORTED_MODULE_394__.validateRenderables),
/* harmony export */   vertexGPUTemplate: () => (/* reexport safe */ _rendering_high_shader_defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_177__.vertexGPUTemplate),
/* harmony export */   vertexGlTemplate: () => (/* reexport safe */ _rendering_high_shader_defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_177__.vertexGlTemplate),
/* harmony export */   viewportFromFrame: () => (/* reexport safe */ _rendering_renderers_shared_renderTarget_viewportFromFrame_mjs__WEBPACK_IMPORTED_MODULE_313__.viewportFromFrame),
/* harmony export */   vkFormatToGPUFormat: () => (/* reexport safe */ _compressed_textures_ktx2_utils_vkFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_80__.vkFormatToGPUFormat),
/* harmony export */   warn: () => (/* reexport safe */ _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_541__.warn),
/* harmony export */   webworkerExt: () => (/* reexport safe */ _environment_webworker_webworkerExt_mjs__WEBPACK_IMPORTED_MODULE_551__.webworkerExt),
/* harmony export */   wrapModeToGlAddress: () => (/* reexport safe */ _rendering_renderers_gl_texture_utils_pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_253__.wrapModeToGlAddress)
/* harmony export */ });
/* harmony import */ var _environment_browser_browserExt_mjs__WEBPACK_IMPORTED_MODULE_550__ = __webpack_require__(/*! ./environment-browser/browserExt.mjs */ "./node_modules/pixi.js/lib/environment-browser/browserExt.mjs");
/* harmony import */ var _environment_webworker_webworkerExt_mjs__WEBPACK_IMPORTED_MODULE_551__ = __webpack_require__(/*! ./environment-webworker/webworkerExt.mjs */ "./node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_init_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rendering/init.mjs */ "./node_modules/pixi.js/lib/rendering/init.mjs");
/* harmony import */ var _spritesheet_init_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./spritesheet/init.mjs */ "./node_modules/pixi.js/lib/spritesheet/init.mjs");
/* harmony import */ var _accessibility_AccessibilitySystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./accessibility/AccessibilitySystem.mjs */ "./node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs");
/* harmony import */ var _accessibility_accessibilityTarget_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./accessibility/accessibilityTarget.mjs */ "./node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs");
/* harmony import */ var _advanced_blend_modes_ColorBlend_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./advanced-blend-modes/ColorBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs");
/* harmony import */ var _advanced_blend_modes_ColorBurnBlend_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./advanced-blend-modes/ColorBurnBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs");
/* harmony import */ var _advanced_blend_modes_ColorDodgeBlend_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./advanced-blend-modes/ColorDodgeBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs");
/* harmony import */ var _advanced_blend_modes_DarkenBlend_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./advanced-blend-modes/DarkenBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs");
/* harmony import */ var _advanced_blend_modes_DifferenceBlend_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./advanced-blend-modes/DifferenceBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs");
/* harmony import */ var _advanced_blend_modes_DivideBlend_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./advanced-blend-modes/DivideBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs");
/* harmony import */ var _advanced_blend_modes_ExclusionBlend_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./advanced-blend-modes/ExclusionBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs");
/* harmony import */ var _advanced_blend_modes_HardLightBlend_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./advanced-blend-modes/HardLightBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs");
/* harmony import */ var _advanced_blend_modes_HardMixBlend_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./advanced-blend-modes/HardMixBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs");
/* harmony import */ var _advanced_blend_modes_LightenBlend_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./advanced-blend-modes/LightenBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs");
/* harmony import */ var _advanced_blend_modes_LinearBurnBlend_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./advanced-blend-modes/LinearBurnBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs");
/* harmony import */ var _advanced_blend_modes_LinearDodgeBlend_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./advanced-blend-modes/LinearDodgeBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs");
/* harmony import */ var _advanced_blend_modes_LinearLightBlend_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./advanced-blend-modes/LinearLightBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs");
/* harmony import */ var _advanced_blend_modes_LuminosityBlend_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./advanced-blend-modes/LuminosityBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs");
/* harmony import */ var _advanced_blend_modes_NegationBlend_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./advanced-blend-modes/NegationBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs");
/* harmony import */ var _advanced_blend_modes_OverlayBlend_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./advanced-blend-modes/OverlayBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs");
/* harmony import */ var _advanced_blend_modes_PinLightBlend_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./advanced-blend-modes/PinLightBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs");
/* harmony import */ var _advanced_blend_modes_SaturationBlend_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./advanced-blend-modes/SaturationBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs");
/* harmony import */ var _advanced_blend_modes_SoftLightBlend_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./advanced-blend-modes/SoftLightBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs");
/* harmony import */ var _advanced_blend_modes_SubtractBlend_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./advanced-blend-modes/SubtractBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs");
/* harmony import */ var _advanced_blend_modes_VividLightBlend_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./advanced-blend-modes/VividLightBlend.mjs */ "./node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs");
/* harmony import */ var _app_Application_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./app/Application.mjs */ "./node_modules/pixi.js/lib/app/Application.mjs");
/* harmony import */ var _app_ResizePlugin_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./app/ResizePlugin.mjs */ "./node_modules/pixi.js/lib/app/ResizePlugin.mjs");
/* harmony import */ var _app_TickerPlugin_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./app/TickerPlugin.mjs */ "./node_modules/pixi.js/lib/app/TickerPlugin.mjs");
/* harmony import */ var _assets_Assets_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./assets/Assets.mjs */ "./node_modules/pixi.js/lib/assets/Assets.mjs");
/* harmony import */ var _assets_BackgroundLoader_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./assets/BackgroundLoader.mjs */ "./node_modules/pixi.js/lib/assets/BackgroundLoader.mjs");
/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./assets/cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _assets_cache_parsers_cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./assets/cache/parsers/cacheTextureArray.mjs */ "./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs");
/* harmony import */ var _assets_detections_parsers_detectAvif_mjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./assets/detections/parsers/detectAvif.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs");
/* harmony import */ var _assets_detections_parsers_detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./assets/detections/parsers/detectDefaults.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs");
/* harmony import */ var _assets_detections_parsers_detectMp4_mjs__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./assets/detections/parsers/detectMp4.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs");
/* harmony import */ var _assets_detections_parsers_detectOgv_mjs__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./assets/detections/parsers/detectOgv.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs");
/* harmony import */ var _assets_detections_parsers_detectWebm_mjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./assets/detections/parsers/detectWebm.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs");
/* harmony import */ var _assets_detections_parsers_detectWebp_mjs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./assets/detections/parsers/detectWebp.mjs */ "./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs");
/* harmony import */ var _assets_detections_utils_testImageFormat_mjs__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./assets/detections/utils/testImageFormat.mjs */ "./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs");
/* harmony import */ var _assets_detections_utils_testVideoFormat_mjs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./assets/detections/utils/testVideoFormat.mjs */ "./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs");
/* harmony import */ var _assets_loader_Loader_mjs__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./assets/loader/Loader.mjs */ "./node_modules/pixi.js/lib/assets/loader/Loader.mjs");
/* harmony import */ var _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./assets/loader/parsers/LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _assets_loader_parsers_loadJson_mjs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./assets/loader/parsers/loadJson.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs");
/* harmony import */ var _assets_loader_parsers_loadTxt_mjs__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./assets/loader/parsers/loadTxt.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs");
/* harmony import */ var _assets_loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./assets/loader/parsers/loadWebFont.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs");
/* harmony import */ var _assets_loader_parsers_textures_loadSVG_mjs__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./assets/loader/parsers/textures/loadSVG.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs");
/* harmony import */ var _assets_loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./assets/loader/parsers/textures/loadTextures.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs");
/* harmony import */ var _assets_loader_parsers_textures_loadVideoTextures_mjs__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./assets/loader/parsers/textures/loadVideoTextures.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs");
/* harmony import */ var _assets_loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./assets/loader/parsers/textures/utils/createTexture.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs");
/* harmony import */ var _assets_loader_workers_WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./assets/loader/workers/WorkerManager.mjs */ "./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs");
/* harmony import */ var _assets_resolver_parsers_resolveJsonUrl_mjs__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./assets/resolver/parsers/resolveJsonUrl.mjs */ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs");
/* harmony import */ var _assets_resolver_parsers_resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./assets/resolver/parsers/resolveTextureUrl.mjs */ "./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs");
/* harmony import */ var _assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./assets/resolver/Resolver.mjs */ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs");
/* harmony import */ var _assets_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./assets/utils/checkDataUrl.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs");
/* harmony import */ var _assets_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./assets/utils/checkExtension.mjs */ "./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs");
/* harmony import */ var _assets_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./assets/utils/convertToList.mjs */ "./node_modules/pixi.js/lib/assets/utils/convertToList.mjs");
/* harmony import */ var _assets_utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./assets/utils/copySearchParams.mjs */ "./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs");
/* harmony import */ var _assets_utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./assets/utils/createStringVariations.mjs */ "./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs");
/* harmony import */ var _assets_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./assets/utils/isSingleItem.mjs */ "./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs");
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _compressed_textures_basis_detectBasis_mjs__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./compressed-textures/basis/detectBasis.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs");
/* harmony import */ var _compressed_textures_basis_loadBasis_mjs__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./compressed-textures/basis/loadBasis.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs");
/* harmony import */ var _compressed_textures_basis_utils_createLevelBuffers_mjs__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./compressed-textures/basis/utils/createLevelBuffers.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs");
/* harmony import */ var _compressed_textures_basis_utils_gpuFormatToBasisTranscoderFormat_mjs__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs");
/* harmony import */ var _compressed_textures_basis_utils_setBasisTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./compressed-textures/basis/utils/setBasisTranscoderPath.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs");
/* harmony import */ var _compressed_textures_basis_worker_loadBasisOnWorker_mjs__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./compressed-textures/basis/worker/loadBasisOnWorker.mjs */ "./node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs");
/* harmony import */ var _compressed_textures_dds_const_mjs__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./compressed-textures/dds/const.mjs */ "./node_modules/pixi.js/lib/compressed-textures/dds/const.mjs");
/* harmony import */ var _compressed_textures_dds_loadDDS_mjs__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./compressed-textures/dds/loadDDS.mjs */ "./node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs");
/* harmony import */ var _compressed_textures_dds_parseDDS_mjs__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./compressed-textures/dds/parseDDS.mjs */ "./node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs");
/* harmony import */ var _compressed_textures_ktx_loadKTX_mjs__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./compressed-textures/ktx/loadKTX.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs");
/* harmony import */ var _compressed_textures_ktx_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./compressed-textures/ktx/parseKTX.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs");
/* harmony import */ var _compressed_textures_ktx2_const_mjs__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./compressed-textures/ktx2/const.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs");
/* harmony import */ var _compressed_textures_ktx2_loadKTX2_mjs__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./compressed-textures/ktx2/loadKTX2.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs");
/* harmony import */ var _compressed_textures_ktx2_utils_convertFormatIfRequired_mjs__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./compressed-textures/ktx2/utils/convertFormatIfRequired.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs");
/* harmony import */ var _compressed_textures_ktx2_utils_createLevelBuffersFromKTX_mjs__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs");
/* harmony import */ var _compressed_textures_ktx2_utils_getTextureFormatFromKTXTexture_mjs__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs");
/* harmony import */ var _compressed_textures_ktx2_utils_glFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs");
/* harmony import */ var _compressed_textures_ktx2_utils_gpuFormatToKTXBasisTranscoderFormat_mjs__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs");
/* harmony import */ var _compressed_textures_ktx2_utils_setKTXTranscoderPath_mjs__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs");
/* harmony import */ var _compressed_textures_ktx2_utils_vkFormatToGPUFormat_mjs__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs");
/* harmony import */ var _compressed_textures_ktx2_worker_loadKTX2onWorker_mjs__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./compressed-textures/ktx2/worker/loadKTX2onWorker.mjs */ "./node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs");
/* harmony import */ var _compressed_textures_shared_detectCompressed_mjs__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./compressed-textures/shared/detectCompressed.mjs */ "./node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs");
/* harmony import */ var _compressed_textures_shared_resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./compressed-textures/shared/resolveCompressedTextureUrl.mjs */ "./node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs");
/* harmony import */ var _culling_Culler_mjs__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./culling/Culler.mjs */ "./node_modules/pixi.js/lib/culling/Culler.mjs");
/* harmony import */ var _culling_CullerPlugin_mjs__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./culling/CullerPlugin.mjs */ "./node_modules/pixi.js/lib/culling/CullerPlugin.mjs");
/* harmony import */ var _culling_cullingMixin_mjs__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./culling/cullingMixin.mjs */ "./node_modules/pixi.js/lib/culling/cullingMixin.mjs");
/* harmony import */ var _dom_DOMContainer_mjs__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./dom/DOMContainer.mjs */ "./node_modules/pixi.js/lib/dom/DOMContainer.mjs");
/* harmony import */ var _dom_DOMPipe_mjs__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./dom/DOMPipe.mjs */ "./node_modules/pixi.js/lib/dom/DOMPipe.mjs");
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _environment_autoDetectEnvironment_mjs__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./environment/autoDetectEnvironment.mjs */ "./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs");
/* harmony import */ var _environment_browser_BrowserAdapter_mjs__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./environment-browser/BrowserAdapter.mjs */ "./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs");
/* harmony import */ var _environment_webworker_WebWorkerAdapter_mjs__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./environment-webworker/WebWorkerAdapter.mjs */ "./node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs");
/* harmony import */ var _events_EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./events/EventBoundary.mjs */ "./node_modules/pixi.js/lib/events/EventBoundary.mjs");
/* harmony import */ var _events_EventSystem_mjs__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./events/EventSystem.mjs */ "./node_modules/pixi.js/lib/events/EventSystem.mjs");
/* harmony import */ var _events_EventTicker_mjs__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./events/EventTicker.mjs */ "./node_modules/pixi.js/lib/events/EventTicker.mjs");
/* harmony import */ var _events_FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./events/FederatedEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedEvent.mjs");
/* harmony import */ var _events_FederatedEventTarget_mjs__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./events/FederatedEventTarget.mjs */ "./node_modules/pixi.js/lib/events/FederatedEventTarget.mjs");
/* harmony import */ var _events_FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./events/FederatedMouseEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs");
/* harmony import */ var _events_FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./events/FederatedPointerEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs");
/* harmony import */ var _events_FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./events/FederatedWheelEvent.mjs */ "./node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs");
/* harmony import */ var _filters_blend_modes_blend_template_frag_mjs__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./filters/blend-modes/blend-template.frag.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs");
/* harmony import */ var _filters_blend_modes_blend_template_vert_mjs__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./filters/blend-modes/blend-template.vert.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs");
/* harmony import */ var _filters_blend_modes_blend_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./filters/blend-modes/blend-template.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs");
/* harmony import */ var _filters_blend_modes_hsl_wgsl_mjs__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./filters/blend-modes/hsl.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs");
/* harmony import */ var _filters_defaults_alpha_alpha_frag_mjs__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./filters/defaults/alpha/alpha.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs");
/* harmony import */ var _filters_defaults_alpha_alpha_wgsl_mjs__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./filters/defaults/alpha/alpha.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs");
/* harmony import */ var _filters_defaults_blur_gpu_blur_template_wgsl_mjs__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./filters/defaults/blur/gpu/blur-template.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs");
/* harmony import */ var _filters_defaults_color_matrix_colorMatrixFilter_frag_mjs__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./filters/defaults/color-matrix/colorMatrixFilter.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs");
/* harmony import */ var _filters_defaults_color_matrix_colorMatrixFilter_wgsl_mjs__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs");
/* harmony import */ var _filters_defaults_defaultFilter_vert_mjs__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./filters/defaults/defaultFilter.vert.mjs */ "./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs");
/* harmony import */ var _filters_defaults_displacement_displacement_frag_mjs__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./filters/defaults/displacement/displacement.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs");
/* harmony import */ var _filters_defaults_displacement_displacement_vert_mjs__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./filters/defaults/displacement/displacement.vert.mjs */ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs");
/* harmony import */ var _filters_defaults_displacement_displacement_wgsl_mjs__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./filters/defaults/displacement/displacement.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs");
/* harmony import */ var _filters_defaults_noise_noise_frag_mjs__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./filters/defaults/noise/noise.frag.mjs */ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs");
/* harmony import */ var _filters_defaults_noise_noise_wgsl_mjs__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./filters/defaults/noise/noise.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs");
/* harmony import */ var _filters_mask_mask_frag_mjs__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./filters/mask/mask.frag.mjs */ "./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs");
/* harmony import */ var _filters_mask_mask_vert_mjs__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./filters/mask/mask.vert.mjs */ "./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs");
/* harmony import */ var _filters_mask_mask_wgsl_mjs__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./filters/mask/mask.wgsl.mjs */ "./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs");
/* harmony import */ var _filters_blend_modes_BlendModeFilter_mjs__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./filters/blend-modes/BlendModeFilter.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs");
/* harmony import */ var _filters_blend_modes_hls_GLhls_mjs__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./filters/blend-modes/hls/GLhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs");
/* harmony import */ var _filters_blend_modes_hls_GPUhls_mjs__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./filters/blend-modes/hls/GPUhls.mjs */ "./node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs");
/* harmony import */ var _filters_defaults_alpha_AlphaFilter_mjs__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./filters/defaults/alpha/AlphaFilter.mjs */ "./node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs");
/* harmony import */ var _filters_defaults_blur_BlurFilter_mjs__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./filters/defaults/blur/BlurFilter.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs");
/* harmony import */ var _filters_defaults_blur_BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./filters/defaults/blur/BlurFilterPass.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs");
/* harmony import */ var _filters_defaults_blur_const_mjs__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./filters/defaults/blur/const.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/const.mjs");
/* harmony import */ var _filters_defaults_blur_gl_generateBlurFragSource_mjs__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./filters/defaults/blur/gl/generateBlurFragSource.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs");
/* harmony import */ var _filters_defaults_blur_gl_generateBlurGlProgram_mjs__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./filters/defaults/blur/gl/generateBlurGlProgram.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs");
/* harmony import */ var _filters_defaults_blur_gl_generateBlurVertSource_mjs__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./filters/defaults/blur/gl/generateBlurVertSource.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs");
/* harmony import */ var _filters_defaults_blur_gpu_generateBlurProgram_mjs__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./filters/defaults/blur/gpu/generateBlurProgram.mjs */ "./node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs");
/* harmony import */ var _filters_defaults_color_matrix_ColorMatrixFilter_mjs__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./filters/defaults/color-matrix/ColorMatrixFilter.mjs */ "./node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs");
/* harmony import */ var _filters_defaults_displacement_DisplacementFilter_mjs__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./filters/defaults/displacement/DisplacementFilter.mjs */ "./node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs");
/* harmony import */ var _filters_defaults_noise_NoiseFilter_mjs__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./filters/defaults/noise/NoiseFilter.mjs */ "./node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs");
/* harmony import */ var _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./filters/Filter.mjs */ "./node_modules/pixi.js/lib/filters/Filter.mjs");
/* harmony import */ var _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./filters/FilterEffect.mjs */ "./node_modules/pixi.js/lib/filters/FilterEffect.mjs");
/* harmony import */ var _filters_FilterPipe_mjs__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./filters/FilterPipe.mjs */ "./node_modules/pixi.js/lib/filters/FilterPipe.mjs");
/* harmony import */ var _filters_FilterSystem_mjs__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./filters/FilterSystem.mjs */ "./node_modules/pixi.js/lib/filters/FilterSystem.mjs");
/* harmony import */ var _filters_mask_MaskFilter_mjs__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./filters/mask/MaskFilter.mjs */ "./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs");
/* harmony import */ var _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./maths/matrix/groupD8.mjs */ "./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_misc_const_mjs__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./maths/misc/const.mjs */ "./node_modules/pixi.js/lib/maths/misc/const.mjs");
/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./maths/misc/pow2.mjs */ "./node_modules/pixi.js/lib/maths/misc/pow2.mjs");
/* harmony import */ var _maths_misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./maths/misc/squaredDistanceToLineSegment.mjs */ "./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs");
/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./maths/point/ObservablePoint.mjs */ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs");
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _maths_point_pointInTriangle_mjs__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./maths/point/pointInTriangle.mjs */ "./node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs");
/* harmony import */ var _maths_shapes_Circle_mjs__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./maths/shapes/Circle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Circle.mjs");
/* harmony import */ var _maths_shapes_Ellipse_mjs__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./maths/shapes/Ellipse.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs");
/* harmony import */ var _maths_shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./maths/shapes/Polygon.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _maths_shapes_RoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./maths/shapes/RoundedRectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs");
/* harmony import */ var _maths_shapes_Triangle_mjs__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./maths/shapes/Triangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Triangle.mjs");
/* harmony import */ var _prepare_PrepareBase_mjs__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./prepare/PrepareBase.mjs */ "./node_modules/pixi.js/lib/prepare/PrepareBase.mjs");
/* harmony import */ var _prepare_PrepareQueue_mjs__WEBPACK_IMPORTED_MODULE_153__ = __webpack_require__(/*! ./prepare/PrepareQueue.mjs */ "./node_modules/pixi.js/lib/prepare/PrepareQueue.mjs");
/* harmony import */ var _prepare_PrepareSystem_mjs__WEBPACK_IMPORTED_MODULE_154__ = __webpack_require__(/*! ./prepare/PrepareSystem.mjs */ "./node_modules/pixi.js/lib/prepare/PrepareSystem.mjs");
/* harmony import */ var _prepare_PrepareUpload_mjs__WEBPACK_IMPORTED_MODULE_155__ = __webpack_require__(/*! ./prepare/PrepareUpload.mjs */ "./node_modules/pixi.js/lib/prepare/PrepareUpload.mjs");
/* harmony import */ var _rendering_batcher_gl_GlBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_156__ = __webpack_require__(/*! ./rendering/batcher/gl/GlBatchAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs");
/* harmony import */ var _rendering_batcher_gl_utils_checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_157__ = __webpack_require__(/*! ./rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs");
/* harmony import */ var _rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_158__ = __webpack_require__(/*! ./rendering/batcher/gl/utils/maxRecommendedTextures.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs");
/* harmony import */ var _rendering_batcher_gpu_generateGPULayout_mjs__WEBPACK_IMPORTED_MODULE_159__ = __webpack_require__(/*! ./rendering/batcher/gpu/generateGPULayout.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs");
/* harmony import */ var _rendering_batcher_gpu_generateLayout_mjs__WEBPACK_IMPORTED_MODULE_160__ = __webpack_require__(/*! ./rendering/batcher/gpu/generateLayout.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs");
/* harmony import */ var _rendering_batcher_gpu_getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_161__ = __webpack_require__(/*! ./rendering/batcher/gpu/getTextureBatchBindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs");
/* harmony import */ var _rendering_batcher_gpu_GpuBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_162__ = __webpack_require__(/*! ./rendering/batcher/gpu/GpuBatchAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs");
/* harmony import */ var _rendering_batcher_shared_Batcher_mjs__WEBPACK_IMPORTED_MODULE_163__ = __webpack_require__(/*! ./rendering/batcher/shared/Batcher.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs");
/* harmony import */ var _rendering_batcher_shared_BatcherPipe_mjs__WEBPACK_IMPORTED_MODULE_164__ = __webpack_require__(/*! ./rendering/batcher/shared/BatcherPipe.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs");
/* harmony import */ var _rendering_batcher_shared_BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_165__ = __webpack_require__(/*! ./rendering/batcher/shared/BatchGeometry.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs");
/* harmony import */ var _rendering_batcher_shared_BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_166__ = __webpack_require__(/*! ./rendering/batcher/shared/BatchTextureArray.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs");
/* harmony import */ var _rendering_batcher_shared_DefaultBatcher_mjs__WEBPACK_IMPORTED_MODULE_167__ = __webpack_require__(/*! ./rendering/batcher/shared/DefaultBatcher.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs");
/* harmony import */ var _rendering_batcher_shared_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_168__ = __webpack_require__(/*! ./rendering/batcher/shared/DefaultShader.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs");
/* harmony import */ var _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_169__ = __webpack_require__(/*! ./rendering/high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _rendering_high_shader_compiler_compileHighShader_mjs__WEBPACK_IMPORTED_MODULE_170__ = __webpack_require__(/*! ./rendering/high-shader/compiler/compileHighShader.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs");
/* harmony import */ var _rendering_high_shader_compiler_utils_addBits_mjs__WEBPACK_IMPORTED_MODULE_171__ = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/addBits.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs");
/* harmony import */ var _rendering_high_shader_compiler_utils_compileHooks_mjs__WEBPACK_IMPORTED_MODULE_172__ = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/compileHooks.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs");
/* harmony import */ var _rendering_high_shader_compiler_utils_compileInputs_mjs__WEBPACK_IMPORTED_MODULE_173__ = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/compileInputs.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs");
/* harmony import */ var _rendering_high_shader_compiler_utils_compileOutputs_mjs__WEBPACK_IMPORTED_MODULE_174__ = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/compileOutputs.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs");
/* harmony import */ var _rendering_high_shader_compiler_utils_formatShader_mjs__WEBPACK_IMPORTED_MODULE_175__ = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/formatShader.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs");
/* harmony import */ var _rendering_high_shader_compiler_utils_injectBits_mjs__WEBPACK_IMPORTED_MODULE_176__ = __webpack_require__(/*! ./rendering/high-shader/compiler/utils/injectBits.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs");
/* harmony import */ var _rendering_high_shader_defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_177__ = __webpack_require__(/*! ./rendering/high-shader/defaultProgramTemplate.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_178__ = __webpack_require__(/*! ./rendering/high-shader/shader-bits/colorBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_179__ = __webpack_require__(/*! ./rendering/high-shader/shader-bits/generateTextureBatchBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_globalUniformsBit_mjs__WEBPACK_IMPORTED_MODULE_180__ = __webpack_require__(/*! ./rendering/high-shader/shader-bits/globalUniformsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_181__ = __webpack_require__(/*! ./rendering/high-shader/shader-bits/localUniformBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_182__ = __webpack_require__(/*! ./rendering/high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_textureBit_mjs__WEBPACK_IMPORTED_MODULE_183__ = __webpack_require__(/*! ./rendering/high-shader/shader-bits/textureBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs");
/* harmony import */ var _rendering_mask_alpha_AlphaMask_mjs__WEBPACK_IMPORTED_MODULE_184__ = __webpack_require__(/*! ./rendering/mask/alpha/AlphaMask.mjs */ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs");
/* harmony import */ var _rendering_mask_alpha_AlphaMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_185__ = __webpack_require__(/*! ./rendering/mask/alpha/AlphaMaskPipe.mjs */ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs");
/* harmony import */ var _rendering_mask_color_ColorMask_mjs__WEBPACK_IMPORTED_MODULE_186__ = __webpack_require__(/*! ./rendering/mask/color/ColorMask.mjs */ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs");
/* harmony import */ var _rendering_mask_color_ColorMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_187__ = __webpack_require__(/*! ./rendering/mask/color/ColorMaskPipe.mjs */ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs");
/* harmony import */ var _rendering_mask_MaskEffectManager_mjs__WEBPACK_IMPORTED_MODULE_188__ = __webpack_require__(/*! ./rendering/mask/MaskEffectManager.mjs */ "./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs");
/* harmony import */ var _rendering_mask_scissor_ScissorMask_mjs__WEBPACK_IMPORTED_MODULE_189__ = __webpack_require__(/*! ./rendering/mask/scissor/ScissorMask.mjs */ "./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs");
/* harmony import */ var _rendering_mask_stencil_StencilMask_mjs__WEBPACK_IMPORTED_MODULE_190__ = __webpack_require__(/*! ./rendering/mask/stencil/StencilMask.mjs */ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs");
/* harmony import */ var _rendering_mask_stencil_StencilMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_191__ = __webpack_require__(/*! ./rendering/mask/stencil/StencilMaskPipe.mjs */ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs");
/* harmony import */ var _rendering_mask_utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_192__ = __webpack_require__(/*! ./rendering/mask/utils/addMaskBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs");
/* harmony import */ var _rendering_mask_utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_193__ = __webpack_require__(/*! ./rendering/mask/utils/addMaskLocalBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs");
/* harmony import */ var _rendering_renderers_autoDetectRenderer_mjs__WEBPACK_IMPORTED_MODULE_194__ = __webpack_require__(/*! ./rendering/renderers/autoDetectRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs");
/* harmony import */ var _rendering_renderers_gl_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_195__ = __webpack_require__(/*! ./rendering/renderers/gl/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs");
/* harmony import */ var _rendering_renderers_gl_buffer_GlBuffer_mjs__WEBPACK_IMPORTED_MODULE_196__ = __webpack_require__(/*! ./rendering/renderers/gl/buffer/GlBuffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs");
/* harmony import */ var _rendering_renderers_gl_buffer_GlBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_197__ = __webpack_require__(/*! ./rendering/renderers/gl/buffer/GlBufferSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_const_mjs__WEBPACK_IMPORTED_MODULE_198__ = __webpack_require__(/*! ./rendering/renderers/gl/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs");
/* harmony import */ var _rendering_renderers_gl_context_GlContextSystem_mjs__WEBPACK_IMPORTED_MODULE_199__ = __webpack_require__(/*! ./rendering/renderers/gl/context/GlContextSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_geometry_GlGeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_200__ = __webpack_require__(/*! ./rendering/renderers/gl/geometry/GlGeometrySystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs");
/* harmony import */ var _rendering_renderers_gl_geometry_utils_getGlTypeFromFormat_mjs__WEBPACK_IMPORTED_MODULE_201__ = __webpack_require__(/*! ./rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs");
/* harmony import */ var _rendering_renderers_gl_GlBackBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_202__ = __webpack_require__(/*! ./rendering/renderers/gl/GlBackBufferSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_GlColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_203__ = __webpack_require__(/*! ./rendering/renderers/gl/GlColorMaskSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_GlEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_204__ = __webpack_require__(/*! ./rendering/renderers/gl/GlEncoderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_GlRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_205__ = __webpack_require__(/*! ./rendering/renderers/gl/GlRenderTarget.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs");
/* harmony import */ var _rendering_renderers_gl_GlStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_206__ = __webpack_require__(/*! ./rendering/renderers/gl/GlStencilSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_GlUboSystem_mjs__WEBPACK_IMPORTED_MODULE_207__ = __webpack_require__(/*! ./rendering/renderers/gl/GlUboSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_renderTarget_GlRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_208__ = __webpack_require__(/*! ./rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs");
/* harmony import */ var _rendering_renderers_gl_renderTarget_GlRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_209__ = __webpack_require__(/*! ./rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GenerateShaderSyncCode_mjs__WEBPACK_IMPORTED_MODULE_210__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_211__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_212__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlProgramData_mjs__WEBPACK_IMPORTED_MODULE_213__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlProgramData.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_214__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlShaderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlUniformGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_215__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/GlUniformGroupSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_migrateFragmentFromV7toV8_mjs__WEBPACK_IMPORTED_MODULE_216__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_compileShader_mjs__WEBPACK_IMPORTED_MODULE_217__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/compileShader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_defaultValue_mjs__WEBPACK_IMPORTED_MODULE_218__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/defaultValue.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_ensureAttributes_mjs__WEBPACK_IMPORTED_MODULE_219__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/ensureAttributes.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_extractAttributesFromGlProgram_mjs__WEBPACK_IMPORTED_MODULE_220__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_221__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/generateProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_222__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_223__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getTestContext.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_getUboData_mjs__WEBPACK_IMPORTED_MODULE_224__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getUboData.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_getUniformData_mjs__WEBPACK_IMPORTED_MODULE_225__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/getUniformData.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_logProgramError_mjs__WEBPACK_IMPORTED_MODULE_226__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/logProgramError.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_mapSize_mjs__WEBPACK_IMPORTED_MODULE_227__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/mapSize.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_mapType_mjs__WEBPACK_IMPORTED_MODULE_228__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/mapType.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_preprocessors_addProgramDefines_mjs__WEBPACK_IMPORTED_MODULE_229__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_preprocessors_ensurePrecision_mjs__WEBPACK_IMPORTED_MODULE_230__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_preprocessors_insertVersion_mjs__WEBPACK_IMPORTED_MODULE_231__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_preprocessors_setProgramName_mjs__WEBPACK_IMPORTED_MODULE_232__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_program_preprocessors_stripVersion_mjs__WEBPACK_IMPORTED_MODULE_233__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_utils_createUboElementsSTD40_mjs__WEBPACK_IMPORTED_MODULE_234__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_utils_createUboSyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_235__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_utils_generateArraySyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_236__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_utils_generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_237__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/generateUniformsSync.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_utils_generateUniformsSyncTypes_mjs__WEBPACK_IMPORTED_MODULE_238__ = __webpack_require__(/*! ./rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs");
/* harmony import */ var _rendering_renderers_gl_state_GlStateSystem_mjs__WEBPACK_IMPORTED_MODULE_239__ = __webpack_require__(/*! ./rendering/renderers/gl/state/GlStateSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_state_mapWebGLBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_240__ = __webpack_require__(/*! ./rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_const_mjs__WEBPACK_IMPORTED_MODULE_241__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_GlTexture_mjs__WEBPACK_IMPORTED_MODULE_242__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/GlTexture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_GlTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_243__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/GlTextureSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_uploaders_glUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_244__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_uploaders_glUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_245__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_uploaders_glUploadImageResource_mjs__WEBPACK_IMPORTED_MODULE_246__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_uploaders_glUploadVideoResource_mjs__WEBPACK_IMPORTED_MODULE_247__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_utils_applyStyleParams_mjs__WEBPACK_IMPORTED_MODULE_248__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/applyStyleParams.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_utils_getSupportedGlCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_249__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_utils_mapFormatToGlFormat_mjs__WEBPACK_IMPORTED_MODULE_250__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_utils_mapFormatToGlInternalFormat_mjs__WEBPACK_IMPORTED_MODULE_251__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_utils_mapFormatToGlType_mjs__WEBPACK_IMPORTED_MODULE_252__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_utils_pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_253__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs");
/* harmony import */ var _rendering_renderers_gl_texture_utils_unpremultiplyAlpha_mjs__WEBPACK_IMPORTED_MODULE_254__ = __webpack_require__(/*! ./rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs");
/* harmony import */ var _rendering_renderers_gl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_255__ = __webpack_require__(/*! ./rendering/renderers/gl/WebGLRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs");
/* harmony import */ var _rendering_renderers_gpu_BindGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_256__ = __webpack_require__(/*! ./rendering/renderers/gpu/BindGroupSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_buffer_GpuBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_257__ = __webpack_require__(/*! ./rendering/renderers/gpu/buffer/GpuBufferSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_buffer_GpuReadBuffer_mjs__WEBPACK_IMPORTED_MODULE_258__ = __webpack_require__(/*! ./rendering/renderers/gpu/buffer/GpuReadBuffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuReadBuffer.mjs");
/* harmony import */ var _rendering_renderers_gpu_buffer_UboBatch_mjs__WEBPACK_IMPORTED_MODULE_259__ = __webpack_require__(/*! ./rendering/renderers/gpu/buffer/UboBatch.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs");
/* harmony import */ var _rendering_renderers_gpu_GpuColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_260__ = __webpack_require__(/*! ./rendering/renderers/gpu/GpuColorMaskSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_GpuDeviceSystem_mjs__WEBPACK_IMPORTED_MODULE_261__ = __webpack_require__(/*! ./rendering/renderers/gpu/GpuDeviceSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_GpuEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_262__ = __webpack_require__(/*! ./rendering/renderers/gpu/GpuEncoderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_GpuStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_263__ = __webpack_require__(/*! ./rendering/renderers/gpu/GpuStencilSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_GpuUboSystem_mjs__WEBPACK_IMPORTED_MODULE_264__ = __webpack_require__(/*! ./rendering/renderers/gpu/GpuUboSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_GpuUniformBatchPipe_mjs__WEBPACK_IMPORTED_MODULE_265__ = __webpack_require__(/*! ./rendering/renderers/gpu/GpuUniformBatchPipe.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs");
/* harmony import */ var _rendering_renderers_gpu_pipeline_PipelineSystem_mjs__WEBPACK_IMPORTED_MODULE_266__ = __webpack_require__(/*! ./rendering/renderers/gpu/pipeline/PipelineSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_renderTarget_calculateProjection_mjs__WEBPACK_IMPORTED_MODULE_267__ = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/calculateProjection.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs");
/* harmony import */ var _rendering_renderers_gpu_renderTarget_GpuRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_268__ = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs");
/* harmony import */ var _rendering_renderers_gpu_renderTarget_GpuRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_269__ = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs");
/* harmony import */ var _rendering_renderers_gpu_renderTarget_GpuRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_270__ = __webpack_require__(/*! ./rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_271__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_272__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_273__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/GpuShaderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_createUboElementsWGSL_mjs__WEBPACK_IMPORTED_MODULE_274__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_createUboSyncFunctionWGSL_mjs__WEBPACK_IMPORTED_MODULE_275__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_extractAttributesFromGpuProgram_mjs__WEBPACK_IMPORTED_MODULE_276__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_extractStructAndGroups_mjs__WEBPACK_IMPORTED_MODULE_277__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_generateArraySyncWGSL_mjs__WEBPACK_IMPORTED_MODULE_278__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_generateGpuLayoutGroups_mjs__WEBPACK_IMPORTED_MODULE_279__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_generateLayoutHash_mjs__WEBPACK_IMPORTED_MODULE_280__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_utils_removeStructAndGroupDuplicates_mjs__WEBPACK_IMPORTED_MODULE_281__ = __webpack_require__(/*! ./rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs");
/* harmony import */ var _rendering_renderers_gpu_state_GpuBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_282__ = __webpack_require__(/*! ./rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs");
/* harmony import */ var _rendering_renderers_gpu_state_GpuStateSystem_mjs__WEBPACK_IMPORTED_MODULE_283__ = __webpack_require__(/*! ./rendering/renderers/gpu/state/GpuStateSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_state_GpuStencilModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_284__ = __webpack_require__(/*! ./rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs");
/* harmony import */ var _rendering_renderers_gpu_texture_GpuTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_285__ = __webpack_require__(/*! ./rendering/renderers/gpu/texture/GpuTextureSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs");
/* harmony import */ var _rendering_renderers_gpu_texture_uploaders_gpuUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_286__ = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs");
/* harmony import */ var _rendering_renderers_gpu_texture_uploaders_gpuUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_287__ = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs");
/* harmony import */ var _rendering_renderers_gpu_texture_uploaders_gpuUploadImageSource_mjs__WEBPACK_IMPORTED_MODULE_288__ = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs");
/* harmony import */ var _rendering_renderers_gpu_texture_uploaders_gpuUploadVideoSource_mjs__WEBPACK_IMPORTED_MODULE_289__ = __webpack_require__(/*! ./rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs");
/* harmony import */ var _rendering_renderers_gpu_texture_utils_getSupportedGPUCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_290__ = __webpack_require__(/*! ./rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs");
/* harmony import */ var _rendering_renderers_gpu_texture_utils_GpuMipmapGenerator_mjs__WEBPACK_IMPORTED_MODULE_291__ = __webpack_require__(/*! ./rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs");
/* harmony import */ var _rendering_renderers_gpu_WebGPURenderer_mjs__WEBPACK_IMPORTED_MODULE_292__ = __webpack_require__(/*! ./rendering/renderers/gpu/WebGPURenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs");
/* harmony import */ var _rendering_renderers_shared_background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_293__ = __webpack_require__(/*! ./rendering/renderers/shared/background/BackgroundSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_blendModes_BlendModePipe_mjs__WEBPACK_IMPORTED_MODULE_294__ = __webpack_require__(/*! ./rendering/renderers/shared/blendModes/BlendModePipe.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs");
/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_295__ = __webpack_require__(/*! ./rendering/renderers/shared/buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _rendering_renderers_shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_296__ = __webpack_require__(/*! ./rendering/renderers/shared/buffer/BufferResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs");
/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_297__ = __webpack_require__(/*! ./rendering/renderers/shared/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");
/* harmony import */ var _rendering_renderers_shared_buffer_utils_fastCopy_mjs__WEBPACK_IMPORTED_MODULE_298__ = __webpack_require__(/*! ./rendering/renderers/shared/buffer/utils/fastCopy.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs");
/* harmony import */ var _rendering_renderers_shared_extract_ExtractSystem_mjs__WEBPACK_IMPORTED_MODULE_299__ = __webpack_require__(/*! ./rendering/renderers/shared/extract/ExtractSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_extract_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_300__ = __webpack_require__(/*! ./rendering/renderers/shared/extract/GenerateTextureSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_const_mjs__WEBPACK_IMPORTED_MODULE_301__ = __webpack_require__(/*! ./rendering/renderers/shared/geometry/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_302__ = __webpack_require__(/*! ./rendering/renderers/shared/geometry/Geometry.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_303__ = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/buildUvs.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_ensureIsBuffer_mjs__WEBPACK_IMPORTED_MODULE_304__ = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_305__ = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_getGeometryBounds_mjs__WEBPACK_IMPORTED_MODULE_306__ = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_transformVertices_mjs__WEBPACK_IMPORTED_MODULE_307__ = __webpack_require__(/*! ./rendering/renderers/shared/geometry/utils/transformVertices.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs");
/* harmony import */ var _rendering_renderers_shared_instructions_InstructionSet_mjs__WEBPACK_IMPORTED_MODULE_308__ = __webpack_require__(/*! ./rendering/renderers/shared/instructions/InstructionSet.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs");
/* harmony import */ var _rendering_renderers_shared_renderTarget_GlobalUniformSystem_mjs__WEBPACK_IMPORTED_MODULE_309__ = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_renderTarget_isRenderingToScreen_mjs__WEBPACK_IMPORTED_MODULE_310__ = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs");
/* harmony import */ var _rendering_renderers_shared_renderTarget_RenderTarget_mjs__WEBPACK_IMPORTED_MODULE_311__ = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/RenderTarget.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs");
/* harmony import */ var _rendering_renderers_shared_renderTarget_RenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_312__ = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_renderTarget_viewportFromFrame_mjs__WEBPACK_IMPORTED_MODULE_313__ = __webpack_require__(/*! ./rendering/renderers/shared/renderTarget/viewportFromFrame.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/viewportFromFrame.mjs");
/* harmony import */ var _rendering_renderers_shared_SchedulerSystem_mjs__WEBPACK_IMPORTED_MODULE_314__ = __webpack_require__(/*! ./rendering/renderers/shared/SchedulerSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_const_mjs__WEBPACK_IMPORTED_MODULE_315__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_316__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_types_mjs__WEBPACK_IMPORTED_MODULE_317__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UboSystem_mjs__WEBPACK_IMPORTED_MODULE_318__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/UboSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_319__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_utils_createUboSyncFunction_mjs__WEBPACK_IMPORTED_MODULE_320__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_utils_getDefaultUniformValue_mjs__WEBPACK_IMPORTED_MODULE_321__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_utils_uboSyncFunctions_mjs__WEBPACK_IMPORTED_MODULE_322__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_323__ = __webpack_require__(/*! ./rendering/renderers/shared/shader/utils/uniformParsers.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs");
/* harmony import */ var _rendering_renderers_shared_startup_HelloSystem_mjs__WEBPACK_IMPORTED_MODULE_324__ = __webpack_require__(/*! ./rendering/renderers/shared/startup/HelloSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_325__ = __webpack_require__(/*! ./rendering/renderers/shared/state/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");
/* harmony import */ var _rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_326__ = __webpack_require__(/*! ./rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs");
/* harmony import */ var _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_327__ = __webpack_require__(/*! ./rendering/renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _rendering_renderers_shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_328__ = __webpack_require__(/*! ./rendering/renderers/shared/system/AbstractRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs");
/* harmony import */ var _rendering_renderers_shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_329__ = __webpack_require__(/*! ./rendering/renderers/shared/system/SharedSystems.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs");
/* harmony import */ var _rendering_renderers_shared_system_SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_330__ = __webpack_require__(/*! ./rendering/renderers/shared/system/SystemRunner.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_331__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/CanvasPool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_const_mjs__WEBPACK_IMPORTED_MODULE_332__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_RenderableGCSystem_mjs__WEBPACK_IMPORTED_MODULE_333__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/RenderableGCSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_334__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/RenderTexture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_BufferImageSource_mjs__WEBPACK_IMPORTED_MODULE_335__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/BufferImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_336__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/CanvasSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_CompressedSource_mjs__WEBPACK_IMPORTED_MODULE_337__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/CompressedSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_338__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/ImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_339__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_340__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/sources/VideoSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_341__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_342__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureGCSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_343__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureMatrix.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_344__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TextureStyle_mjs__WEBPACK_IMPORTED_MODULE_345__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureStyle.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TextureUvs_mjs__WEBPACK_IMPORTED_MODULE_346__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/TextureUvs.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_generateUID_mjs__WEBPACK_IMPORTED_MODULE_347__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/generateUID.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_348__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/getCanvasTexture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getSupportedCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_349__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_getSupportedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_350__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_utils_textureFrom_mjs__WEBPACK_IMPORTED_MODULE_351__ = __webpack_require__(/*! ./rendering/renderers/shared/texture/utils/textureFrom.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs");
/* harmony import */ var _rendering_renderers_shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_352__ = __webpack_require__(/*! ./rendering/renderers/shared/utils/createIdFromString.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs");
/* harmony import */ var _rendering_renderers_shared_utils_parseFunctionBody_mjs__WEBPACK_IMPORTED_MODULE_353__ = __webpack_require__(/*! ./rendering/renderers/shared/utils/parseFunctionBody.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs");
/* harmony import */ var _rendering_renderers_shared_view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_354__ = __webpack_require__(/*! ./rendering/renderers/shared/view/ViewSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs");
/* harmony import */ var _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_355__ = __webpack_require__(/*! ./rendering/renderers/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _scene_particle_container_shared_shader_particles_frag_mjs__WEBPACK_IMPORTED_MODULE_356__ = __webpack_require__(/*! ./scene/particle-container/shared/shader/particles.frag.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs");
/* harmony import */ var _scene_particle_container_shared_shader_particles_vert_mjs__WEBPACK_IMPORTED_MODULE_357__ = __webpack_require__(/*! ./scene/particle-container/shared/shader/particles.vert.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs");
/* harmony import */ var _scene_particle_container_shared_shader_particles_wgsl_mjs__WEBPACK_IMPORTED_MODULE_358__ = __webpack_require__(/*! ./scene/particle-container/shared/shader/particles.wgsl.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs");
/* harmony import */ var _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_359__ = __webpack_require__(/*! ./scene/container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _scene_container_bounds_getFastGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_360__ = __webpack_require__(/*! ./scene/container/bounds/getFastGlobalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs");
/* harmony import */ var _scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_361__ = __webpack_require__(/*! ./scene/container/bounds/getGlobalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs");
/* harmony import */ var _scene_container_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_362__ = __webpack_require__(/*! ./scene/container/bounds/getLocalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs");
/* harmony import */ var _scene_container_bounds_getRenderableBounds_mjs__WEBPACK_IMPORTED_MODULE_363__ = __webpack_require__(/*! ./scene/container/bounds/getRenderableBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs");
/* harmony import */ var _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_364__ = __webpack_require__(/*! ./scene/container/bounds/utils/matrixAndBoundsPool.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");
/* harmony import */ var _scene_container_container_mixins_cacheAsTextureMixin_mjs__WEBPACK_IMPORTED_MODULE_365__ = __webpack_require__(/*! ./scene/container/container-mixins/cacheAsTextureMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_childrenHelperMixin_mjs__WEBPACK_IMPORTED_MODULE_366__ = __webpack_require__(/*! ./scene/container/container-mixins/childrenHelperMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_collectRenderablesMixin_mjs__WEBPACK_IMPORTED_MODULE_367__ = __webpack_require__(/*! ./scene/container/container-mixins/collectRenderablesMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_effectsMixin_mjs__WEBPACK_IMPORTED_MODULE_368__ = __webpack_require__(/*! ./scene/container/container-mixins/effectsMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_findMixin_mjs__WEBPACK_IMPORTED_MODULE_369__ = __webpack_require__(/*! ./scene/container/container-mixins/findMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_getFastGlobalBoundsMixin_mjs__WEBPACK_IMPORTED_MODULE_370__ = __webpack_require__(/*! ./scene/container/container-mixins/getFastGlobalBoundsMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_371__ = __webpack_require__(/*! ./scene/container/container-mixins/getGlobalMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_measureMixin_mjs__WEBPACK_IMPORTED_MODULE_372__ = __webpack_require__(/*! ./scene/container/container-mixins/measureMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_onRenderMixin_mjs__WEBPACK_IMPORTED_MODULE_373__ = __webpack_require__(/*! ./scene/container/container-mixins/onRenderMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_sortMixin_mjs__WEBPACK_IMPORTED_MODULE_374__ = __webpack_require__(/*! ./scene/container/container-mixins/sortMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs");
/* harmony import */ var _scene_container_container_mixins_toLocalGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_375__ = __webpack_require__(/*! ./scene/container/container-mixins/toLocalGlobalMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs");
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_376__ = __webpack_require__(/*! ./scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _scene_container_CustomRenderPipe_mjs__WEBPACK_IMPORTED_MODULE_377__ = __webpack_require__(/*! ./scene/container/CustomRenderPipe.mjs */ "./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs");
/* harmony import */ var _scene_container_RenderContainer_mjs__WEBPACK_IMPORTED_MODULE_378__ = __webpack_require__(/*! ./scene/container/RenderContainer.mjs */ "./node_modules/pixi.js/lib/scene/container/RenderContainer.mjs");
/* harmony import */ var _scene_container_RenderGroup_mjs__WEBPACK_IMPORTED_MODULE_379__ = __webpack_require__(/*! ./scene/container/RenderGroup.mjs */ "./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs");
/* harmony import */ var _scene_container_RenderGroupPipe_mjs__WEBPACK_IMPORTED_MODULE_380__ = __webpack_require__(/*! ./scene/container/RenderGroupPipe.mjs */ "./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs");
/* harmony import */ var _scene_container_RenderGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_381__ = __webpack_require__(/*! ./scene/container/RenderGroupSystem.mjs */ "./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs");
/* harmony import */ var _scene_container_utils_assignWithIgnore_mjs__WEBPACK_IMPORTED_MODULE_382__ = __webpack_require__(/*! ./scene/container/utils/assignWithIgnore.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs");
/* harmony import */ var _scene_container_utils_checkChildrenDidChange_mjs__WEBPACK_IMPORTED_MODULE_383__ = __webpack_require__(/*! ./scene/container/utils/checkChildrenDidChange.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs");
/* harmony import */ var _scene_container_utils_clearList_mjs__WEBPACK_IMPORTED_MODULE_384__ = __webpack_require__(/*! ./scene/container/utils/clearList.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs");
/* harmony import */ var _scene_container_utils_collectAllRenderables_mjs__WEBPACK_IMPORTED_MODULE_385__ = __webpack_require__(/*! ./scene/container/utils/collectAllRenderables.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.mjs");
/* harmony import */ var _scene_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_386__ = __webpack_require__(/*! ./scene/container/utils/definedProps.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs");
/* harmony import */ var _scene_container_utils_executeInstructions_mjs__WEBPACK_IMPORTED_MODULE_387__ = __webpack_require__(/*! ./scene/container/utils/executeInstructions.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs");
/* harmony import */ var _scene_container_utils_mixHexColors_mjs__WEBPACK_IMPORTED_MODULE_388__ = __webpack_require__(/*! ./scene/container/utils/mixHexColors.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs");
/* harmony import */ var _scene_container_utils_multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_389__ = __webpack_require__(/*! ./scene/container/utils/multiplyColors.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs");
/* harmony import */ var _scene_container_utils_multiplyHexColors_mjs__WEBPACK_IMPORTED_MODULE_390__ = __webpack_require__(/*! ./scene/container/utils/multiplyHexColors.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs");
/* harmony import */ var _scene_container_utils_updateLocalTransform_mjs__WEBPACK_IMPORTED_MODULE_391__ = __webpack_require__(/*! ./scene/container/utils/updateLocalTransform.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs");
/* harmony import */ var _scene_container_utils_updateRenderGroupTransforms_mjs__WEBPACK_IMPORTED_MODULE_392__ = __webpack_require__(/*! ./scene/container/utils/updateRenderGroupTransforms.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs");
/* harmony import */ var _scene_container_utils_updateWorldTransform_mjs__WEBPACK_IMPORTED_MODULE_393__ = __webpack_require__(/*! ./scene/container/utils/updateWorldTransform.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs");
/* harmony import */ var _scene_container_utils_validateRenderables_mjs__WEBPACK_IMPORTED_MODULE_394__ = __webpack_require__(/*! ./scene/container/utils/validateRenderables.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs");
/* harmony import */ var _scene_graphics_gl_GlGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_395__ = __webpack_require__(/*! ./scene/graphics/gl/GlGraphicsAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs");
/* harmony import */ var _scene_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_396__ = __webpack_require__(/*! ./scene/graphics/gpu/colorToUniform.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs");
/* harmony import */ var _scene_graphics_gpu_GpuGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_397__ = __webpack_require__(/*! ./scene/graphics/gpu/GpuGraphicsAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs");
/* harmony import */ var _scene_graphics_shared_BatchableGraphics_mjs__WEBPACK_IMPORTED_MODULE_398__ = __webpack_require__(/*! ./scene/graphics/shared/BatchableGraphics.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildAdaptiveBezier_mjs__WEBPACK_IMPORTED_MODULE_399__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildAdaptiveQuadratic_mjs__WEBPACK_IMPORTED_MODULE_400__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildArc_mjs__WEBPACK_IMPORTED_MODULE_401__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildArc.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildArcTo_mjs__WEBPACK_IMPORTED_MODULE_402__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildArcTo.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildArcToSvg_mjs__WEBPACK_IMPORTED_MODULE_403__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildArcToSvg.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_404__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildCircle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildLine_mjs__WEBPACK_IMPORTED_MODULE_405__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildLine.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildPixelLine_mjs__WEBPACK_IMPORTED_MODULE_406__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildPixelLine.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildPolygon_mjs__WEBPACK_IMPORTED_MODULE_407__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildPolygon.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_408__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildRectangle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs");
/* harmony import */ var _scene_graphics_shared_buildCommands_buildTriangle_mjs__WEBPACK_IMPORTED_MODULE_409__ = __webpack_require__(/*! ./scene/graphics/shared/buildCommands/buildTriangle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs");
/* harmony import */ var _scene_graphics_shared_const_mjs__WEBPACK_IMPORTED_MODULE_410__ = __webpack_require__(/*! ./scene/graphics/shared/const.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs");
/* harmony import */ var _scene_graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_411__ = __webpack_require__(/*! ./scene/graphics/shared/fill/FillGradient.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs");
/* harmony import */ var _scene_graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_412__ = __webpack_require__(/*! ./scene/graphics/shared/fill/FillPattern.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs");
/* harmony import */ var _scene_graphics_shared_Graphics_mjs__WEBPACK_IMPORTED_MODULE_413__ = __webpack_require__(/*! ./scene/graphics/shared/Graphics.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs");
/* harmony import */ var _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_414__ = __webpack_require__(/*! ./scene/graphics/shared/GraphicsContext.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs");
/* harmony import */ var _scene_graphics_shared_GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_415__ = __webpack_require__(/*! ./scene/graphics/shared/GraphicsContextSystem.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs");
/* harmony import */ var _scene_graphics_shared_GraphicsPipe_mjs__WEBPACK_IMPORTED_MODULE_416__ = __webpack_require__(/*! ./scene/graphics/shared/GraphicsPipe.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs");
/* harmony import */ var _scene_graphics_shared_path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_417__ = __webpack_require__(/*! ./scene/graphics/shared/path/GraphicsPath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs");
/* harmony import */ var _scene_graphics_shared_path_roundShape_mjs__WEBPACK_IMPORTED_MODULE_418__ = __webpack_require__(/*! ./scene/graphics/shared/path/roundShape.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs");
/* harmony import */ var _scene_graphics_shared_path_ShapePath_mjs__WEBPACK_IMPORTED_MODULE_419__ = __webpack_require__(/*! ./scene/graphics/shared/path/ShapePath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs");
/* harmony import */ var _scene_graphics_shared_svg_parseSVGDefinitions_mjs__WEBPACK_IMPORTED_MODULE_420__ = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGDefinitions.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs");
/* harmony import */ var _scene_graphics_shared_svg_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_421__ = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGFloatAttribute.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs");
/* harmony import */ var _scene_graphics_shared_svg_parseSVGPath_mjs__WEBPACK_IMPORTED_MODULE_422__ = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGPath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs");
/* harmony import */ var _scene_graphics_shared_svg_parseSVGStyle_mjs__WEBPACK_IMPORTED_MODULE_423__ = __webpack_require__(/*! ./scene/graphics/shared/svg/parseSVGStyle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs");
/* harmony import */ var _scene_graphics_shared_svg_SVGParser_mjs__WEBPACK_IMPORTED_MODULE_424__ = __webpack_require__(/*! ./scene/graphics/shared/svg/SVGParser.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs");
/* harmony import */ var _scene_graphics_shared_svg_utils_extractSvgUrlId_mjs__WEBPACK_IMPORTED_MODULE_425__ = __webpack_require__(/*! ./scene/graphics/shared/svg/utils/extractSvgUrlId.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs");
/* harmony import */ var _scene_graphics_shared_utils_buildContextBatches_mjs__WEBPACK_IMPORTED_MODULE_426__ = __webpack_require__(/*! ./scene/graphics/shared/utils/buildContextBatches.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs");
/* harmony import */ var _scene_graphics_shared_utils_buildGeometryFromPath_mjs__WEBPACK_IMPORTED_MODULE_427__ = __webpack_require__(/*! ./scene/graphics/shared/utils/buildGeometryFromPath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs");
/* harmony import */ var _scene_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_428__ = __webpack_require__(/*! ./scene/graphics/shared/utils/convertFillInputToFillStyle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs");
/* harmony import */ var _scene_graphics_shared_utils_generateTextureFillMatrix_mjs__WEBPACK_IMPORTED_MODULE_429__ = __webpack_require__(/*! ./scene/graphics/shared/utils/generateTextureFillMatrix.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs");
/* harmony import */ var _scene_graphics_shared_utils_getOrientationOfPoints_mjs__WEBPACK_IMPORTED_MODULE_430__ = __webpack_require__(/*! ./scene/graphics/shared/utils/getOrientationOfPoints.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs");
/* harmony import */ var _scene_graphics_shared_utils_triangulateWithHoles_mjs__WEBPACK_IMPORTED_MODULE_431__ = __webpack_require__(/*! ./scene/graphics/shared/utils/triangulateWithHoles.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs");
/* harmony import */ var _scene_layers_RenderLayer_mjs__WEBPACK_IMPORTED_MODULE_432__ = __webpack_require__(/*! ./scene/layers/RenderLayer.mjs */ "./node_modules/pixi.js/lib/scene/layers/RenderLayer.mjs");
/* harmony import */ var _scene_mesh_perspective_PerspectiveMesh_mjs__WEBPACK_IMPORTED_MODULE_433__ = __webpack_require__(/*! ./scene/mesh-perspective/PerspectiveMesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs");
/* harmony import */ var _scene_mesh_perspective_PerspectivePlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_434__ = __webpack_require__(/*! ./scene/mesh-perspective/PerspectivePlaneGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs");
/* harmony import */ var _scene_mesh_perspective_utils_applyProjectiveTransformationToPlane_mjs__WEBPACK_IMPORTED_MODULE_435__ = __webpack_require__(/*! ./scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs */ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs");
/* harmony import */ var _scene_mesh_perspective_utils_compute2DProjections_mjs__WEBPACK_IMPORTED_MODULE_436__ = __webpack_require__(/*! ./scene/mesh-perspective/utils/compute2DProjections.mjs */ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs");
/* harmony import */ var _scene_mesh_plane_MeshPlane_mjs__WEBPACK_IMPORTED_MODULE_437__ = __webpack_require__(/*! ./scene/mesh-plane/MeshPlane.mjs */ "./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs");
/* harmony import */ var _scene_mesh_plane_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_438__ = __webpack_require__(/*! ./scene/mesh-plane/PlaneGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs");
/* harmony import */ var _scene_mesh_simple_MeshRope_mjs__WEBPACK_IMPORTED_MODULE_439__ = __webpack_require__(/*! ./scene/mesh-simple/MeshRope.mjs */ "./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs");
/* harmony import */ var _scene_mesh_simple_MeshSimple_mjs__WEBPACK_IMPORTED_MODULE_440__ = __webpack_require__(/*! ./scene/mesh-simple/MeshSimple.mjs */ "./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs");
/* harmony import */ var _scene_mesh_simple_RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_441__ = __webpack_require__(/*! ./scene/mesh-simple/RopeGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs");
/* harmony import */ var _scene_mesh_gl_GlMeshAdaptor_mjs__WEBPACK_IMPORTED_MODULE_442__ = __webpack_require__(/*! ./scene/mesh/gl/GlMeshAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs");
/* harmony import */ var _scene_mesh_gpu_GpuMeshAdapter_mjs__WEBPACK_IMPORTED_MODULE_443__ = __webpack_require__(/*! ./scene/mesh/gpu/GpuMeshAdapter.mjs */ "./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs");
/* harmony import */ var _scene_mesh_shared_BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_444__ = __webpack_require__(/*! ./scene/mesh/shared/BatchableMesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs");
/* harmony import */ var _scene_mesh_shared_getTextureDefaultMatrix_mjs__WEBPACK_IMPORTED_MODULE_445__ = __webpack_require__(/*! ./scene/mesh/shared/getTextureDefaultMatrix.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs");
/* harmony import */ var _scene_mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_446__ = __webpack_require__(/*! ./scene/mesh/shared/Mesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs");
/* harmony import */ var _scene_mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_447__ = __webpack_require__(/*! ./scene/mesh/shared/MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");
/* harmony import */ var _scene_mesh_shared_MeshPipe_mjs__WEBPACK_IMPORTED_MODULE_448__ = __webpack_require__(/*! ./scene/mesh/shared/MeshPipe.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs");
/* harmony import */ var _scene_particle_container_gl_GlParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_449__ = __webpack_require__(/*! ./scene/particle-container/gl/GlParticleContainerAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs");
/* harmony import */ var _scene_particle_container_gpu_GpuParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_450__ = __webpack_require__(/*! ./scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs");
/* harmony import */ var _scene_particle_container_shared_GlParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_451__ = __webpack_require__(/*! ./scene/particle-container/shared/GlParticleContainerPipe.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs");
/* harmony import */ var _scene_particle_container_shared_GpuParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_452__ = __webpack_require__(/*! ./scene/particle-container/shared/GpuParticleContainerPipe.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs");
/* harmony import */ var _scene_particle_container_shared_Particle_mjs__WEBPACK_IMPORTED_MODULE_453__ = __webpack_require__(/*! ./scene/particle-container/shared/Particle.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs");
/* harmony import */ var _scene_particle_container_shared_ParticleBuffer_mjs__WEBPACK_IMPORTED_MODULE_454__ = __webpack_require__(/*! ./scene/particle-container/shared/ParticleBuffer.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs");
/* harmony import */ var _scene_particle_container_shared_ParticleContainer_mjs__WEBPACK_IMPORTED_MODULE_455__ = __webpack_require__(/*! ./scene/particle-container/shared/ParticleContainer.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs");
/* harmony import */ var _scene_particle_container_shared_ParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_456__ = __webpack_require__(/*! ./scene/particle-container/shared/ParticleContainerPipe.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs");
/* harmony import */ var _scene_particle_container_shared_particleData_mjs__WEBPACK_IMPORTED_MODULE_457__ = __webpack_require__(/*! ./scene/particle-container/shared/particleData.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs");
/* harmony import */ var _scene_particle_container_shared_shader_ParticleShader_mjs__WEBPACK_IMPORTED_MODULE_458__ = __webpack_require__(/*! ./scene/particle-container/shared/shader/ParticleShader.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs");
/* harmony import */ var _scene_particle_container_shared_utils_createIndicesForQuads_mjs__WEBPACK_IMPORTED_MODULE_459__ = __webpack_require__(/*! ./scene/particle-container/shared/utils/createIndicesForQuads.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs");
/* harmony import */ var _scene_particle_container_shared_utils_generateParticleUpdateFunction_mjs__WEBPACK_IMPORTED_MODULE_460__ = __webpack_require__(/*! ./scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs");
/* harmony import */ var _scene_sprite_animated_AnimatedSprite_mjs__WEBPACK_IMPORTED_MODULE_461__ = __webpack_require__(/*! ./scene/sprite-animated/AnimatedSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs");
/* harmony import */ var _scene_sprite_nine_slice_NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_462__ = __webpack_require__(/*! ./scene/sprite-nine-slice/NineSliceGeometry.mjs */ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs");
/* harmony import */ var _scene_sprite_nine_slice_NineSliceSprite_mjs__WEBPACK_IMPORTED_MODULE_463__ = __webpack_require__(/*! ./scene/sprite-nine-slice/NineSliceSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs");
/* harmony import */ var _scene_sprite_nine_slice_NineSliceSpritePipe_mjs__WEBPACK_IMPORTED_MODULE_464__ = __webpack_require__(/*! ./scene/sprite-nine-slice/NineSliceSpritePipe.mjs */ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs");
/* harmony import */ var _scene_sprite_tiling_shader_tilingBit_mjs__WEBPACK_IMPORTED_MODULE_465__ = __webpack_require__(/*! ./scene/sprite-tiling/shader/tilingBit.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs");
/* harmony import */ var _scene_sprite_tiling_shader_TilingSpriteShader_mjs__WEBPACK_IMPORTED_MODULE_466__ = __webpack_require__(/*! ./scene/sprite-tiling/shader/TilingSpriteShader.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs");
/* harmony import */ var _scene_sprite_tiling_TilingSprite_mjs__WEBPACK_IMPORTED_MODULE_467__ = __webpack_require__(/*! ./scene/sprite-tiling/TilingSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs");
/* harmony import */ var _scene_sprite_tiling_TilingSpritePipe_mjs__WEBPACK_IMPORTED_MODULE_468__ = __webpack_require__(/*! ./scene/sprite-tiling/TilingSpritePipe.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs");
/* harmony import */ var _scene_sprite_tiling_utils_applyMatrix_mjs__WEBPACK_IMPORTED_MODULE_469__ = __webpack_require__(/*! ./scene/sprite-tiling/utils/applyMatrix.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs");
/* harmony import */ var _scene_sprite_tiling_utils_QuadGeometry_mjs__WEBPACK_IMPORTED_MODULE_470__ = __webpack_require__(/*! ./scene/sprite-tiling/utils/QuadGeometry.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs");
/* harmony import */ var _scene_sprite_tiling_utils_setPositions_mjs__WEBPACK_IMPORTED_MODULE_471__ = __webpack_require__(/*! ./scene/sprite-tiling/utils/setPositions.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs");
/* harmony import */ var _scene_sprite_tiling_utils_setUvs_mjs__WEBPACK_IMPORTED_MODULE_472__ = __webpack_require__(/*! ./scene/sprite-tiling/utils/setUvs.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs");
/* harmony import */ var _scene_sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_473__ = __webpack_require__(/*! ./scene/sprite/BatchableSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");
/* harmony import */ var _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_474__ = __webpack_require__(/*! ./scene/sprite/Sprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs");
/* harmony import */ var _scene_sprite_SpritePipe_mjs__WEBPACK_IMPORTED_MODULE_475__ = __webpack_require__(/*! ./scene/sprite/SpritePipe.mjs */ "./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs");
/* harmony import */ var _scene_text_bitmap_AbstractBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_476__ = __webpack_require__(/*! ./scene/text-bitmap/AbstractBitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs");
/* harmony import */ var _scene_text_bitmap_asset_bitmapFontTextParser_mjs__WEBPACK_IMPORTED_MODULE_477__ = __webpack_require__(/*! ./scene/text-bitmap/asset/bitmapFontTextParser.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs");
/* harmony import */ var _scene_text_bitmap_asset_bitmapFontXMLParser_mjs__WEBPACK_IMPORTED_MODULE_478__ = __webpack_require__(/*! ./scene/text-bitmap/asset/bitmapFontXMLParser.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs");
/* harmony import */ var _scene_text_bitmap_asset_bitmapFontXMLStringParser_mjs__WEBPACK_IMPORTED_MODULE_479__ = __webpack_require__(/*! ./scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs");
/* harmony import */ var _scene_text_bitmap_asset_loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_480__ = __webpack_require__(/*! ./scene/text-bitmap/asset/loadBitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs");
/* harmony import */ var _scene_text_bitmap_BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_481__ = __webpack_require__(/*! ./scene/text-bitmap/BitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs");
/* harmony import */ var _scene_text_bitmap_BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_482__ = __webpack_require__(/*! ./scene/text-bitmap/BitmapFontManager.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs");
/* harmony import */ var _scene_text_bitmap_BitmapText_mjs__WEBPACK_IMPORTED_MODULE_483__ = __webpack_require__(/*! ./scene/text-bitmap/BitmapText.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs");
/* harmony import */ var _scene_text_bitmap_BitmapTextPipe_mjs__WEBPACK_IMPORTED_MODULE_484__ = __webpack_require__(/*! ./scene/text-bitmap/BitmapTextPipe.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs");
/* harmony import */ var _scene_text_bitmap_DynamicBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_485__ = __webpack_require__(/*! ./scene/text-bitmap/DynamicBitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs");
/* harmony import */ var _scene_text_bitmap_utils_getBitmapTextLayout_mjs__WEBPACK_IMPORTED_MODULE_486__ = __webpack_require__(/*! ./scene/text-bitmap/utils/getBitmapTextLayout.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs");
/* harmony import */ var _scene_text_bitmap_utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_487__ = __webpack_require__(/*! ./scene/text-bitmap/utils/resolveCharacters.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs");
/* harmony import */ var _scene_text_html_HTMLText_mjs__WEBPACK_IMPORTED_MODULE_488__ = __webpack_require__(/*! ./scene/text-html/HTMLText.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs");
/* harmony import */ var _scene_text_html_HTMLTextPipe_mjs__WEBPACK_IMPORTED_MODULE_489__ = __webpack_require__(/*! ./scene/text-html/HTMLTextPipe.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs");
/* harmony import */ var _scene_text_html_HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_490__ = __webpack_require__(/*! ./scene/text-html/HTMLTextRenderData.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs");
/* harmony import */ var _scene_text_html_HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_491__ = __webpack_require__(/*! ./scene/text-html/HTMLTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs");
/* harmony import */ var _scene_text_html_HTMLTextSystem_mjs__WEBPACK_IMPORTED_MODULE_492__ = __webpack_require__(/*! ./scene/text-html/HTMLTextSystem.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs");
/* harmony import */ var _scene_text_html_utils_extractFontFamilies_mjs__WEBPACK_IMPORTED_MODULE_493__ = __webpack_require__(/*! ./scene/text-html/utils/extractFontFamilies.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs");
/* harmony import */ var _scene_text_html_utils_getFontCss_mjs__WEBPACK_IMPORTED_MODULE_494__ = __webpack_require__(/*! ./scene/text-html/utils/getFontCss.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs");
/* harmony import */ var _scene_text_html_utils_getSVGUrl_mjs__WEBPACK_IMPORTED_MODULE_495__ = __webpack_require__(/*! ./scene/text-html/utils/getSVGUrl.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs");
/* harmony import */ var _scene_text_html_utils_getTemporaryCanvasFromImage_mjs__WEBPACK_IMPORTED_MODULE_496__ = __webpack_require__(/*! ./scene/text-html/utils/getTemporaryCanvasFromImage.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs");
/* harmony import */ var _scene_text_html_utils_loadFontAsBase64_mjs__WEBPACK_IMPORTED_MODULE_497__ = __webpack_require__(/*! ./scene/text-html/utils/loadFontAsBase64.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs");
/* harmony import */ var _scene_text_html_utils_loadFontCSS_mjs__WEBPACK_IMPORTED_MODULE_498__ = __webpack_require__(/*! ./scene/text-html/utils/loadFontCSS.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs");
/* harmony import */ var _scene_text_html_utils_loadSVGImage_mjs__WEBPACK_IMPORTED_MODULE_499__ = __webpack_require__(/*! ./scene/text-html/utils/loadSVGImage.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs");
/* harmony import */ var _scene_text_html_utils_measureHtmlText_mjs__WEBPACK_IMPORTED_MODULE_500__ = __webpack_require__(/*! ./scene/text-html/utils/measureHtmlText.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs");
/* harmony import */ var _scene_text_html_utils_textStyleToCSS_mjs__WEBPACK_IMPORTED_MODULE_501__ = __webpack_require__(/*! ./scene/text-html/utils/textStyleToCSS.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs");
/* harmony import */ var _scene_text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_502__ = __webpack_require__(/*! ./scene/text/AbstractText.mjs */ "./node_modules/pixi.js/lib/scene/text/AbstractText.mjs");
/* harmony import */ var _scene_text_canvas_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_503__ = __webpack_require__(/*! ./scene/text/canvas/CanvasTextMetrics.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs");
/* harmony import */ var _scene_text_canvas_CanvasTextPipe_mjs__WEBPACK_IMPORTED_MODULE_504__ = __webpack_require__(/*! ./scene/text/canvas/CanvasTextPipe.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs");
/* harmony import */ var _scene_text_canvas_CanvasTextSystem_mjs__WEBPACK_IMPORTED_MODULE_505__ = __webpack_require__(/*! ./scene/text/canvas/CanvasTextSystem.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs");
/* harmony import */ var _scene_text_canvas_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_506__ = __webpack_require__(/*! ./scene/text/canvas/utils/fontStringFromTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs");
/* harmony import */ var _scene_text_canvas_utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_507__ = __webpack_require__(/*! ./scene/text/canvas/utils/getCanvasFillStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs");
/* harmony import */ var _scene_text_sdfShader_SdfShader_mjs__WEBPACK_IMPORTED_MODULE_508__ = __webpack_require__(/*! ./scene/text/sdfShader/SdfShader.mjs */ "./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs");
/* harmony import */ var _scene_text_sdfShader_shader_bits_localUniformMSDFBit_mjs__WEBPACK_IMPORTED_MODULE_509__ = __webpack_require__(/*! ./scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs */ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs");
/* harmony import */ var _scene_text_sdfShader_shader_bits_mSDFBit_mjs__WEBPACK_IMPORTED_MODULE_510__ = __webpack_require__(/*! ./scene/text/sdfShader/shader-bits/mSDFBit.mjs */ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs");
/* harmony import */ var _scene_text_Text_mjs__WEBPACK_IMPORTED_MODULE_511__ = __webpack_require__(/*! ./scene/text/Text.mjs */ "./node_modules/pixi.js/lib/scene/text/Text.mjs");
/* harmony import */ var _scene_text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_512__ = __webpack_require__(/*! ./scene/text/TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");
/* harmony import */ var _scene_text_utils_ensureTextStyle_mjs__WEBPACK_IMPORTED_MODULE_513__ = __webpack_require__(/*! ./scene/text/utils/ensureTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs");
/* harmony import */ var _scene_text_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_514__ = __webpack_require__(/*! ./scene/text/utils/generateTextStyleKey.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs");
/* harmony import */ var _scene_text_utils_getPo2TextureFromSource_mjs__WEBPACK_IMPORTED_MODULE_515__ = __webpack_require__(/*! ./scene/text/utils/getPo2TextureFromSource.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs");
/* harmony import */ var _scene_text_utils_updateTextBounds_mjs__WEBPACK_IMPORTED_MODULE_516__ = __webpack_require__(/*! ./scene/text/utils/updateTextBounds.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs");
/* harmony import */ var _scene_view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_517__ = __webpack_require__(/*! ./scene/view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");
/* harmony import */ var _spritesheet_Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_518__ = __webpack_require__(/*! ./spritesheet/Spritesheet.mjs */ "./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs");
/* harmony import */ var _spritesheet_spritesheetAsset_mjs__WEBPACK_IMPORTED_MODULE_519__ = __webpack_require__(/*! ./spritesheet/spritesheetAsset.mjs */ "./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs");
/* harmony import */ var _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_520__ = __webpack_require__(/*! ./ticker/const.mjs */ "./node_modules/pixi.js/lib/ticker/const.mjs");
/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_521__ = __webpack_require__(/*! ./ticker/Ticker.mjs */ "./node_modules/pixi.js/lib/ticker/Ticker.mjs");
/* harmony import */ var _ticker_TickerListener_mjs__WEBPACK_IMPORTED_MODULE_522__ = __webpack_require__(/*! ./ticker/TickerListener.mjs */ "./node_modules/pixi.js/lib/ticker/TickerListener.mjs");
/* harmony import */ var _utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_523__ = __webpack_require__(/*! ./utils/browser/detectVideoAlphaMode.mjs */ "./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs");
/* harmony import */ var _utils_browser_isMobile_mjs__WEBPACK_IMPORTED_MODULE_524__ = __webpack_require__(/*! ./utils/browser/isMobile.mjs */ "./node_modules/pixi.js/lib/utils/browser/isMobile.mjs");
/* harmony import */ var _utils_browser_isSafari_mjs__WEBPACK_IMPORTED_MODULE_525__ = __webpack_require__(/*! ./utils/browser/isSafari.mjs */ "./node_modules/pixi.js/lib/utils/browser/isSafari.mjs");
/* harmony import */ var _utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_526__ = __webpack_require__(/*! ./utils/browser/isWebGLSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs");
/* harmony import */ var _utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_527__ = __webpack_require__(/*! ./utils/browser/isWebGPUSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs");
/* harmony import */ var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_528__ = __webpack_require__(/*! ./utils/browser/unsafeEvalSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs");
/* harmony import */ var _utils_canvas_getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_529__ = __webpack_require__(/*! ./utils/canvas/getCanvasBoundingBox.mjs */ "./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs");
/* harmony import */ var _utils_const_mjs__WEBPACK_IMPORTED_MODULE_530__ = __webpack_require__(/*! ./utils/const.mjs */ "./node_modules/pixi.js/lib/utils/const.mjs");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_531__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _utils_data_clean_mjs__WEBPACK_IMPORTED_MODULE_532__ = __webpack_require__(/*! ./utils/data/clean.mjs */ "./node_modules/pixi.js/lib/utils/data/clean.mjs");
/* harmony import */ var _utils_data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_533__ = __webpack_require__(/*! ./utils/data/removeItems.mjs */ "./node_modules/pixi.js/lib/utils/data/removeItems.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_534__ = __webpack_require__(/*! ./utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_535__ = __webpack_require__(/*! ./utils/data/updateQuadBounds.mjs */ "./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs");
/* harmony import */ var _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_536__ = __webpack_require__(/*! ./utils/data/ViewableBuffer.mjs */ "./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs");
/* harmony import */ var _utils_global_globalHooks_mjs__WEBPACK_IMPORTED_MODULE_537__ = __webpack_require__(/*! ./utils/global/globalHooks.mjs */ "./node_modules/pixi.js/lib/utils/global/globalHooks.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_538__ = __webpack_require__(/*! ./utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _utils_logging_logDebugTexture_mjs__WEBPACK_IMPORTED_MODULE_539__ = __webpack_require__(/*! ./utils/logging/logDebugTexture.mjs */ "./node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs");
/* harmony import */ var _utils_logging_logScene_mjs__WEBPACK_IMPORTED_MODULE_540__ = __webpack_require__(/*! ./utils/logging/logScene.mjs */ "./node_modules/pixi.js/lib/utils/logging/logScene.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_541__ = __webpack_require__(/*! ./utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_misc_NOOP_mjs__WEBPACK_IMPORTED_MODULE_542__ = __webpack_require__(/*! ./utils/misc/NOOP.mjs */ "./node_modules/pixi.js/lib/utils/misc/NOOP.mjs");
/* harmony import */ var _utils_misc_Transform_mjs__WEBPACK_IMPORTED_MODULE_543__ = __webpack_require__(/*! ./utils/misc/Transform.mjs */ "./node_modules/pixi.js/lib/utils/misc/Transform.mjs");
/* harmony import */ var _utils_network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_544__ = __webpack_require__(/*! ./utils/network/getResolutionOfUrl.mjs */ "./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs");
/* harmony import */ var _utils_path_mjs__WEBPACK_IMPORTED_MODULE_545__ = __webpack_require__(/*! ./utils/path.mjs */ "./node_modules/pixi.js/lib/utils/path.mjs");
/* harmony import */ var _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_546__ = __webpack_require__(/*! ./utils/pool/Pool.mjs */ "./node_modules/pixi.js/lib/utils/pool/Pool.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_547__ = __webpack_require__(/*! ./utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _utils_sayHello_mjs__WEBPACK_IMPORTED_MODULE_548__ = __webpack_require__(/*! ./utils/sayHello.mjs */ "./node_modules/pixi.js/lib/utils/sayHello.mjs");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_549__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");































































































































































































































































































































































































































































































































































































"use strict";
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions.add(_environment_browser_browserExt_mjs__WEBPACK_IMPORTED_MODULE_550__.browserExt, _environment_webworker_webworkerExt_mjs__WEBPACK_IMPORTED_MODULE_551__.webworkerExt);


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Matrix: () => (/* binding */ Matrix)
/* harmony export */ });
/* harmony import */ var _misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc/const.mjs */ "./node_modules/pixi.js/lib/maths/misc/const.mjs");
/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");



"use strict";
class Matrix {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    /** An array of the current matrix. Only populated when `toArray` is called */
    this.array = null;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, transformed through this matrix
   */
  apply(pos, newPos) {
    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(pos, newPos) {
    newPos = newPos || new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const tx = this.tx;
    const ty = this.ty;
    const id = 1 / (a * d + c * -b);
    const x = pos.x;
    const y = pos.y;
    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
    return newPos;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  /**
   * Appends two matrix's and sets the result to this matrix. AB = A * B
   * @param a - The matrix to append.
   * @param b - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  appendFrom(a, b) {
    const a1 = a.a;
    const b1 = a.b;
    const c1 = a.c;
    const d1 = a.d;
    const tx = a.tx;
    const ty = a.ty;
    const a2 = b.a;
    const b2 = b.b;
    const c2 = b.c;
    const d2 = b.d;
    this.a = a1 * a2 + b1 * c2;
    this.b = a1 * b2 + b1 * d2;
    this.c = c1 * a2 + d1 * c2;
    this.d = c1 * b2 + d1 * d2;
    this.tx = tx * a2 + ty * c2 + b.tx;
    this.ty = tx * b2 + ty * d2 + b.ty;
    return this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(transform) {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(_misc_const_mjs__WEBPACK_IMPORTED_MODULE_1__.PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
    return transform;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  }
  /** Checks if this matrix is an identity matrix */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param matrix - The matrix to copy from.
   * @returns this
   */
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  /**
   * check to see if two matrices are the same
   * @param matrix - The matrix to compare to.
   */
  equals(matrix) {
    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix.
   *
   * This is a shared object, if you want to modify it consider creating a new `Matrix`
   * @readonly
   */
  static get IDENTITY() {
    return identityMatrix.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   * Use this object for fast but temporary calculations, as it may be mutated later on.
   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
   * @readonly
   */
  static get shared() {
    return tempMatrix.identity();
  }
}
const tempMatrix = new Matrix();
const identityMatrix = new Matrix();


//# sourceMappingURL=Matrix.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   groupD8: () => (/* binding */ groupD8)
/* harmony export */ });
/* harmony import */ var _Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");


"use strict";
const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j = 0; j < 16; j++) {
      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (let k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new _Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0       | East      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45     | Southeast |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90     | South     |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135    | Southwest |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180     | West      |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135/225 | Northwest    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90/270  | North        |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45/315  | Northeast    |
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof maths.groupD8
   * @constant {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (ind) => ux[ind],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (ind) => uy[ind],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (ind) => vx[ind],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (ind) => vy[ind],
  /**
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  /**
   * Reverse of `add`.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof maths.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (rotation) => rotation ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof maths.groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (rotation) => (rotation & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof maths.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof maths.groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};


//# sourceMappingURL=groupD8.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/misc/const.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/misc/const.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEG_TO_RAD: () => (/* binding */ DEG_TO_RAD),
/* harmony export */   PI_2: () => (/* binding */ PI_2),
/* harmony export */   RAD_TO_DEG: () => (/* binding */ RAD_TO_DEG)
/* harmony export */ });

const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/misc/pow2.mjs":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/misc/pow2.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPow2: () => (/* binding */ isPow2),
/* harmony export */   log2: () => (/* binding */ log2),
/* harmony export */   nextPow2: () => (/* binding */ nextPow2)
/* harmony export */ });

function nextPow2(v) {
  v += v === 0 ? 1 : 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  let r = (v > 65535 ? 1 : 0) << 4;
  v >>>= r;
  let shift = (v > 255 ? 1 : 0) << 3;
  v >>>= shift;
  r |= shift;
  shift = (v > 15 ? 1 : 0) << 2;
  v >>>= shift;
  r |= shift;
  shift = (v > 3 ? 1 : 0) << 1;
  v >>>= shift;
  r |= shift;
  return r | v >> 1;
}


//# sourceMappingURL=pow2.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   squaredDistanceToLineSegment: () => (/* binding */ squaredDistanceToLineSegment)
/* harmony export */ });

function squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {
  const a = x - x1;
  const b = y - y1;
  const c = x2 - x1;
  const d = y2 - y1;
  const dot = a * c + b * d;
  const lenSq = c * c + d * d;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * c;
    yy = y1 + param * d;
  }
  const dx = x - xx;
  const dy = y - yy;
  return dx * dx + dy * dy;
}


//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObservablePoint: () => (/* binding */ ObservablePoint)
/* harmony export */ });

class ObservablePoint {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(observer, x, y) {
    this._x = x || 0;
    this._y = y || 0;
    this._observer = observer;
  }
  /**
   * Creates a clone of this point.
   * @param observer - Optional observer to pass to the new observable point.
   * @returns a copy of this observable point
   */
  clone(observer) {
    return new ObservablePoint(observer ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(x = 0, y = x) {
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this._observer._onUpdate(this);
    }
    return this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `PointData`
   * @returns The observable point instance itself
   */
  copyFrom(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this._observer._onUpdate(this);
    }
    return this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p) {
    p.set(this._x, this._y);
    return p;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
  }
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this._observer._onUpdate(this);
    }
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this._observer._onUpdate(this);
    }
  }
}


//# sourceMappingURL=ObservablePoint.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/Point.mjs":
/*!********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/Point.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Point: () => (/* binding */ Point)
/* harmony export */ });

class Point {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(x = 0, y = 0) {
    /** Position of the point on the x axis */
    this.x = 0;
    /** Position of the point on the y axis */
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new Point(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(p) {
    this.set(p.x, p.y);
    return this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `PointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p) {
    p.set(this.x, this.y);
    return p;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(x = 0, y = x) {
    this.x = x;
    this.y = y;
    return this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
   * @readonly
   */
  static get shared() {
    tempPoint.x = 0;
    tempPoint.y = 0;
    return tempPoint;
  }
}
const tempPoint = new Point();


//# sourceMappingURL=Point.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pointInTriangle: () => (/* binding */ pointInTriangle)
/* harmony export */ });

function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
  const v2x = x3 - x1;
  const v2y = y3 - y1;
  const v1x = x2 - x1;
  const v1y = y2 - y1;
  const v0x = px - x1;
  const v0y = py - y1;
  const dot00 = v2x * v2x + v2y * v2y;
  const dot01 = v2x * v1x + v2y * v1y;
  const dot02 = v2x * v0x + v2y * v0y;
  const dot11 = v1x * v1x + v1y * v1y;
  const dot12 = v1x * v0x + v1y * v0y;
  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
  return u >= 0 && v >= 0 && u + v < 1;
}


//# sourceMappingURL=pointInTriangle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Circle.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Circle.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Circle: () => (/* binding */ Circle)
/* harmony export */ });
/* harmony import */ var _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");


"use strict";
class Circle {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(x = 0, y = 0, radius = 0) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'circle'
     */
    this.type = "circle";
    this.x = x;
    this.y = y;
    this.radius = radius;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(x, y) {
    if (this.radius <= 0)
      return false;
    const r2 = this.radius * this.radius;
    let dx = this.x - x;
    let dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this Circle
   */
  strokeContains(x, y, width, alignment = 0.5) {
    if (this.radius === 0)
      return false;
    const dx = this.x - x;
    const dy = this.y - y;
    const radius = this.radius;
    const outerWidth = (1 - alignment) * width;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance <= radius + outerWidth && distance > radius - (width - outerWidth);
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(out) {
    out || (out = new _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle());
    out.x = this.x - this.radius;
    out.y = this.y - this.radius;
    out.width = this.radius * 2;
    out.height = this.radius * 2;
    return out;
  }
  /**
   * Copies another circle to this one.
   * @param circle - The circle to copy from.
   * @returns Returns itself.
   */
  copyFrom(circle) {
    this.x = circle.x;
    this.y = circle.y;
    this.radius = circle.radius;
    return this;
  }
  /**
   * Copies this circle to another one.
   * @param circle - The circle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(circle) {
    circle.copyFrom(this);
    return circle;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}


//# sourceMappingURL=Circle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ellipse: () => (/* binding */ Ellipse)
/* harmony export */ });
/* harmony import */ var _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");


"use strict";
class Ellipse {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'ellipse'
     */
    this.type = "ellipse";
    this.x = x;
    this.y = y;
    this.halfWidth = halfWidth;
    this.halfHeight = halfHeight;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {Ellipse} A copy of the ellipse
   */
  clone() {
    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(x, y) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0) {
      return false;
    }
    let normx = (x - this.x) / this.halfWidth;
    let normy = (y - this.y) / this.halfHeight;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke
   * @returns Whether the x/y coords are within this ellipse
   */
  strokeContains(x, y, strokeWidth, alignment = 0.5) {
    const { halfWidth, halfHeight } = this;
    if (halfWidth <= 0 || halfHeight <= 0) {
      return false;
    }
    const strokeOuterWidth = strokeWidth * (1 - alignment);
    const strokeInnerWidth = strokeWidth - strokeOuterWidth;
    const innerHorizontal = halfWidth - strokeInnerWidth;
    const innerVertical = halfHeight - strokeInnerWidth;
    const outerHorizontal = halfWidth + strokeOuterWidth;
    const outerVertical = halfHeight + strokeOuterWidth;
    const normalizedX = x - this.x;
    const normalizedY = y - this.y;
    const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
    const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
    return innerEllipse > 1 && outerEllipse <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @param out
   * @returns The framing rectangle
   */
  getBounds(out) {
    out || (out = new _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle());
    out.x = this.x - this.halfWidth;
    out.y = this.y - this.halfHeight;
    out.width = this.halfWidth * 2;
    out.height = this.halfHeight * 2;
    return out;
  }
  /**
   * Copies another ellipse to this one.
   * @param ellipse - The ellipse to copy from.
   * @returns Returns itself.
   */
  copyFrom(ellipse) {
    this.x = ellipse.x;
    this.y = ellipse.y;
    this.halfWidth = ellipse.halfWidth;
    this.halfHeight = ellipse.halfHeight;
    return this;
  }
  /**
   * Copies this ellipse to another one.
   * @param ellipse - The ellipse to copy to.
   * @returns Returns given parameter.
   */
  copyTo(ellipse) {
    ellipse.copyFrom(this);
    return ellipse;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}


//# sourceMappingURL=Ellipse.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polygon: () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var _misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/squaredDistanceToLineSegment.mjs */ "./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs");
/* harmony import */ var _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");



"use strict";
let tempRect;
let tempRect2;
class Polygon {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...points) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'polygon'
     */
    this.type = "polygon";
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p = [];
      for (let i = 0, il = flat.length; i < il; i++) {
        p.push(flat[i].x, flat[i].y);
      }
      flat = p;
    }
    this.points = flat;
    this.closePath = true;
  }
  /**
   * Determines whether the polygon's points are arranged in a clockwise direction.
   * This is calculated using the "shoelace formula" (also known as surveyor's formula) to find the signed area.
   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
   *
   * The formula sums up the cross products of adjacent vertices:
   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
   * The final sum divided by 2 gives the signed area - positive for clockwise.
   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
   */
  isClockwise() {
    let area = 0;
    const points = this.points;
    const length = points.length;
    for (let i = 0; i < length; i += 2) {
      const x1 = points[i];
      const y1 = points[i + 1];
      const x2 = points[(i + 2) % length];
      const y2 = points[(i + 3) % length];
      area += (x2 - x1) * (y2 + y1);
    }
    return area < 0;
  }
  /**
   * Checks if this polygon completely contains another polygon.
   *
   * This is useful for detecting holes in shapes, like when parsing SVG paths.
   * For example, if you have two polygons:
   * ```ts
   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
   *
   * outerSquare.containsPolygon(innerSquare); // Returns true
   * innerSquare.containsPolygon(outerSquare); // Returns false
   * ```
   * @param polygon - The polygon to test for containment
   * @returns True if this polygon completely contains the other polygon
   */
  containsPolygon(polygon) {
    const thisBounds = this.getBounds(tempRect);
    const otherBounds = polygon.getBounds(tempRect2);
    if (!thisBounds.containsRect(otherBounds)) {
      return false;
    }
    const points = polygon.points;
    for (let i = 0; i < points.length; i += 2) {
      const x = points[i];
      const y = points[i + 1];
      if (!this.contains(x, y)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closePath = this.closePath;
    return polygon;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(x, y) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i = 0, j = length - 1; i < length; j = i++) {
      const xi = this.points[i * 2];
      const yi = this.points[i * 2 + 1];
      const xj = this.points[j * 2];
      const yj = this.points[j * 2 + 1];
      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this polygon
   */
  strokeContains(x, y, strokeWidth, alignment = 0.5) {
    const strokeWidthSquared = strokeWidth * strokeWidth;
    const rightWidthSquared = strokeWidthSquared * (1 - alignment);
    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
    const { points } = this;
    const iterationLength = points.length - (this.closePath ? 0 : 2);
    for (let i = 0; i < iterationLength; i += 2) {
      const x1 = points[i];
      const y1 = points[i + 1];
      const x2 = points[(i + 2) % points.length];
      const y2 = points[(i + 3) % points.length];
      const distanceSquared = (0,_misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceToLineSegment)(x, y, x1, y1, x2, y2);
      const sign = Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));
      if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(out) {
    out || (out = new _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle());
    const points = this.points;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i];
      const y = points[i + 1];
      minX = x < minX ? x : minX;
      maxX = x > maxX ? x : maxX;
      minY = y < minY ? y : minY;
      maxY = y > maxY ? y : maxY;
    }
    out.x = minX;
    out.width = maxX - minX;
    out.y = minY;
    out.height = maxY - minY;
    return out;
  }
  /**
   * Copies another polygon to this one.
   * @param polygon - The polygon to copy from.
   * @returns Returns itself.
   */
  copyFrom(polygon) {
    this.points = polygon.points.slice();
    this.closePath = polygon.closePath;
    return this;
  }
  /**
   * Copies this polygon to another one.
   * @param polygon - The polygon to copy to.
   * @returns Returns given parameter.
   */
  copyTo(polygon) {
    polygon.copyFrom(this);
    return polygon;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon
   * @readonly
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon
   * @readonly
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon
   * @readonly
   */
  get x() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the first Y coordinate of the polygon
   * @readonly
   */
  get y() {
    return this.points[this.points.length - 1];
  }
}


//# sourceMappingURL=Polygon.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rectangle: () => (/* binding */ Rectangle)
/* harmony export */ });
/* harmony import */ var _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");


"use strict";
const tempPoints = [new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(), new _point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point()];
class Rectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(x = 0, y = 0, width = 0, height = 0) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'rectangle'
     */
    this.type = "rectangle";
    this.x = Number(x);
    this.y = Number(y);
    this.width = Number(width);
    this.height = Number(height);
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** Determines whether the Rectangle is empty. */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /** A constant empty rectangle. This is a new object every time the property is accessed */
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @param bounds - The bounds to copy and convert to a rectangle.
   * @returns Returns itself.
   */
  copyFromBounds(bounds) {
    this.x = bounds.minX;
    this.y = bounds.minY;
    this.width = bounds.maxX - bounds.minX;
    this.height = bounds.maxY - bounds.minY;
    return this;
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(x, y, strokeWidth, alignment = 0.5) {
    const { width, height } = this;
    if (width <= 0 || height <= 0)
      return false;
    const _x = this.x;
    const _y = this.y;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const outerLeft = _x - strokeWidthOuter;
    const outerRight = _x + width + strokeWidthOuter;
    const outerTop = _y - strokeWidthOuter;
    const outerBottom = _y + height + strokeWidthOuter;
    const innerLeft = _x + strokeWidthInner;
    const innerRight = _x + width - strokeWidthInner;
    const innerTop = _y + strokeWidthInner;
    const innerBottom = _y + height - strokeWidthInner;
    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s * (lb.y - lt.y);
    const ny = s * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s * (lt.y - rt.y);
    const my = s * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(out) {
    out || (out = new Rectangle());
    out.copyFrom(this);
    return out;
  }
  /**
   * Checks if this rectangle fully contains another rectangle.
   *
   * A rectangle contains another rectangle if all four corners of the other rectangle
   * lie within the bounds of this rectangle.
   *
   * ```ts
   * const container = new Rectangle(0, 0, 100, 100);
   * const inside = new Rectangle(25, 25, 50, 50);
   * const partial = new Rectangle(75, 75, 50, 50);
   *
   * container.containsRect(inside); // Returns true
   * container.containsRect(partial); // Returns false - partial overlap
   * ```
   *
   * Note: If either rectangle has a width or height of 0, this method returns false
   * since a zero-area rectangle cannot meaningfully contain another rectangle.
   * @param other - The rectangle to check if it is contained within this one
   * @returns True if the other rectangle is fully contained within this one
   */
  containsRect(other) {
    if (this.width <= 0 || this.height <= 0)
      return false;
    const x1 = other.x;
    const y1 = other.y;
    const x2 = other.x + other.width;
    const y2 = other.y + other.height;
    return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}


//# sourceMappingURL=Rectangle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RoundedRectangle: () => (/* binding */ RoundedRectangle)
/* harmony export */ });
/* harmony import */ var _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");


"use strict";
const isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
  const dx = pX - cornerX;
  const dy = pY - cornerY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;
};
class RoundedRectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'roundedRectangle'
     */
    this.type = "roundedRectangle";
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.radius = radius;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(out) {
    out || (out = new _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle());
    out.x = this.x;
    out.y = this.y;
    out.width = this.width;
    out.height = this.height;
    return out;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.x + this.width) {
      if (y >= this.y && y <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return true;
        }
        let dx = x - (this.x + radius);
        let dy = y - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this rectangle
   */
  strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
    const { x, y, width, height, radius } = this;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const innerX = x + radius;
    const innerY = y + radius;
    const innerWidth = width - radius * 2;
    const innerHeight = height - radius * 2;
    const rightBound = x + width;
    const bottomBound = y + height;
    if ((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
      return true;
    }
    if ((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
      return true;
    }
    return (
      // Top-left
      pX < innerX && pY < innerY && isCornerWithinStroke(
        pX,
        pY,
        innerX,
        innerY,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(
        pX,
        pY,
        rightBound - radius,
        innerY,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(
        pX,
        pY,
        rightBound - radius,
        bottomBound - radius,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(
        pX,
        pY,
        innerX,
        bottomBound - radius,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      )
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}


//# sourceMappingURL=RoundedRectangle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/maths/shapes/Triangle.mjs":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/maths/shapes/Triangle.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Triangle: () => (/* binding */ Triangle)
/* harmony export */ });
/* harmony import */ var _misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../misc/squaredDistanceToLineSegment.mjs */ "./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs");
/* harmony import */ var _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");



"use strict";
class Triangle {
  /**
   * @param x - The X coord of the first point.
   * @param y - The Y coord of the first point.
   * @param x2 - The X coord of the second point.
   * @param y2 - The Y coord of the second point.
   * @param x3 - The X coord of the third point.
   * @param y3 - The Y coord of the third point.
   */
  constructor(x = 0, y = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @default 'triangle'
     */
    this.type = "triangle";
    this.x = x;
    this.y = y;
    this.x2 = x2;
    this.y2 = y2;
    this.x3 = x3;
    this.y3 = y3;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this triangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Triangle
   */
  contains(x, y) {
    const s = (this.x - this.x3) * (y - this.y3) - (this.y - this.y3) * (x - this.x3);
    const t = (this.x2 - this.x) * (y - this.y) - (this.y2 - this.y) * (x - this.x);
    if (s < 0 !== t < 0 && s !== 0 && t !== 0) {
      return false;
    }
    const d = (this.x3 - this.x2) * (y - this.y2) - (this.y3 - this.y2) * (x - this.x2);
    return d === 0 || d < 0 === s + t <= 0;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this triangle including the stroke.
   * @param pointX - The X coordinate of the point to test
   * @param pointY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param _alignment - The alignment of the stroke
   * @returns Whether the x/y coordinates are within this triangle
   */
  strokeContains(pointX, pointY, strokeWidth, _alignment = 0.5) {
    const halfStrokeWidth = strokeWidth / 2;
    const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;
    const { x, x2, x3, y, y2, y3 } = this;
    if ((0,_misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceToLineSegment)(pointX, pointY, x, y, x2, y3) <= halfStrokeWidthSquared || (0,_misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceToLineSegment)(pointX, pointY, x2, y2, x3, y3) <= halfStrokeWidthSquared || (0,_misc_squaredDistanceToLineSegment_mjs__WEBPACK_IMPORTED_MODULE_0__.squaredDistanceToLineSegment)(pointX, pointY, x3, y3, x, y) <= halfStrokeWidthSquared) {
      return true;
    }
    return false;
  }
  /**
   * Creates a clone of this Triangle
   * @returns a copy of the triangle
   */
  clone() {
    const triangle = new Triangle(
      this.x,
      this.y,
      this.x2,
      this.y2,
      this.x3,
      this.y3
    );
    return triangle;
  }
  /**
   * Copies another triangle to this one.
   * @param triangle - The triangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(triangle) {
    this.x = triangle.x;
    this.y = triangle.y;
    this.x2 = triangle.x2;
    this.y2 = triangle.y2;
    this.x3 = triangle.x3;
    this.y3 = triangle.y3;
    return this;
  }
  /**
   * Copies this triangle to another one.
   * @param triangle - The triangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(triangle) {
    triangle.copyFrom(this);
    return triangle;
  }
  /**
   * Returns the framing rectangle of the triangle as a Rectangle object
   * @param out - optional rectangle to store the result
   * @returns The framing rectangle
   */
  getBounds(out) {
    out || (out = new _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle());
    const minX = Math.min(this.x, this.x2, this.x3);
    const maxX = Math.max(this.x, this.x2, this.x3);
    const minY = Math.min(this.y, this.y2, this.y3);
    const maxY = Math.max(this.y, this.y2, this.y3);
    out.x = minX;
    out.y = minY;
    out.width = maxX - minX;
    out.height = maxY - minY;
    return out;
  }
}


//# sourceMappingURL=Triangle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareBase.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareBase.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrepareBase: () => (/* binding */ PrepareBase)
/* harmony export */ });
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ticker/const.mjs */ "./node_modules/pixi.js/lib/ticker/const.mjs");
/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ticker/Ticker.mjs */ "./node_modules/pixi.js/lib/ticker/Ticker.mjs");




"use strict";
const _PrepareBase = class _PrepareBase {
  /**
   * @param {rendering.Renderer} renderer - A reference to the current renderer
   */
  constructor(renderer) {
    /** called per frame by the ticker, defer processing to next tick */
    this._tick = () => {
      this.timeout = setTimeout(this._processQueue, 0);
    };
    /** process the queue up to max item limit per frame */
    this._processQueue = () => {
      const { queue } = this;
      let itemsProcessed = 0;
      while (queue.length && itemsProcessed < _PrepareBase.uploadsPerFrame) {
        const queueItem = queue.shift();
        this.uploadQueueItem(queueItem);
        itemsProcessed++;
      }
      if (queue.length) {
        _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.addOnce(this._tick, this, _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY.UTILITY);
      } else {
        this._resolve();
      }
    };
    this.renderer = renderer;
    this.queue = [];
    this.resolves = [];
  }
  /**
   * Return a copy of the queue
   * @returns {PrepareQueueItem[]} The queue
   */
  getQueue() {
    return [...this.queue];
  }
  /**
   * Add a textures or graphics resource to the queue
   * @param {PrepareSourceItem | PrepareSourceItem[]} resource
   */
  add(resource) {
    const resourceArray = Array.isArray(resource) ? resource : [resource];
    for (const resourceItem of resourceArray) {
      if (resourceItem instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__.Container) {
        this._addContainer(resourceItem);
      } else {
        this.resolveQueueItem(resourceItem, this.queue);
      }
    }
    return this;
  }
  /**
   * Recursively add a container and its children to the queue
   * @param {Container} container - The container to add to the queue
   */
  _addContainer(container) {
    this.resolveQueueItem(container, this.queue);
    for (const child of container.children) {
      this._addContainer(child);
    }
  }
  /**
   * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)
   * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource
   */
  upload(resource) {
    if (resource) {
      this.add(resource);
    }
    return new Promise((resolve) => {
      if (this.queue.length) {
        this.resolves.push(resolve);
        this.dedupeQueue();
        _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.addOnce(this._tick, this, _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY.UTILITY);
      } else {
        resolve();
      }
    });
  }
  /** eliminate duplicates before processing */
  dedupeQueue() {
    const hash = /* @__PURE__ */ Object.create(null);
    let nextUnique = 0;
    for (let i = 0; i < this.queue.length; i++) {
      const current = this.queue[i];
      if (!hash[current.uid]) {
        hash[current.uid] = true;
        this.queue[nextUnique++] = current;
      }
    }
    this.queue.length = nextUnique;
  }
  /** Call all the resolve callbacks */
  _resolve() {
    const { resolves } = this;
    const array = resolves.slice(0);
    resolves.length = 0;
    for (const resolve of array) {
      resolve();
    }
  }
};
/** The number of uploads to process per frame */
_PrepareBase.uploadsPerFrame = 4;
let PrepareBase = _PrepareBase;


//# sourceMappingURL=PrepareBase.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareQueue.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareQueue.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrepareQueue: () => (/* binding */ PrepareQueue)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rendering/renderers/shared/texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _scene_graphics_shared_Graphics_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../scene/graphics/shared/Graphics.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs");
/* harmony import */ var _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scene/graphics/shared/GraphicsContext.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs");
/* harmony import */ var _scene_mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../scene/mesh/shared/Mesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs");
/* harmony import */ var _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scene/sprite/Sprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs");
/* harmony import */ var _scene_sprite_animated_AnimatedSprite_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../scene/sprite-animated/AnimatedSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs");
/* harmony import */ var _scene_sprite_tiling_TilingSprite_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../scene/sprite-tiling/TilingSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs");
/* harmony import */ var _scene_text_Text_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../scene/text/Text.mjs */ "./node_modules/pixi.js/lib/scene/text/Text.mjs");
/* harmony import */ var _PrepareBase_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrepareBase.mjs */ "./node_modules/pixi.js/lib/prepare/PrepareBase.mjs");












"use strict";
class PrepareQueue extends _PrepareBase_mjs__WEBPACK_IMPORTED_MODULE_0__.PrepareBase {
  /**
   * Resolve the given resource type and return an item for the queue
   * @param source
   * @param queue
   */
  resolveQueueItem(source, queue) {
    if (source instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_1__.Container) {
      this.resolveContainerQueueItem(source, queue);
    } else if (source instanceof _rendering_renderers_shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_2__.TextureSource || source instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture) {
      queue.push(source.source);
    } else if (source instanceof _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_4__.GraphicsContext) {
      queue.push(source);
    }
    return null;
  }
  /**
   * Resolve the given container and return an item for the queue
   * @param container
   * @param queue
   */
  resolveContainerQueueItem(container, queue) {
    if (container instanceof _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_5__.Sprite || container instanceof _scene_sprite_tiling_TilingSprite_mjs__WEBPACK_IMPORTED_MODULE_6__.TilingSprite || container instanceof _scene_mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_7__.Mesh) {
      queue.push(container.texture.source);
    } else if (container instanceof _scene_text_Text_mjs__WEBPACK_IMPORTED_MODULE_8__.Text) {
      queue.push(container);
    } else if (container instanceof _scene_graphics_shared_Graphics_mjs__WEBPACK_IMPORTED_MODULE_9__.Graphics) {
      queue.push(container.context);
    } else if (container instanceof _scene_sprite_animated_AnimatedSprite_mjs__WEBPACK_IMPORTED_MODULE_10__.AnimatedSprite) {
      container.textures.forEach((textureOrFrame) => {
        if (textureOrFrame.source) {
          queue.push(textureOrFrame.source);
        } else {
          queue.push(textureOrFrame.texture.source);
        }
      });
    }
  }
  /**
   * Resolve the given graphics context and return an item for the queue
   * @param graphicsContext
   */
  resolveGraphicsContextQueueItem(graphicsContext) {
    this.renderer.graphicsContext.getGpuContext(graphicsContext);
    const { instructions } = graphicsContext;
    for (const instruction of instructions) {
      if (instruction.action === "texture") {
        const { image } = instruction.data;
        return image.source;
      } else if (instruction.action === "fill") {
        const { texture } = instruction.data.style;
        return texture.source;
      }
    }
    return null;
  }
}


//# sourceMappingURL=PrepareQueue.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareSystem.mjs":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareSystem.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrepareSystem: () => (/* binding */ PrepareSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _PrepareUpload_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrepareUpload.mjs */ "./node_modules/pixi.js/lib/prepare/PrepareUpload.mjs");



"use strict";
class PrepareSystem extends _PrepareUpload_mjs__WEBPACK_IMPORTED_MODULE_0__.PrepareUpload {
  /** Destroys the plugin, don't use after this. */
  destroy() {
    clearTimeout(this.timeout);
    this.renderer = null;
    this.queue = null;
    this.resolves = null;
  }
}
/** @ignore */
PrepareSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem
  ],
  name: "prepare"
};


//# sourceMappingURL=PrepareSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/prepare/PrepareUpload.mjs":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/prepare/PrepareUpload.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PrepareUpload: () => (/* binding */ PrepareUpload)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/renderers/shared/texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../scene/graphics/shared/GraphicsContext.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs");
/* harmony import */ var _scene_text_Text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scene/text/Text.mjs */ "./node_modules/pixi.js/lib/scene/text/Text.mjs");
/* harmony import */ var _scene_text_bitmap_BitmapText_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scene/text-bitmap/BitmapText.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs");
/* harmony import */ var _scene_text_html_HTMLText_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scene/text-html/HTMLText.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs");
/* harmony import */ var _PrepareQueue_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrepareQueue.mjs */ "./node_modules/pixi.js/lib/prepare/PrepareQueue.mjs");







"use strict";
class PrepareUpload extends _PrepareQueue_mjs__WEBPACK_IMPORTED_MODULE_0__.PrepareQueue {
  /**
   * Upload the given queue item
   * @param item
   */
  uploadQueueItem(item) {
    if (item instanceof _rendering_renderers_shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureSource) {
      this.uploadTextureSource(item);
    } else if (item instanceof _scene_text_Text_mjs__WEBPACK_IMPORTED_MODULE_2__.Text) {
      this.uploadText(item);
    } else if (item instanceof _scene_text_html_HTMLText_mjs__WEBPACK_IMPORTED_MODULE_3__.HTMLText) {
      this.uploadHTMLText(item);
    } else if (item instanceof _scene_text_bitmap_BitmapText_mjs__WEBPACK_IMPORTED_MODULE_4__.BitmapText) {
      this.uploadBitmapText(item);
    } else if (item instanceof _scene_graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_5__.GraphicsContext) {
      this.uploadGraphicsContext(item);
    }
  }
  uploadTextureSource(textureSource) {
    this.renderer.texture.initSource(textureSource);
  }
  uploadText(_text) {
    this.renderer.renderPipes.text.initGpuText(_text);
  }
  uploadBitmapText(_text) {
    this.renderer.renderPipes.bitmapText.initGpuText(_text);
  }
  uploadHTMLText(_text) {
    this.renderer.renderPipes.htmlText.initGpuText(_text);
  }
  /**
   * Resolve the given graphics context and return an item for the queue
   * @param graphicsContext
   */
  uploadGraphicsContext(graphicsContext) {
    this.renderer.graphicsContext.getGpuContext(graphicsContext);
    const { instructions } = graphicsContext;
    for (const instruction of instructions) {
      if (instruction.action === "texture") {
        const { image } = instruction.data;
        this.uploadTextureSource(image.source);
      } else if (instruction.action === "fill") {
        const { texture } = instruction.data.style;
        this.uploadTextureSource(texture.source);
      }
    }
    return null;
  }
}


//# sourceMappingURL=PrepareUpload.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlBatchAdaptor: () => (/* binding */ GlBatchAdaptor)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");



"use strict";
class GlBatchAdaptor {
  constructor() {
    this._tempState = _renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
    /**
     * We only want to sync the a batched shaders uniforms once on first use
     * this is a hash of shader uids to a boolean value.  When the shader is first bound
     * we set the value to true.  When the shader is bound again we check the value and
     * if it is true we know that the uniforms have already been synced and we skip it.
     */
    this._didUploadHash = {};
  }
  init(batcherPipe) {
    batcherPipe.renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._didUploadHash = {};
  }
  start(batchPipe, geometry, shader) {
    const renderer = batchPipe.renderer;
    const didUpload = this._didUploadHash[shader.uid];
    renderer.shader.bind(shader, didUpload);
    if (!didUpload) {
      this._didUploadHash[shader.uid] = true;
    }
    renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
    renderer.geometry.bind(geometry, shader.glProgram);
  }
  execute(batchPipe, batch) {
    const renderer = batchPipe.renderer;
    this._tempState.blendMode = batch.blendMode;
    renderer.state.set(this._tempState);
    const textures = batch.textures.textures;
    for (let i = 0; i < batch.textures.count; i++) {
      renderer.texture.bind(textures[i], i);
    }
    renderer.geometry.draw(batch.topology, batch.size, batch.start);
  }
}
/** @ignore */
GlBatchAdaptor.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGLPipesAdaptor
  ],
  name: "batch"
};


//# sourceMappingURL=GlBatchAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkMaxIfStatementsInShader: () => (/* binding */ checkMaxIfStatementsInShader)
/* harmony export */ });

const fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += `if(test == ${i}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  try {
    while (true) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
  } finally {
    gl.deleteShader(shader);
  }
  return maxIfs;
}


//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMaxTexturesPerBatch: () => (/* binding */ getMaxTexturesPerBatch)
/* harmony export */ });
/* harmony import */ var _renderers_gl_shader_program_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../renderers/gl/shader/program/getTestContext.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs");
/* harmony import */ var _checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./checkMaxIfStatementsInShader.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs");



"use strict";
let maxTexturesPerBatchCache = null;
function getMaxTexturesPerBatch() {
  if (maxTexturesPerBatchCache)
    return maxTexturesPerBatchCache;
  const gl = (0,_renderers_gl_shader_program_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_0__.getTestContext)();
  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  maxTexturesPerBatchCache = (0,_checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_1__.checkMaxIfStatementsInShader)(
    maxTexturesPerBatchCache,
    gl
  );
  gl.getExtension("WEBGL_lose_context")?.loseContext();
  return maxTexturesPerBatchCache;
}


//# sourceMappingURL=maxRecommendedTextures.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuBatchAdaptor: () => (/* binding */ GpuBatchAdaptor)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTextureBatchBindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs");




"use strict";
const tempState = _renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
class GpuBatchAdaptor {
  start(batchPipe, geometry, shader) {
    const renderer = batchPipe.renderer;
    const encoder = renderer.encoder;
    const program = shader.gpuProgram;
    this._shader = shader;
    this._geometry = geometry;
    encoder.setGeometry(geometry, program);
    tempState.blendMode = "normal";
    renderer.pipeline.getPipeline(
      geometry,
      program,
      tempState
    );
    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
    encoder.resetBindGroup(1);
    encoder.setBindGroup(0, globalUniformsBindGroup, program);
  }
  execute(batchPipe, batch) {
    const program = this._shader.gpuProgram;
    const renderer = batchPipe.renderer;
    const encoder = renderer.encoder;
    if (!batch.bindGroup) {
      const textureBatch = batch.textures;
      batch.bindGroup = (0,_getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.getTextureBatchBindGroup)(textureBatch.textures, textureBatch.count);
    }
    tempState.blendMode = batch.blendMode;
    const gpuBindGroup = renderer.bindGroup.getBindGroup(
      batch.bindGroup,
      program,
      1
    );
    const pipeline = renderer.pipeline.getPipeline(
      this._geometry,
      program,
      tempState,
      batch.topology
    );
    batch.bindGroup._touch(renderer.textureGC.count);
    encoder.setPipeline(pipeline);
    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
  }
}
/** @ignore */
GpuBatchAdaptor.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUPipesAdaptor
  ],
  name: "batch"
};


//# sourceMappingURL=GpuBatchAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateGPULayout: () => (/* binding */ generateGPULayout)
/* harmony export */ });

function generateGPULayout(maxTextures) {
  const gpuLayout = [];
  let bindIndex = 0;
  for (let i = 0; i < maxTextures; i++) {
    gpuLayout[bindIndex] = {
      texture: {
        sampleType: "float",
        viewDimension: "2d",
        multisampled: false
      },
      binding: bindIndex,
      visibility: GPUShaderStage.FRAGMENT
    };
    bindIndex++;
    gpuLayout[bindIndex] = {
      sampler: {
        type: "filtering"
      },
      binding: bindIndex,
      visibility: GPUShaderStage.FRAGMENT
    };
    bindIndex++;
  }
  return gpuLayout;
}


//# sourceMappingURL=generateGPULayout.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateLayout: () => (/* binding */ generateLayout)
/* harmony export */ });

function generateLayout(maxTextures) {
  const layout = {};
  let bindIndex = 0;
  for (let i = 0; i < maxTextures; i++) {
    layout[`textureSource${i + 1}`] = bindIndex++;
    layout[`textureSampler${i + 1}`] = bindIndex++;
  }
  return layout;
}


//# sourceMappingURL=generateLayout.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTextureBatchBindGroup: () => (/* binding */ getTextureBatchBindGroup)
/* harmony export */ });
/* harmony import */ var _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../renderers/gpu/shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");
/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gl/utils/maxRecommendedTextures.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs");




"use strict";
const cachedGroups = {};
function getTextureBatchBindGroup(textures, size) {
  let uid = 2166136261;
  for (let i = 0; i < size; i++) {
    uid ^= textures[i].uid;
    uid = Math.imul(uid, 16777619);
    uid >>>= 0;
  }
  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);
}
let maxTextures = 0;
function generateTextureBatchBindGroup(textures, size, key) {
  const bindGroupResources = {};
  let bindIndex = 0;
  if (!maxTextures)
    maxTextures = (0,_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__.getMaxTexturesPerBatch)();
  for (let i = 0; i < maxTextures; i++) {
    const texture = i < size ? textures[i] : _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new _renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}


//# sourceMappingURL=getTextureBatchBindGroup.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BatchGeometry: () => (/* binding */ BatchGeometry)
/* harmony export */ });
/* harmony import */ var _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../renderers/shared/buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../renderers/shared/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");
/* harmony import */ var _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderers/shared/geometry/Geometry.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs");




"use strict";
const placeHolderBufferData = new Float32Array(1);
const placeHolderIndexData = new Uint32Array(1);
class BatchGeometry extends _renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__.Geometry {
  constructor() {
    const vertexSize = 6;
    const attributeBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer({
      data: placeHolderBufferData,
      label: "attribute-batch-buffer",
      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.VERTEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.COPY_DST,
      shrinkToFit: false
    });
    const indexBuffer = new _renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer({
      data: placeHolderIndexData,
      label: "index-batch-buffer",
      usage: _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.INDEX | _renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: false
    });
    const stride = vertexSize * 4;
    super({
      attributes: {
        aPosition: {
          buffer: attributeBuffer,
          format: "float32x2",
          stride,
          offset: 0
        },
        aUV: {
          buffer: attributeBuffer,
          format: "float32x2",
          stride,
          offset: 2 * 4
        },
        aColor: {
          buffer: attributeBuffer,
          format: "unorm8x4",
          stride,
          offset: 4 * 4
        },
        aTextureIdAndRound: {
          buffer: attributeBuffer,
          format: "uint16x2",
          stride,
          offset: 5 * 4
        }
      },
      indexBuffer
    });
  }
}


//# sourceMappingURL=BatchGeometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BatchTextureArray: () => (/* binding */ BatchTextureArray)
/* harmony export */ });

class BatchTextureArray {
  constructor() {
    /** Respective locations for textures. */
    this.ids = /* @__PURE__ */ Object.create(null);
    this.textures = [];
    this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let i = 0; i < this.count; i++) {
      const t = this.textures[i];
      this.textures[i] = null;
      this.ids[t.uid] = null;
    }
    this.count = 0;
  }
}


//# sourceMappingURL=BatchTextureArray.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Batch: () => (/* binding */ Batch),
/* harmony export */   Batcher: () => (/* binding */ Batcher)
/* harmony export */ });
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/data/ViewableBuffer.mjs */ "./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs");
/* harmony import */ var _renderers_shared_buffer_utils_fastCopy_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../renderers/shared/buffer/utils/fastCopy.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs");
/* harmony import */ var _renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../renderers/shared/state/getAdjustedBlendModeBlend.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs");
/* harmony import */ var _gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gl/utils/maxRecommendedTextures.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs");
/* harmony import */ var _BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BatchTextureArray.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs");







"use strict";
class Batch {
  constructor() {
    this.renderPipeId = "batch";
    this.action = "startBatch";
    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones
    // public elementStart = 0;
    // public elementSize = 0;
    // for drawing..
    this.start = 0;
    this.size = 0;
    this.textures = new _BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_0__.BatchTextureArray();
    this.blendMode = "normal";
    this.topology = "triangle-strip";
    this.canBundle = true;
  }
  destroy() {
    this.textures = null;
    this.gpuBindGroup = null;
    this.bindGroup = null;
    this.batcher = null;
  }
}
const batchPool = [];
let batchPoolIndex = 0;
function getBatchFromPool() {
  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
}
function returnBatchToPool(batch) {
  batchPool[batchPoolIndex++] = batch;
}
let BATCH_TICK = 0;
const _Batcher = class _Batcher {
  constructor(options = {}) {
    /** unique id for this batcher */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("batcher");
    /** Indicates whether the batch data has been modified and needs updating. */
    this.dirty = true;
    /** The current index of the batch being processed. */
    this.batchIndex = 0;
    /** An array of all batches created during the current rendering process. */
    this.batches = [];
    this._elements = [];
    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? (0,_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_2__.getMaxTexturesPerBatch)();
    options = { ..._Batcher.defaultOptions, ...options };
    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;
    this.attributeBuffer = new _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_3__.ViewableBuffer(attributesInitialSize * 4);
    this.indexBuffer = new Uint16Array(indicesInitialSize);
    this.maxTextures = maxTextures;
  }
  begin() {
    this.elementSize = 0;
    this.elementStart = 0;
    this.indexSize = 0;
    this.attributeSize = 0;
    for (let i = 0; i < this.batchIndex; i++) {
      returnBatchToPool(this.batches[i]);
    }
    this.batchIndex = 0;
    this._batchIndexStart = 0;
    this._batchIndexSize = 0;
    this.dirty = true;
  }
  add(batchableObject) {
    this._elements[this.elementSize++] = batchableObject;
    batchableObject._indexStart = this.indexSize;
    batchableObject._attributeStart = this.attributeSize;
    batchableObject._batcher = this;
    this.indexSize += batchableObject.indexSize;
    this.attributeSize += batchableObject.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(batchableObject, texture) {
    const textureId = batchableObject._batch.textures.ids[texture._source.uid];
    if (!textureId && textureId !== 0)
      return false;
    batchableObject._textureId = textureId;
    batchableObject.texture = texture;
    return true;
  }
  updateElement(batchableObject) {
    this.dirty = true;
    const attributeBuffer = this.attributeBuffer;
    if (batchableObject.packAsQuad) {
      this.packQuadAttributes(
        batchableObject,
        attributeBuffer.float32View,
        attributeBuffer.uint32View,
        batchableObject._attributeStart,
        batchableObject._textureId
      );
    } else {
      this.packAttributes(
        batchableObject,
        attributeBuffer.float32View,
        attributeBuffer.uint32View,
        batchableObject._attributeStart,
        batchableObject._textureId
      );
    }
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(instructionSet) {
    const elements = this._elements;
    if (!elements[this.elementStart])
      return;
    let batch = getBatchFromPool();
    let textureBatch = batch.textures;
    textureBatch.clear();
    const firstElement = elements[this.elementStart];
    let blendMode = (0,_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_4__.getAdjustedBlendModeBlend)(firstElement.blendMode, firstElement.texture._source);
    let topology = firstElement.topology;
    if (this.attributeSize * 4 > this.attributeBuffer.size) {
      this._resizeAttributeBuffer(this.attributeSize * 4);
    }
    if (this.indexSize > this.indexBuffer.length) {
      this._resizeIndexBuffer(this.indexSize);
    }
    const f32 = this.attributeBuffer.float32View;
    const u32 = this.attributeBuffer.uint32View;
    const indexBuffer = this.indexBuffer;
    let size = this._batchIndexSize;
    let start = this._batchIndexStart;
    let action = "startBatch";
    const maxTextures = this.maxTextures;
    for (let i = this.elementStart; i < this.elementSize; ++i) {
      const element = elements[i];
      elements[i] = null;
      const texture = element.texture;
      const source = texture._source;
      const adjustedBlendMode = (0,_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_4__.getAdjustedBlendModeBlend)(element.blendMode, source);
      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
      if (source._batchTick === BATCH_TICK && !breakRequired) {
        element._textureId = source._textureBindLocation;
        size += element.indexSize;
        if (element.packAsQuad) {
          this.packQuadAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          this.packQuadIndex(
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        } else {
          this.packAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          this.packIndex(
            element,
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        }
        element._batch = batch;
        continue;
      }
      source._batchTick = BATCH_TICK;
      if (textureBatch.count >= maxTextures || breakRequired) {
        this._finishBatch(
          batch,
          start,
          size - start,
          textureBatch,
          blendMode,
          topology,
          instructionSet,
          action
        );
        action = "renderBatch";
        start = size;
        blendMode = adjustedBlendMode;
        topology = element.topology;
        batch = getBatchFromPool();
        textureBatch = batch.textures;
        textureBatch.clear();
        ++BATCH_TICK;
      }
      element._textureId = source._textureBindLocation = textureBatch.count;
      textureBatch.ids[source.uid] = textureBatch.count;
      textureBatch.textures[textureBatch.count++] = source;
      element._batch = batch;
      size += element.indexSize;
      if (element.packAsQuad) {
        this.packQuadAttributes(
          element,
          f32,
          u32,
          element._attributeStart,
          element._textureId
        );
        this.packQuadIndex(
          indexBuffer,
          element._indexStart,
          element._attributeStart / this.vertexSize
        );
      } else {
        this.packAttributes(
          element,
          f32,
          u32,
          element._attributeStart,
          element._textureId
        );
        this.packIndex(
          element,
          indexBuffer,
          element._indexStart,
          element._attributeStart / this.vertexSize
        );
      }
    }
    if (textureBatch.count > 0) {
      this._finishBatch(
        batch,
        start,
        size - start,
        textureBatch,
        blendMode,
        topology,
        instructionSet,
        action
      );
      start = size;
      ++BATCH_TICK;
    }
    this.elementStart = this.elementSize;
    this._batchIndexStart = start;
    this._batchIndexSize = size;
  }
  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {
    batch.gpuBindGroup = null;
    batch.bindGroup = null;
    batch.action = action;
    batch.batcher = this;
    batch.textures = textureBatch;
    batch.blendMode = blendMode;
    batch.topology = topology;
    batch.start = indexStart;
    batch.size = indexSize;
    ++BATCH_TICK;
    this.batches[this.batchIndex++] = batch;
    instructionSet.add(batch);
  }
  finish(instructionSet) {
    this.break(instructionSet);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(size) {
    if (size * 4 <= this.attributeBuffer.size)
      return;
    this._resizeAttributeBuffer(size * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(size) {
    if (size <= this.indexBuffer.length)
      return;
    this._resizeIndexBuffer(size);
  }
  _resizeAttributeBuffer(size) {
    const newSize = Math.max(size, this.attributeBuffer.size * 2);
    const newArrayBuffer = new _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_3__.ViewableBuffer(newSize);
    (0,_renderers_shared_buffer_utils_fastCopy_mjs__WEBPACK_IMPORTED_MODULE_5__.fastCopy)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
    this.attributeBuffer = newArrayBuffer;
  }
  _resizeIndexBuffer(size) {
    const indexBuffer = this.indexBuffer;
    let newSize = Math.max(size, indexBuffer.length * 1.5);
    newSize += newSize % 2;
    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
      for (let i = 0; i < indexBuffer.length; i++) {
        newIndexBuffer[i] = indexBuffer[i];
      }
    } else {
      (0,_renderers_shared_buffer_utils_fastCopy_mjs__WEBPACK_IMPORTED_MODULE_5__.fastCopy)(indexBuffer.buffer, newIndexBuffer.buffer);
    }
    this.indexBuffer = newIndexBuffer;
  }
  packQuadIndex(indexBuffer, index, indicesOffset) {
    indexBuffer[index] = indicesOffset + 0;
    indexBuffer[index + 1] = indicesOffset + 1;
    indexBuffer[index + 2] = indicesOffset + 2;
    indexBuffer[index + 3] = indicesOffset + 0;
    indexBuffer[index + 4] = indicesOffset + 2;
    indexBuffer[index + 5] = indicesOffset + 3;
  }
  packIndex(element, indexBuffer, index, indicesOffset) {
    const indices = element.indices;
    const size = element.indexSize;
    const indexOffset = element.indexOffset;
    const attributeOffset = element.attributeOffset;
    for (let i = 0; i < size; i++) {
      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;
    }
  }
  destroy() {
    for (let i = 0; i < this.batches.length; i++) {
      returnBatchToPool(this.batches[i]);
    }
    this.batches = null;
    for (let i = 0; i < this._elements.length; i++) {
      this._elements[i]._batch = null;
    }
    this._elements = null;
    this.indexBuffer = null;
    this.attributeBuffer.destroy();
    this.attributeBuffer = null;
  }
};
_Batcher.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let Batcher = _Batcher;


//# sourceMappingURL=Batcher.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BatcherPipe: () => (/* binding */ BatcherPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _DefaultBatcher_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultBatcher.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs");




"use strict";
const _BatcherPipe = class _BatcherPipe {
  constructor(renderer, adaptor) {
    this.state = _renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
    /** A record of all active batchers, keyed by their names */
    this._activeBatches = /* @__PURE__ */ Object.create(null);
    this.renderer = renderer;
    this._adaptor = adaptor;
    this._adaptor.init?.(this);
  }
  static getBatcher(name) {
    return new this._availableBatchers[name]();
  }
  buildStart(instructionSet) {
    let batchers = this._batchersByInstructionSet[instructionSet.uid];
    if (!batchers) {
      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
      batchers.default || (batchers.default = new _DefaultBatcher_mjs__WEBPACK_IMPORTED_MODULE_1__.DefaultBatcher());
    }
    this._activeBatches = batchers;
    this._activeBatch = this._activeBatches.default;
    for (const i in this._activeBatches) {
      this._activeBatches[i].begin();
    }
  }
  addToBatch(batchableObject, instructionSet) {
    if (this._activeBatch.name !== batchableObject.batcherName) {
      this._activeBatch.break(instructionSet);
      let batch = this._activeBatches[batchableObject.batcherName];
      if (!batch) {
        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);
        batch.begin();
      }
      this._activeBatch = batch;
    }
    this._activeBatch.add(batchableObject);
  }
  break(instructionSet) {
    this._activeBatch.break(instructionSet);
  }
  buildEnd(instructionSet) {
    this._activeBatch.break(instructionSet);
    const batches = this._activeBatches;
    for (const i in batches) {
      const batch = batches[i];
      const geometry = batch.geometry;
      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
    }
  }
  upload(instructionSet) {
    const batchers = this._batchersByInstructionSet[instructionSet.uid];
    for (const i in batchers) {
      const batcher = batchers[i];
      const geometry = batcher.geometry;
      if (batcher.dirty) {
        batcher.dirty = false;
        geometry.buffers[0].update(batcher.attributeSize * 4);
      }
    }
  }
  execute(batch) {
    if (batch.action === "startBatch") {
      const batcher = batch.batcher;
      const geometry = batcher.geometry;
      const shader = batcher.shader;
      this._adaptor.start(this, geometry, shader);
    }
    this._adaptor.execute(this, batch);
  }
  destroy() {
    this.state = null;
    this.renderer = null;
    this._adaptor = null;
    for (const i in this._activeBatches) {
      this._activeBatches[i].destroy();
    }
    this._activeBatches = null;
  }
};
/** @ignore */
_BatcherPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.CanvasPipes
  ],
  name: "batch"
};
_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
let BatcherPipe = _BatcherPipe;
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.extensions.handleByMap(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.Batcher, BatcherPipe._availableBatchers);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.extensions.add(_DefaultBatcher_mjs__WEBPACK_IMPORTED_MODULE_1__.DefaultBatcher);


//# sourceMappingURL=BatcherPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultBatcher: () => (/* binding */ DefaultBatcher)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _Batcher_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Batcher.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs");
/* harmony import */ var _BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BatchGeometry.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs");





"use strict";
let defaultShader = null;
const _DefaultBatcher = class _DefaultBatcher extends _Batcher_mjs__WEBPACK_IMPORTED_MODULE_0__.Batcher {
  constructor() {
    super(...arguments);
    this.geometry = new _BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__.BatchGeometry();
    this.shader = defaultShader || (defaultShader = new _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_2__.DefaultShader(this.maxTextures));
    this.name = _DefaultBatcher.extension.name;
    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */
    this.vertexSize = 6;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(element, float32View, uint32View, index, textureId) {
    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
    const wt = element.transform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const { positions, uvs } = element;
    const argb = element.color;
    const offset = element.attributeOffset;
    const end = offset + element.attributeSize;
    for (let i = offset; i < end; i++) {
      const i2 = i * 2;
      const x = positions[i2];
      const y = positions[i2 + 1];
      float32View[index++] = a * x + c * y + tx;
      float32View[index++] = d * y + b * x + ty;
      float32View[index++] = uvs[i2];
      float32View[index++] = uvs[i2 + 1];
      uint32View[index++] = argb;
      uint32View[index++] = textureIdAndRound;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(element, float32View, uint32View, index, textureId) {
    const texture = element.texture;
    const wt = element.transform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const bounds = element.bounds;
    const w0 = bounds.maxX;
    const w1 = bounds.minX;
    const h0 = bounds.maxY;
    const h1 = bounds.minY;
    const uvs = texture.uvs;
    const argb = element.color;
    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
    float32View[index + 0] = a * w1 + c * h1 + tx;
    float32View[index + 1] = d * h1 + b * w1 + ty;
    float32View[index + 2] = uvs.x0;
    float32View[index + 3] = uvs.y0;
    uint32View[index + 4] = argb;
    uint32View[index + 5] = textureIdAndRound;
    float32View[index + 6] = a * w0 + c * h1 + tx;
    float32View[index + 7] = d * h1 + b * w0 + ty;
    float32View[index + 8] = uvs.x1;
    float32View[index + 9] = uvs.y1;
    uint32View[index + 10] = argb;
    uint32View[index + 11] = textureIdAndRound;
    float32View[index + 12] = a * w0 + c * h0 + tx;
    float32View[index + 13] = d * h0 + b * w0 + ty;
    float32View[index + 14] = uvs.x2;
    float32View[index + 15] = uvs.y2;
    uint32View[index + 16] = argb;
    uint32View[index + 17] = textureIdAndRound;
    float32View[index + 18] = a * w1 + c * h0 + tx;
    float32View[index + 19] = d * h0 + b * w1 + ty;
    float32View[index + 20] = uvs.x3;
    float32View[index + 21] = uvs.y3;
    uint32View[index + 22] = argb;
    uint32View[index + 23] = textureIdAndRound;
  }
};
/** @ignore */
_DefaultBatcher.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.Batcher
  ],
  name: "default"
};
let DefaultBatcher = _DefaultBatcher;


//# sourceMappingURL=DefaultBatcher.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultShader: () => (/* binding */ DefaultShader)
/* harmony export */ });
/* harmony import */ var _high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../high-shader/shader-bits/colorBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs");
/* harmony import */ var _high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../high-shader/shader-bits/generateTextureBatchBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs");
/* harmony import */ var _high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../renderers/gl/shader/getBatchSamplersUniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs");
/* harmony import */ var _renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");







"use strict";
class DefaultShader extends _renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__.Shader {
  constructor(maxTextures) {
    const glProgram = (0,_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.compileHighShaderGlProgram)({
      name: "batch",
      bits: [
        _high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_2__.colorBitGl,
        (0,_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_3__.generateTextureBatchBitGl)(maxTextures),
        _high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_4__.roundPixelsBitGl
      ]
    });
    const gpuProgram = (0,_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.compileHighShaderGpuProgram)({
      name: "batch",
      bits: [
        _high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_2__.colorBit,
        (0,_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_3__.generateTextureBatchBit)(maxTextures),
        _high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_4__.roundPixelsBit
      ]
    });
    super({
      glProgram,
      gpuProgram,
      resources: {
        batchSamplers: (0,_renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.getBatchSamplersUniformGroup)(maxTextures)
      }
    });
  }
}


//# sourceMappingURL=DefaultShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileHighShaderGlProgram: () => (/* binding */ compileHighShaderGlProgram),
/* harmony export */   compileHighShaderGpuProgram: () => (/* binding */ compileHighShaderGpuProgram)
/* harmony export */ });
/* harmony import */ var _renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _compiler_compileHighShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compiler/compileHighShader.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs");
/* harmony import */ var _defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultProgramTemplate.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs");
/* harmony import */ var _shader_bits_globalUniformsBit_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader-bits/globalUniformsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs");






"use strict";
function compileHighShaderGpuProgram({ bits, name }) {
  const source = (0,_compiler_compileHighShader_mjs__WEBPACK_IMPORTED_MODULE_0__.compileHighShader)({
    template: {
      fragment: _defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_1__.fragmentGPUTemplate,
      vertex: _defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_1__.vertexGPUTemplate
    },
    bits: [
      _shader_bits_globalUniformsBit_mjs__WEBPACK_IMPORTED_MODULE_2__.globalUniformsBit,
      ...bits
    ]
  });
  return _renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_3__.GpuProgram.from({
    name,
    vertex: {
      source: source.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name }) {
  return new _renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.GlProgram({
    name,
    ...(0,_compiler_compileHighShader_mjs__WEBPACK_IMPORTED_MODULE_0__.compileHighShaderGl)({
      template: {
        vertex: _defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_1__.vertexGlTemplate,
        fragment: _defaultProgramTemplate_mjs__WEBPACK_IMPORTED_MODULE_1__.fragmentGlTemplate
      },
      bits: [
        _shader_bits_globalUniformsBit_mjs__WEBPACK_IMPORTED_MODULE_2__.globalUniformsBitGl,
        ...bits
      ]
    })
  });
}


//# sourceMappingURL=compileHighShaderToProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileHighShader: () => (/* binding */ compileHighShader),
/* harmony export */   compileHighShaderGl: () => (/* binding */ compileHighShaderGl)
/* harmony export */ });
/* harmony import */ var _utils_addBits_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/addBits.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs");
/* harmony import */ var _utils_compileHooks_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/compileHooks.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs");
/* harmony import */ var _utils_compileInputs_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/compileInputs.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs");
/* harmony import */ var _utils_compileOutputs_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/compileOutputs.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs");
/* harmony import */ var _utils_injectBits_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/injectBits.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs");






"use strict";
const cacheMap = /* @__PURE__ */ Object.create(null);
const bitCacheMap = /* @__PURE__ */ new Map();
let CACHE_UID = 0;
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex, fragment } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex, fragment, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);
  let compiledVertex = (0,_utils_compileInputs_mjs__WEBPACK_IMPORTED_MODULE_0__.compileInputs)(vertexFragments, template.vertex, true);
  compiledVertex = (0,_utils_compileOutputs_mjs__WEBPACK_IMPORTED_MODULE_1__.compileOutputs)(vertexFragments, compiledVertex);
  const compiledFragment = (0,_utils_compileInputs_mjs__WEBPACK_IMPORTED_MODULE_0__.compileInputs)(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a, b) => a - b).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex, fragment, bits) {
  const vertexParts = (0,_utils_compileHooks_mjs__WEBPACK_IMPORTED_MODULE_2__.compileHooks)(vertex);
  const fragmentParts = (0,_utils_compileHooks_mjs__WEBPACK_IMPORTED_MODULE_2__.compileHooks)(fragment);
  bits.forEach((shaderBit) => {
    (0,_utils_addBits_mjs__WEBPACK_IMPORTED_MODULE_3__.addBits)(shaderBit.vertex, vertexParts, shaderBit.name);
    (0,_utils_addBits_mjs__WEBPACK_IMPORTED_MODULE_3__.addBits)(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: (0,_utils_injectBits_mjs__WEBPACK_IMPORTED_MODULE_4__.injectBits)(vertex, vertexParts),
    fragment: (0,_utils_injectBits_mjs__WEBPACK_IMPORTED_MODULE_4__.injectBits)(fragment, fragmentParts)
  };
}


//# sourceMappingURL=compileHighShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addBits: () => (/* binding */ addBits)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");


"use strict";
function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i in srcParts) {
      const id = i.toLocaleLowerCase();
      const part = parts[id];
      if (part) {
        let sanitisedPart = srcParts[i];
        if (i === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`${i} placement hook does not exist in shader`);
      }
    }
  }
}


//# sourceMappingURL=addBits.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileHooks: () => (/* binding */ compileHooks),
/* harmony export */   findHooksRx: () => (/* binding */ findHooksRx)
/* harmony export */ });

const findHooksRx = /\{\{(.*?)\}\}/g;
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}


//# sourceMappingURL=compileHooks.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileInputs: () => (/* binding */ compileInputs)
/* harmony export */ });

function extractInputs(fragmentSource, out) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractInputs(fragment.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}


//# sourceMappingURL=compileInputs.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileOutputs: () => (/* binding */ compileOutputs)
/* harmony export */ });

function extractOutputs(fragmentSource, out) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractOutputs(fragment.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}


//# sourceMappingURL=compileOutputs.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatShader: () => (/* binding */ formatShader)
/* harmony export */ });

function formatShader(shader) {
  const spl = shader.split(/([\n{}])/g).map((a) => a.trim()).filter((a) => a.length);
  let indent = "";
  const formatted = spl.map((a) => {
    let indentedLine = indent + a;
    if (a === "{") {
      indent += "    ";
    } else if (a === "}") {
      indent = indent.substr(0, indent.length - 4);
      indentedLine = indent + a;
    }
    return indentedLine;
  }).join("\n");
  return formatted;
}


//# sourceMappingURL=formatShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   injectBits: () => (/* binding */ injectBits)
/* harmony export */ });

function injectBits(templateSrc, fragmentParts) {
  let out = templateSrc;
  for (const i in fragmentParts) {
    const parts = fragmentParts[i];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out = out.replace(`{{${i}}}`, `//-----${i} START-----//
${parts.join("\n")}
//----${i} FINISH----//`);
    } else {
      out = out.replace(`{{${i}}}`, "");
    }
  }
  return out;
}


//# sourceMappingURL=injectBits.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fragmentGPUTemplate: () => (/* binding */ fragmentGPUTemplate),
/* harmony export */   fragmentGlTemplate: () => (/* binding */ fragmentGlTemplate),
/* harmony export */   vertexGPUTemplate: () => (/* binding */ vertexGPUTemplate),
/* harmony export */   vertexGlTemplate: () => (/* binding */ vertexGlTemplate)
/* harmony export */ });

const vertexGPUTemplate = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
);
const fragmentGPUTemplate = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
);
const vertexGlTemplate = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
);
const fragmentGlTemplate = (
  /* glsl */
  `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`
);


//# sourceMappingURL=defaultProgramTemplate.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorBit: () => (/* binding */ colorBit),
/* harmony export */   colorBitGl: () => (/* binding */ colorBitGl)
/* harmony export */ });

const colorBit = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
};
const colorBitGl = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
};


//# sourceMappingURL=colorBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateTextureBatchBit: () => (/* binding */ generateTextureBatchBit),
/* harmony export */   generateTextureBatchBitGl: () => (/* binding */ generateTextureBatchBitGl)
/* harmony export */ });

const textureBatchBitGpuCache = {};
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i = 0; i < maxTextures; i++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i = 0; i < maxTextures; i++) {
      if (i === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures) {
  if (!textureBatchBitGpuCache[maxTextures]) {
    textureBatchBitGpuCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures];
}
const textureBatchBitGlCache = {};
function generateSampleGlSrc(maxTextures) {
  const src = [];
  for (let i = 0; i < maxTextures; i++) {
    if (i > 0) {
      src.push("else");
    }
    if (i < maxTextures - 1) {
      src.push(`if(vTextureId < ${i}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uTextures[${i}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures) {
  if (!textureBatchBitGlCache[maxTextures]) {
    textureBatchBitGlCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
        main: `

                ${generateSampleGlSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures];
}


//# sourceMappingURL=generateTextureBatchBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   globalUniformsBit: () => (/* binding */ globalUniformsBit),
/* harmony export */   globalUniformsBitGl: () => (/* binding */ globalUniformsBitGl),
/* harmony export */   globalUniformsUBOBitGl: () => (/* binding */ globalUniformsUBOBitGl)
/* harmony export */ });

const globalUniformsBit = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
};
const globalUniformsUBOBitGl = {
  name: "global-uniforms-ubo-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform globalUniforms {
            mat3 uProjectionMatrix;
            mat3 uWorldTransformMatrix;
            vec4 uWorldColorAlpha;
            vec2 uResolution;
          };
        `
    )
  }
};
const globalUniformsBitGl = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};


//# sourceMappingURL=globalUniformsBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   localUniformBit: () => (/* binding */ localUniformBit),
/* harmony export */   localUniformBitGl: () => (/* binding */ localUniformBitGl),
/* harmony export */   localUniformBitGroup2: () => (/* binding */ localUniformBitGroup2)
/* harmony export */ });

const localUniformBit = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* wgsl */
      `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
    ),
    end: (
      /* wgsl */
      `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    )
  }
};
const localUniformBitGroup2 = {
  ...localUniformBit,
  vertex: {
    ...localUniformBit.vertex,
    // replace the group!
    header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
  }
};
const localUniformBitGl = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* glsl */
      `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
    ),
    end: (
      /* glsl */
      `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    )
  }
};


//# sourceMappingURL=localUniformBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   roundPixelsBit: () => (/* binding */ roundPixelsBit),
/* harmony export */   roundPixelsBitGl: () => (/* binding */ roundPixelsBitGl)
/* harmony export */ });

const roundPixelsBit = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
};
const roundPixelsBitGl = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
};


//# sourceMappingURL=roundPixelsBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   textureBit: () => (/* binding */ textureBit),
/* harmony export */   textureBitGl: () => (/* binding */ textureBitGl)
/* harmony export */ });

const textureBit = {
  name: "texture-bit",
  vertex: {
    header: (
      /* wgsl */
      `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
    ),
    main: (
      /* wgsl */
      `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    )
  }
};
const textureBitGl = {
  name: "texture-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTextureMatrix;
        `
    ),
    main: (
      /* glsl */
      `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
        uniform sampler2D uTexture;

         
        `
    ),
    main: (
      /* glsl */
      `
            outColor = texture(uTexture, vUV);
        `
    )
  }
};


//# sourceMappingURL=textureBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/init.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/init.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _mask_alpha_AlphaMask_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mask/alpha/AlphaMask.mjs */ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs");
/* harmony import */ var _mask_color_ColorMask_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mask/color/ColorMask.mjs */ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs");
/* harmony import */ var _mask_stencil_StencilMask_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mask/stencil/StencilMask.mjs */ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs");
/* harmony import */ var _renderers_shared_texture_sources_BufferImageSource_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderers/shared/texture/sources/BufferImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs");
/* harmony import */ var _renderers_shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderers/shared/texture/sources/CanvasSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs");
/* harmony import */ var _renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderers/shared/texture/sources/ImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs");
/* harmony import */ var _renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderers/shared/texture/sources/VideoSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs");
/* harmony import */ var _renderers_shared_texture_utils_textureFrom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderers/shared/texture/utils/textureFrom.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs");











"use strict";
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.extensions.add(_mask_alpha_AlphaMask_mjs__WEBPACK_IMPORTED_MODULE_2__.AlphaMask, _mask_color_ColorMask_mjs__WEBPACK_IMPORTED_MODULE_3__.ColorMask, _mask_stencil_StencilMask_mjs__WEBPACK_IMPORTED_MODULE_4__.StencilMask, _renderers_shared_texture_sources_VideoSource_mjs__WEBPACK_IMPORTED_MODULE_5__.VideoSource, _renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_6__.ImageSource, _renderers_shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_7__.CanvasSource, _renderers_shared_texture_sources_BufferImageSource_mjs__WEBPACK_IMPORTED_MODULE_8__.BufferImageSource);
//# sourceMappingURL=init.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MaskEffectManager: () => (/* binding */ MaskEffectManager),
/* harmony export */   MaskEffectManagerClass: () => (/* binding */ MaskEffectManagerClass)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");



"use strict";
class MaskEffectManagerClass {
  constructor() {
    /**
     * @private
     */
    this._effectClasses = [];
    this._tests = [];
    this._initialized = false;
  }
  init() {
    if (this._initialized)
      return;
    this._initialized = true;
    this._effectClasses.forEach((test) => {
      this.add({
        test: test.test,
        maskClass: test
      });
    });
  }
  add(test) {
    this._tests.push(test);
  }
  getMaskEffect(item) {
    if (!this._initialized)
      this.init();
    for (let i = 0; i < this._tests.length; i++) {
      const test = this._tests[i];
      if (test.test(item)) {
        return _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(test.maskClass, item);
      }
    }
    return item;
  }
  returnMaskEffect(effect) {
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(effect);
  }
}
const MaskEffectManager = new MaskEffectManagerClass();
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.extensions.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.MaskEffect, MaskEffectManager._effectClasses);


//# sourceMappingURL=MaskEffectManager.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlphaMask: () => (/* binding */ AlphaMask)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/sprite/Sprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs");
/* harmony import */ var _utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/addMaskBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs");
/* harmony import */ var _utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/addMaskLocalBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs");





"use strict";
class AlphaMask {
  constructor(options) {
    this.priority = 0;
    this.inverse = false;
    this.pipe = "alphaMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.renderMaskToTexture = !(mask instanceof _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__.Sprite);
    this.mask.renderable = this.renderMaskToTexture;
    this.mask.includeInBuild = !this.renderMaskToTexture;
    this.mask.measurable = false;
  }
  reset() {
    this.mask.measurable = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    if (!this.inverse) {
      (0,_utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.addMaskBounds)(this.mask, bounds, skipUpdateTransform);
    }
  }
  addLocalBounds(bounds, localRoot) {
    (0,_utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_2__.addMaskLocalBounds)(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__.Sprite;
  }
}
AlphaMask.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.MaskEffect;


//# sourceMappingURL=AlphaMask.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlphaMaskPipe: () => (/* binding */ AlphaMaskPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../filters/FilterEffect.mjs */ "./node_modules/pixi.js/lib/filters/FilterEffect.mjs");
/* harmony import */ var _filters_mask_MaskFilter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../filters/mask/MaskFilter.mjs */ "./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs");
/* harmony import */ var _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scene/container/bounds/getGlobalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs");
/* harmony import */ var _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scene/sprite/Sprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _renderers_types_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../renderers/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");











"use strict";
const tempBounds = new _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__.Bounds();
class AlphaMaskEffect extends _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_1__.FilterEffect {
  constructor() {
    super();
    this.filters = [new _filters_mask_MaskFilter_mjs__WEBPACK_IMPORTED_MODULE_2__.MaskFilter({
      sprite: new _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_3__.Sprite(_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_4__.Texture.EMPTY),
      inverse: false,
      resolution: "inherit",
      antialias: "inherit"
    })];
  }
  get sprite() {
    return this.filters[0].sprite;
  }
  set sprite(value) {
    this.filters[0].sprite = value;
  }
  get inverse() {
    return this.filters[0].inverse;
  }
  set inverse(value) {
    this.filters[0].inverse = value;
  }
}
class AlphaMaskPipe {
  constructor(renderer) {
    this._activeMaskStage = [];
    this._renderer = renderer;
  }
  push(mask, maskedContainer, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "pushMaskBegin",
      mask,
      inverse: maskedContainer._maskOptions.inverse,
      canBundle: false,
      maskedContainer
    });
    mask.inverse = maskedContainer._maskOptions.inverse;
    if (mask.renderMaskToTexture) {
      const maskContainer = mask.mask;
      maskContainer.includeInBuild = true;
      maskContainer.collectRenderables(
        instructionSet,
        renderer,
        null
      );
      maskContainer.includeInBuild = false;
    }
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "pushMaskEnd",
      mask,
      maskedContainer,
      inverse: maskedContainer._maskOptions.inverse,
      canBundle: false
    });
  }
  pop(mask, _maskedContainer, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "popMaskEnd",
      mask,
      inverse: _maskedContainer._maskOptions.inverse,
      canBundle: false
    });
  }
  execute(instruction) {
    const renderer = this._renderer;
    const renderMask = instruction.mask.renderMaskToTexture;
    if (instruction.action === "pushMaskBegin") {
      const filterEffect = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.BigPool.get(AlphaMaskEffect);
      filterEffect.inverse = instruction.inverse;
      if (renderMask) {
        instruction.mask.mask.measurable = true;
        const bounds = (0,_scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_6__.getGlobalBounds)(instruction.mask.mask, true, tempBounds);
        instruction.mask.mask.measurable = false;
        bounds.ceil();
        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        const filterTexture = _renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_7__.TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          colorTextureSource._resolution,
          colorTextureSource.antialias
        );
        renderer.renderTarget.push(filterTexture, true);
        renderer.globalUniforms.push({
          offset: bounds,
          worldColor: 4294967295
        });
        const sprite = filterEffect.sprite;
        sprite.texture = filterTexture;
        sprite.worldTransform.tx = bounds.minX;
        sprite.worldTransform.ty = bounds.minY;
        this._activeMaskStage.push({
          filterEffect,
          maskedContainer: instruction.maskedContainer,
          filterTexture
        });
      } else {
        filterEffect.sprite = instruction.mask.mask;
        this._activeMaskStage.push({
          filterEffect,
          maskedContainer: instruction.maskedContainer
        });
      }
    } else if (instruction.action === "pushMaskEnd") {
      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
      if (renderMask) {
        if (renderer.type === _renderers_types_mjs__WEBPACK_IMPORTED_MODULE_8__.RendererType.WEBGL) {
          renderer.renderTarget.finishRenderPass();
        }
        renderer.renderTarget.pop();
        renderer.globalUniforms.pop();
      }
      renderer.filter.push({
        renderPipeId: "filter",
        action: "pushFilter",
        container: maskData.maskedContainer,
        filterEffect: maskData.filterEffect,
        canBundle: false
      });
    } else if (instruction.action === "popMaskEnd") {
      renderer.filter.pop();
      const maskData = this._activeMaskStage.pop();
      if (renderMask) {
        _renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_7__.TexturePool.returnTexture(maskData.filterTexture);
      }
      _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.BigPool.return(maskData.filterEffect);
    }
  }
  destroy() {
    this._renderer = null;
    this._activeMaskStage = null;
  }
}
/** @ignore */
AlphaMaskPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_9__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_9__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_9__.ExtensionType.CanvasPipes
  ],
  name: "alphaMask"
};


//# sourceMappingURL=AlphaMaskPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorMask: () => (/* binding */ ColorMask)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class ColorMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "colorMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
  }
  destroy() {
  }
  static test(mask) {
    return typeof mask === "number";
  }
}
ColorMask.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.MaskEffect;


//# sourceMappingURL=ColorMask.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorMaskPipe: () => (/* binding */ ColorMaskPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class ColorMaskPipe {
  constructor(renderer) {
    this._colorStack = [];
    this._colorStackIndex = 0;
    this._currentColor = 0;
    this._renderer = renderer;
  }
  buildStart() {
    this._colorStack[0] = 15;
    this._colorStackIndex = 1;
    this._currentColor = 15;
  }
  push(mask, _container, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
    const currentColor = this._colorStack[this._colorStackIndex];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
    this._colorStackIndex++;
  }
  pop(_mask, _container, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    this._colorStackIndex--;
    const currentColor = colorStack[this._colorStackIndex - 1];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
  }
  execute(instruction) {
    const renderer = this._renderer;
    renderer.colorMask.setMask(instruction.colorMask);
  }
  destroy() {
    this._colorStack = null;
  }
}
/** @ignore */
ColorMaskPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasPipes
  ],
  name: "colorMask"
};


//# sourceMappingURL=ColorMaskPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScissorMask: () => (/* binding */ ScissorMask)
/* harmony export */ });
/* harmony import */ var _utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/addMaskBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs");
/* harmony import */ var _utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/addMaskLocalBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs");



"use strict";
class ScissorMask {
  constructor(mask) {
    this.priority = 0;
    this.pipe = "scissorMask";
    this.mask = mask;
    this.mask.renderable = false;
    this.mask.measurable = false;
  }
  addBounds(bounds, skipUpdateTransform) {
    (0,_utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_0__.addMaskBounds)(this.mask, bounds, skipUpdateTransform);
  }
  addLocalBounds(bounds, localRoot) {
    (0,_utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.addMaskLocalBounds)(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  reset() {
    this.mask.measurable = true;
    this.mask = null;
  }
  destroy() {
    this.reset();
  }
}


//# sourceMappingURL=ScissorMask.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StencilMask: () => (/* binding */ StencilMask)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/addMaskBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs");
/* harmony import */ var _utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/addMaskLocalBounds.mjs */ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs");





"use strict";
class StencilMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "stencilMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.mask.includeInBuild = false;
    this.mask.measurable = false;
  }
  reset() {
    this.mask.measurable = true;
    this.mask.includeInBuild = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    (0,_utils_addMaskBounds_mjs__WEBPACK_IMPORTED_MODULE_0__.addMaskBounds)(this.mask, bounds, skipUpdateTransform);
  }
  addLocalBounds(bounds, localRoot) {
    (0,_utils_addMaskLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.addMaskLocalBounds)(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__.Container;
  }
}
StencilMask.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.MaskEffect;


//# sourceMappingURL=StencilMask.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StencilMaskPipe: () => (/* binding */ StencilMaskPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _renderers_gl_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../renderers/gl/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs");
/* harmony import */ var _renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderers/shared/state/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");




"use strict";
class StencilMaskPipe {
  constructor(renderer) {
    // used when building and also when executing..
    this._maskStackHash = {};
    this._maskHash = /* @__PURE__ */ new WeakMap();
    this._renderer = renderer;
  }
  push(mask, _container, instructionSet) {
    var _a;
    const effect = mask;
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "pushMaskBegin",
      mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const maskContainer = effect.mask;
    maskContainer.includeInBuild = true;
    if (!this._maskHash.has(effect)) {
      this._maskHash.set(effect, {
        instructionsStart: 0,
        instructionsLength: 0
      });
    }
    const maskData = this._maskHash.get(effect);
    maskData.instructionsStart = instructionSet.instructionSize;
    maskContainer.collectRenderables(
      instructionSet,
      renderer,
      null
    );
    maskContainer.includeInBuild = false;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "pushMaskEnd",
      mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
    maskData.instructionsLength = instructionsLength;
    const renderTargetUid = renderer.renderTarget.renderTarget.uid;
    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
  }
  pop(mask, _container, instructionSet) {
    const effect = mask;
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "popMaskBegin",
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const maskData = this._maskHash.get(mask);
    for (let i = 0; i < maskData.instructionsLength; i++) {
      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
    }
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "popMaskEnd",
      canBundle: false
    });
  }
  execute(instruction) {
    var _a;
    const renderer = this._renderer;
    const renderTargetUid = renderer.renderTarget.renderTarget.uid;
    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
    if (instruction.action === "pushMaskBegin") {
      renderer.renderTarget.ensureDepthStencil();
      renderer.stencil.setStencilMode(_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
      maskStackIndex++;
      renderer.colorMask.setMask(0);
    } else if (instruction.action === "pushMaskEnd") {
      if (instruction.inverse) {
        renderer.stencil.setStencilMode(_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
      } else {
        renderer.stencil.setStencilMode(_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
      }
      renderer.colorMask.setMask(15);
    } else if (instruction.action === "popMaskBegin") {
      renderer.colorMask.setMask(0);
      if (maskStackIndex !== 0) {
        renderer.stencil.setStencilMode(_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
      } else {
        renderer.renderTarget.clear(null, _renderers_gl_const_mjs__WEBPACK_IMPORTED_MODULE_1__.CLEAR.STENCIL);
        renderer.stencil.setStencilMode(_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.DISABLED, maskStackIndex);
      }
      maskStackIndex--;
    } else if (instruction.action === "popMaskEnd") {
      if (instruction.inverse) {
        renderer.stencil.setStencilMode(_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
      } else {
        renderer.stencil.setStencilMode(_renderers_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
      }
      renderer.colorMask.setMask(15);
    }
    this._maskStackHash[renderTargetUid] = maskStackIndex;
  }
  destroy() {
    this._renderer = null;
    this._maskStackHash = null;
    this._maskHash = null;
  }
}
StencilMaskPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.CanvasPipes
  ],
  name: "stencilMask"
};


//# sourceMappingURL=StencilMaskPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addMaskBounds: () => (/* binding */ addMaskBounds)
/* harmony export */ });
/* harmony import */ var _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/container/bounds/getGlobalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs");



"use strict";
const tempBounds = new _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__.Bounds();
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds;
  mask.measurable = true;
  (0,_scene_container_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.getGlobalBounds)(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}


//# sourceMappingURL=addMaskBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addMaskLocalBounds: () => (/* binding */ addMaskLocalBounds),
/* harmony export */   getMatrixRelativeToParent: () => (/* binding */ getMatrixRelativeToParent)
/* harmony export */ });
/* harmony import */ var _scene_container_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scene/container/bounds/getLocalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs");
/* harmony import */ var _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scene/container/bounds/utils/matrixAndBoundsPool.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");




"use strict";
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.boundsPool.get();
  mask.measurable = true;
  const tempMatrix = _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.matrixPool.get().identity();
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);
  (0,_scene_container_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.getLocalBounds)(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
  _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.matrixPool.return(tempMatrix);
  _scene_container_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.boundsPool.return(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("Mask bounds, renderable is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    target.updateLocalTransform();
    matrix.append(target.localTransform);
  }
  return matrix;
}


//# sourceMappingURL=addMaskLocalBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autoDetectRenderer: () => (/* binding */ autoDetectRenderer)
/* harmony export */ });
/* harmony import */ var _utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/browser/isWebGLSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs");
/* harmony import */ var _utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/browser/isWebGPUSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs");
/* harmony import */ var _shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/system/AbstractRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs");




"use strict";
const renderPriority = ["webgl", "webgpu", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  let finalOptions = {};
  for (let i = 0; i < preferredOrder.length; i++) {
    const rendererType = preferredOrder[i];
    if (rendererType === "webgpu" && await (0,_utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_0__.isWebGPUSupported)()) {
      const { WebGPURenderer } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./gpu/WebGPURenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"));
      RendererClass = WebGPURenderer;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && (0,_utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_1__.isWebGLSupported)(
      options.failIfMajorPerformanceCaveat ?? _shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__.AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./gl/WebGLRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"));
      RendererClass = WebGLRenderer;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      throw new Error("CanvasRenderer is not yet implemented");
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  if (!RendererClass) {
    throw new Error("No available renderer for the current environment");
  }
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}


//# sourceMappingURL=autoDetectRenderer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlBackBufferSystem: () => (/* binding */ GlBackBufferSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/geometry/Geometry.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs");
/* harmony import */ var _shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");









"use strict";
const bigTriangleGeometry = new _shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__.Geometry({
  attributes: {
    aPosition: [
      -1,
      -1,
      // Bottom left corner
      3,
      -1,
      // Bottom right corner, extending beyond right edge
      -1,
      3
      // Top left corner, extending beyond top edge
    ]
  }
});
const _GlBackBufferSystem = class _GlBackBufferSystem {
  constructor(renderer) {
    /** if true, the back buffer is used */
    this.useBackBuffer = false;
    this._useBackBufferThisRender = false;
    this._renderer = renderer;
  }
  init(options = {}) {
    const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };
    this.useBackBuffer = useBackBuffer;
    this._antialias = antialias;
    if (!this._renderer.context.supports.msaa) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__.warn)("antialiasing, is not supported on when using the back buffer");
      this._antialias = false;
    }
    this._state = _shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_2__.State.for2d();
    const bigTriangleProgram = new _shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__.GlProgram({
      vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
      fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
      name: "big-triangle"
    });
    this._bigTriangleShader = new _shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_4__.Shader({
      glProgram: bigTriangleProgram,
      resources: {
        uTexture: _shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__.Texture.WHITE.source
      }
    });
  }
  /**
   * This is called before the RenderTargetSystem is started. This is where
   * we replace the target with the back buffer if required.
   * @param options - The options for this render.
   */
  renderStart(options) {
    const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
    this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
    if (this._useBackBufferThisRender) {
      const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
      this._targetTexture = renderTarget2.colorTexture;
      options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
    }
  }
  renderEnd() {
    this._presentBackBuffer();
  }
  _presentBackBuffer() {
    const renderer = this._renderer;
    renderer.renderTarget.finishRenderPass();
    if (!this._useBackBufferThisRender)
      return;
    renderer.renderTarget.bind(this._targetTexture, false);
    this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
    renderer.encoder.draw({
      geometry: bigTriangleGeometry,
      shader: this._bigTriangleShader,
      state: this._state
    });
  }
  _getBackBufferTexture(targetSourceTexture) {
    this._backBufferTexture = this._backBufferTexture || new _shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__.Texture({
      source: new _shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_6__.TextureSource({
        width: targetSourceTexture.width,
        height: targetSourceTexture.height,
        resolution: targetSourceTexture._resolution,
        antialias: this._antialias
      })
    });
    this._backBufferTexture.source.resize(
      targetSourceTexture.width,
      targetSourceTexture.height,
      targetSourceTexture._resolution
    );
    return this._backBufferTexture;
  }
  /** destroys the back buffer */
  destroy() {
    if (this._backBufferTexture) {
      this._backBufferTexture.destroy();
      this._backBufferTexture = null;
    }
  }
};
/** @ignore */
_GlBackBufferSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.WebGLSystem
  ],
  name: "backBuffer",
  priority: 1
};
/** default options for the back buffer system */
_GlBackBufferSystem.defaultOptions = {
  /** if true will use the back buffer where required */
  useBackBuffer: false
};
let GlBackBufferSystem = _GlBackBufferSystem;


//# sourceMappingURL=GlBackBufferSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlColorMaskSystem: () => (/* binding */ GlColorMaskSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class GlColorMaskSystem {
  constructor(renderer) {
    this._colorMaskCache = 15;
    this._renderer = renderer;
  }
  setMask(colorMask) {
    if (this._colorMaskCache === colorMask)
      return;
    this._colorMaskCache = colorMask;
    this._renderer.gl.colorMask(
      !!(colorMask & 8),
      !!(colorMask & 4),
      !!(colorMask & 2),
      !!(colorMask & 1)
    );
  }
}
/** @ignore */
GlColorMaskSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLSystem
  ],
  name: "colorMask"
};


//# sourceMappingURL=GlColorMaskSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlEncoderSystem: () => (/* binding */ GlEncoderSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class GlEncoderSystem {
  constructor(renderer) {
    this.commandFinished = Promise.resolve();
    this._renderer = renderer;
  }
  setGeometry(geometry, shader) {
    this._renderer.geometry.bind(geometry, shader.glProgram);
  }
  finishRenderPass() {
  }
  draw(options) {
    const renderer = this._renderer;
    const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
    renderer.shader.bind(shader, skipSync);
    renderer.geometry.bind(geometry, renderer.shader._activeProgram);
    if (state) {
      renderer.state.set(state);
    }
    renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
GlEncoderSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLSystem
  ],
  name: "encoder"
};


//# sourceMappingURL=GlEncoderSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlRenderTarget: () => (/* binding */ GlRenderTarget)
/* harmony export */ });

class GlRenderTarget {
  constructor() {
    this.width = -1;
    this.height = -1;
    this.msaa = false;
    this.msaaRenderBuffer = [];
  }
}


//# sourceMappingURL=GlRenderTarget.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlStencilSystem: () => (/* binding */ GlStencilSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _gpu_state_GpuStencilModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gpu/state/GpuStencilModesToPixi.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs");
/* harmony import */ var _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/state/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");




"use strict";
class GlStencilSystem {
  constructor(renderer) {
    this._stencilCache = {
      enabled: false,
      stencilReference: 0,
      stencilMode: _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.NONE
    };
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  contextChange(gl) {
    this._gl = gl;
    this._comparisonFuncMapping = {
      always: gl.ALWAYS,
      never: gl.NEVER,
      equal: gl.EQUAL,
      "not-equal": gl.NOTEQUAL,
      less: gl.LESS,
      "less-equal": gl.LEQUAL,
      greater: gl.GREATER,
      "greater-equal": gl.GEQUAL
    };
    this._stencilOpsMapping = {
      keep: gl.KEEP,
      zero: gl.ZERO,
      replace: gl.REPLACE,
      invert: gl.INVERT,
      "increment-clamp": gl.INCR,
      "decrement-clamp": gl.DECR,
      "increment-wrap": gl.INCR_WRAP,
      "decrement-wrap": gl.DECR_WRAP
    };
    this.resetState();
  }
  onRenderTargetChange(renderTarget) {
    if (this._activeRenderTarget === renderTarget)
      return;
    this._activeRenderTarget = renderTarget;
    let stencilState = this._renderTargetStencilState[renderTarget.uid];
    if (!stencilState) {
      stencilState = this._renderTargetStencilState[renderTarget.uid] = {
        stencilMode: _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.DISABLED,
        stencilReference: 0
      };
    }
    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
  }
  resetState() {
    this._stencilCache.enabled = false;
    this._stencilCache.stencilMode = _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.NONE;
    this._stencilCache.stencilReference = 0;
  }
  setStencilMode(stencilMode, stencilReference) {
    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
    const gl = this._gl;
    const mode = _gpu_state_GpuStencilModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuStencilModesToPixi[stencilMode];
    const _stencilCache = this._stencilCache;
    stencilState.stencilMode = stencilMode;
    stencilState.stencilReference = stencilReference;
    if (stencilMode === _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.DISABLED) {
      if (this._stencilCache.enabled) {
        this._stencilCache.enabled = false;
        gl.disable(gl.STENCIL_TEST);
      }
      return;
    }
    if (!this._stencilCache.enabled) {
      this._stencilCache.enabled = true;
      gl.enable(gl.STENCIL_TEST);
    }
    if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
      _stencilCache.stencilMode = stencilMode;
      _stencilCache.stencilReference = stencilReference;
      gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
      gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
    }
  }
}
/** @ignore */
GlStencilSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLSystem
  ],
  name: "stencil"
};


//# sourceMappingURL=GlStencilSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlUboSystem: () => (/* binding */ GlUboSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_shader_UboSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/shader/UboSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs");
/* harmony import */ var _shader_utils_createUboElementsSTD40_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader/utils/createUboElementsSTD40.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs");
/* harmony import */ var _shader_utils_createUboSyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader/utils/createUboSyncSTD40.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs");





"use strict";
class GlUboSystem extends _shared_shader_UboSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.UboSystem {
  constructor() {
    super({
      createUboElements: _shader_utils_createUboElementsSTD40_mjs__WEBPACK_IMPORTED_MODULE_1__.createUboElementsSTD40,
      generateUboSync: _shader_utils_createUboSyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_2__.createUboSyncFunctionSTD40
    });
  }
}
/** @ignore */
GlUboSystem.extension = {
  type: [_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGLSystem],
  name: "ubo"
};


//# sourceMappingURL=GlUboSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLRenderer: () => (/* binding */ WebGLRenderer)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _scene_graphics_gl_GlGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../scene/graphics/gl/GlGraphicsAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs");
/* harmony import */ var _scene_mesh_gl_GlMeshAdaptor_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../scene/mesh/gl/GlMeshAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs");
/* harmony import */ var _batcher_gl_GlBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../batcher/gl/GlBatchAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs");
/* harmony import */ var _shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../shared/system/AbstractRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs");
/* harmony import */ var _shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/system/SharedSystems.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _buffer_GlBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buffer/GlBufferSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs");
/* harmony import */ var _context_GlContextSystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context/GlContextSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs");
/* harmony import */ var _geometry_GlGeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./geometry/GlGeometrySystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs");
/* harmony import */ var _GlBackBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GlBackBufferSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs");
/* harmony import */ var _GlColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./GlColorMaskSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs");
/* harmony import */ var _GlEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./GlEncoderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs");
/* harmony import */ var _GlStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./GlStencilSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs");
/* harmony import */ var _GlUboSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlUboSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs");
/* harmony import */ var _renderTarget_GlRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderTarget/GlRenderTargetSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs");
/* harmony import */ var _shader_GlShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shader/GlShaderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs");
/* harmony import */ var _shader_GlUniformGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shader/GlUniformGroupSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs");
/* harmony import */ var _state_GlStateSystem_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./state/GlStateSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs");
/* harmony import */ var _texture_GlTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture/GlTextureSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs");





















"use strict";
const DefaultWebGLSystems = [
  ..._shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_0__.SharedSystems,
  _GlUboSystem_mjs__WEBPACK_IMPORTED_MODULE_1__.GlUboSystem,
  _GlBackBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_2__.GlBackBufferSystem,
  _context_GlContextSystem_mjs__WEBPACK_IMPORTED_MODULE_3__.GlContextSystem,
  _buffer_GlBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_4__.GlBufferSystem,
  _texture_GlTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_5__.GlTextureSystem,
  _renderTarget_GlRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_6__.GlRenderTargetSystem,
  _geometry_GlGeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_7__.GlGeometrySystem,
  _shader_GlUniformGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_8__.GlUniformGroupSystem,
  _shader_GlShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_9__.GlShaderSystem,
  _GlEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_10__.GlEncoderSystem,
  _state_GlStateSystem_mjs__WEBPACK_IMPORTED_MODULE_11__.GlStateSystem,
  _GlStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.GlStencilSystem,
  _GlColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_13__.GlColorMaskSystem
];
const DefaultWebGLPipes = [..._shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_0__.SharedRenderPipes];
const DefaultWebGLAdapters = [_batcher_gl_GlBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_14__.GlBatchAdaptor, _scene_mesh_gl_GlMeshAdaptor_mjs__WEBPACK_IMPORTED_MODULE_15__.GlMeshAdaptor, _scene_graphics_gl_GlGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_16__.GlGraphicsAdaptor];
const systems = [];
const renderPipes = [];
const renderPipeAdaptors = [];
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.handleByNamedList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.ExtensionType.WebGLSystem, systems);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.handleByNamedList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.ExtensionType.WebGLPipes, renderPipes);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.handleByNamedList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
class WebGLRenderer extends _shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_18__.AbstractRenderer {
  constructor() {
    const systemConfig = {
      name: "webgl",
      type: _types_mjs__WEBPACK_IMPORTED_MODULE_19__.RendererType.WEBGL,
      systems,
      renderPipes,
      renderPipeAdaptors
    };
    super(systemConfig);
  }
}


//# sourceMappingURL=WebGLRenderer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlBuffer: () => (/* binding */ GlBuffer)
/* harmony export */ });

class GlBuffer {
  constructor(buffer, type) {
    this._lastBindBaseLocation = -1;
    this._lastBindCallId = -1;
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.type = type;
  }
}


//# sourceMappingURL=GlBuffer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlBufferSystem: () => (/* binding */ GlBufferSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs");
/* harmony import */ var _GlBuffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GlBuffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs");





"use strict";
class GlBufferSystem {
  /**
   * @param {Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    /** Cache keeping track of the base bound buffer bases */
    this._boundBufferBases = /* @__PURE__ */ Object.create(null);
    this._minBaseLocation = 0;
    this._nextBindBaseIndex = this._minBaseLocation;
    this._bindCallId = 0;
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
  }
  /**
   * @ignore
   */
  destroy() {
    this._renderer = null;
    this._gl = null;
    this._gpuBuffers = null;
    this._boundBufferBases = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    const gl = this._gl = this._renderer.gl;
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  }
  getGlBuffer(buffer) {
    return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
  }
  /**
   * This binds specified buffer. On first run, it will create the webGL buffers for the context too
   * @param buffer - the buffer to bind to the renderer
   */
  bind(buffer) {
    const { _gl: gl } = this;
    const glBuffer = this.getGlBuffer(buffer);
    gl.bindBuffer(glBuffer.type, glBuffer.buffer);
  }
  /**
   * Binds an uniform buffer to at the given index.
   *
   * A cache is used so a buffer will not be bound again if already bound.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind it to.
   */
  bindBufferBase(glBuffer, index) {
    const { _gl: gl } = this;
    if (this._boundBufferBases[index] !== glBuffer) {
      this._boundBufferBases[index] = glBuffer;
      glBuffer._lastBindBaseLocation = index;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  nextBindBase(hasTransformFeedback) {
    this._bindCallId++;
    this._minBaseLocation = 0;
    if (hasTransformFeedback) {
      this._boundBufferBases[0] = null;
      this._minBaseLocation = 1;
      if (this._nextBindBaseIndex < 1) {
        this._nextBindBaseIndex = 1;
      }
    }
  }
  freeLocationForBufferBase(glBuffer) {
    let freeIndex = this.getLastBindBaseLocation(glBuffer);
    if (freeIndex >= this._minBaseLocation) {
      glBuffer._lastBindCallId = this._bindCallId;
      return freeIndex;
    }
    let loop = 0;
    let nextIndex = this._nextBindBaseIndex;
    while (loop < 2) {
      if (nextIndex >= this._maxBindings) {
        nextIndex = this._minBaseLocation;
        loop++;
      }
      const curBuf = this._boundBufferBases[nextIndex];
      if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
        nextIndex++;
        continue;
      }
      break;
    }
    freeIndex = nextIndex;
    this._nextBindBaseIndex = nextIndex + 1;
    if (loop >= 2) {
      return -1;
    }
    glBuffer._lastBindCallId = this._bindCallId;
    this._boundBufferBases[freeIndex] = null;
    return freeIndex;
  }
  getLastBindBaseLocation(glBuffer) {
    const index = glBuffer._lastBindBaseLocation;
    if (this._boundBufferBases[index] === glBuffer) {
      return index;
    }
    return -1;
  }
  /**
   * Binds a buffer whilst also binding its range.
   * This will make the buffer start from the offset supplied rather than 0 when it is read.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind at, defaults to 0
   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
   * @param size - the size to bind at (this is blocks of 256).
   */
  bindBufferRange(glBuffer, index, offset, size) {
    const { _gl: gl } = this;
    offset || (offset = 0);
    index || (index = 0);
    this._boundBufferBases[index] = null;
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
  }
  /**
   * Will ensure the data in the buffer is uploaded to the GPU.
   * @param {Buffer} buffer - the buffer to update
   */
  updateBuffer(buffer) {
    const { _gl: gl } = this;
    const glBuffer = this.getGlBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return glBuffer;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(glBuffer.type, glBuffer.buffer);
    const data = buffer.data;
    const drawType = buffer.descriptor.usage & _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_0__.BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
    if (data) {
      if (glBuffer.byteLength >= data.byteLength) {
        gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
      } else {
        glBuffer.byteLength = data.byteLength;
        gl.bufferData(glBuffer.type, data, drawType);
      }
    } else {
      glBuffer.byteLength = buffer.descriptor.size;
      gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
    }
    return glBuffer;
  }
  /** dispose all WebGL resources of all managed buffers */
  destroyAll() {
    const gl = this._gl;
    for (const id in this._gpuBuffers) {
      gl.deleteBuffer(this._gpuBuffers[id].buffer);
    }
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Disposes buffer
   * @param {Buffer} buffer - buffer with data
   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  onBufferDestroy(buffer, contextLost) {
    const glBuffer = this._gpuBuffers[buffer.uid];
    const gl = this._gl;
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    this._gpuBuffers[buffer.uid] = null;
  }
  /**
   * creates and attaches a GLBuffer object tied to the current context.
   * @param buffer
   * @protected
   */
  createGLBuffer(buffer) {
    const { _gl: gl } = this;
    let type = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.BUFFER_TYPE.ARRAY_BUFFER;
    if (buffer.descriptor.usage & _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_0__.BufferUsage.INDEX) {
      type = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    } else if (buffer.descriptor.usage & _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_0__.BufferUsage.UNIFORM) {
      type = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.BUFFER_TYPE.UNIFORM_BUFFER;
    }
    const glBuffer = new _GlBuffer_mjs__WEBPACK_IMPORTED_MODULE_2__.GlBuffer(gl.createBuffer(), type);
    this._gpuBuffers[buffer.uid] = glBuffer;
    buffer.on("destroy", this.onBufferDestroy, this);
    return glBuffer;
  }
  resetState() {
    this._boundBufferBases = /* @__PURE__ */ Object.create(null);
  }
}
/** @ignore */
GlBufferSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGLSystem
  ],
  name: "buffer"
};


//# sourceMappingURL=GlBufferSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BUFFER_TYPE: () => (/* binding */ BUFFER_TYPE)
/* harmony export */ });

var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CLEAR: () => (/* binding */ CLEAR)
/* harmony export */ });

var CLEAR = /* @__PURE__ */ ((CLEAR2) => {
  CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
  CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
  CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
  CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
  CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
  CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
  CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
  CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
  return CLEAR2;
})(CLEAR || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlContextSystem: () => (/* binding */ GlContextSystem)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");




"use strict";
const _GlContextSystem = class _GlContextSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    /**
     * Features supported by current renderer.
     * @type {object}
     * @readonly
     */
    this.supports = {
      /** Support for 32-bit indices buffer. */
      uint32Indices: true,
      /** Support for UniformBufferObjects */
      uniformBufferObject: true,
      /** Support for VertexArrayObjects */
      vertexArrayObject: true,
      /** Support for SRGB texture format */
      srgbTextures: true,
      /** Support for wrapping modes if a texture is non-power of two */
      nonPowOf2wrapping: true,
      /** Support for MSAA (antialiasing of dynamic textures) */
      msaa: true,
      /** Support for mipmaps if a texture is non-power of two */
      nonPowOf2mipmaps: true
    };
    this._renderer = renderer;
    this.extensions = /* @__PURE__ */ Object.create(null);
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  /**
   * `true` if the context is lost
   * @readonly
   */
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  /**
   * Handles the context change event.
   * @param {WebGLRenderingContext} gl - New WebGL context.
   */
  contextChange(gl) {
    this.gl = gl;
    this._renderer.gl = gl;
  }
  init(options) {
    options = { ..._GlContextSystem.defaultOptions, ...options };
    let multiView = this.multiView = options.multiView;
    if (options.context && multiView) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
      multiView = false;
    }
    if (multiView) {
      this.canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
    } else {
      this.canvas = this._renderer.view.canvas;
    }
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this._renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha ?? true;
      const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
      this.createContext(options.preferWebGLVersion, {
        alpha,
        premultipliedAlpha,
        antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference ?? "default"
      });
    }
  }
  ensureCanvasSize(targetCanvas) {
    if (!this.multiView) {
      if (targetCanvas !== this.canvas) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)("multiView is disabled, but targetCanvas is not the main canvas");
      }
      return;
    }
    const { canvas } = this;
    if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
      canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
      canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
    }
  }
  /**
   * Initializes the context.
   * @protected
   * @param {WebGLRenderingContext} gl - WebGL context
   */
  initFromContext(gl) {
    this.gl = gl;
    this.webGLVersion = gl instanceof _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
    this.getExtensions();
    this.validateContext(gl);
    this._renderer.runners.contextChange.emit(gl);
    const element = this._renderer.view.canvas;
    element.addEventListener("webglcontextlost", this.handleContextLost, false);
    element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
  }
  /**
   * Initialize from context options
   * @protected
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
   * @param preferWebGLVersion
   * @param {object} options - context attributes
   */
  createContext(preferWebGLVersion, options) {
    let gl;
    const canvas = this.canvas;
    if (preferWebGLVersion === 2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (!gl) {
      gl = canvas.getContext("webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.initFromContext(this.gl);
  }
  /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
  getExtensions() {
    const { gl } = this;
    const common = {
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      // eslint-disable-line camelcase
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc"),
      bptc: gl.getExtension("EXT_texture_compression_bptc"),
      rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
      loseContext: gl.getExtension("WEBGL_lose_context")
    };
    if (this.webGLVersion === 1) {
      this.extensions = {
        ...common,
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
        vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
        srgb: gl.getExtension("EXT_sRGB")
      };
    } else {
      this.extensions = {
        ...common,
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      };
      const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
      if (provokeExt) {
        provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
      }
    }
  }
  /**
   * Handles a lost webgl context
   * @param {WebGLContextEvent} event - The context lost event.
   */
  handleContextLost(event) {
    event.preventDefault();
    if (this._contextLossForced) {
      this._contextLossForced = false;
      setTimeout(() => {
        if (this.gl.isContextLost()) {
          this.extensions.loseContext?.restoreContext();
        }
      }, 0);
    }
  }
  /** Handles a restored webgl context. */
  handleContextRestored() {
    this.getExtensions();
    this._renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const element = this._renderer.view.canvas;
    this._renderer = null;
    element.removeEventListener("webglcontextlost", this.handleContextLost);
    element.removeEventListener("webglcontextrestored", this.handleContextRestored);
    this.gl.useProgram(null);
    this.extensions.loseContext?.loseContext();
  }
  /**
   * this function can be called to force a webGL context loss
   * this will release all resources on the GPU.
   * Useful if you need to put Pixi to sleep, and save some GPU memory
   *
   * As soon as render is called - all resources will be created again.
   */
  forceContextLoss() {
    this.extensions.loseContext?.loseContext();
    this._contextLossForced = true;
  }
  /**
   * Validate context.
   * @param {WebGLRenderingContext} gl - Render context.
   */
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    if (attributes && !attributes.stencil) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const supports = this.supports;
    const isWebGl2 = this.webGLVersion === 2;
    const extensions = this.extensions;
    supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;
    supports.uniformBufferObject = isWebGl2;
    supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;
    supports.srgbTextures = isWebGl2 || !!extensions.srgb;
    supports.nonPowOf2wrapping = isWebGl2;
    supports.nonPowOf2mipmaps = isWebGl2;
    supports.msaa = isWebGl2;
    if (!supports.uint32Indices) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
    }
  }
};
/** @ignore */
_GlContextSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLSystem
  ],
  name: "context"
};
/** The default options for the system. */
_GlContextSystem.defaultOptions = {
  /**
   * {@link WebGLOptions.context}
   * @default null
   */
  context: null,
  /**
   * {@link WebGLOptions.premultipliedAlpha}
   * @default true
   */
  premultipliedAlpha: true,
  /**
   * {@link WebGLOptions.preserveDrawingBuffer}
   * @default false
   */
  preserveDrawingBuffer: false,
  /**
   * {@link WebGLOptions.powerPreference}
   * @default default
   */
  powerPreference: void 0,
  /**
   * {@link WebGLOptions.webGLVersion}
   * @default 2
   */
  preferWebGLVersion: 2,
  /**
   * {@link WebGLOptions.multiView}
   * @default false
   */
  multiView: false
};
let GlContextSystem = _GlContextSystem;


//# sourceMappingURL=GlContextSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlGeometrySystem: () => (/* binding */ GlGeometrySystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/geometry/utils/getAttributeInfoFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");
/* harmony import */ var _shader_program_ensureAttributes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader/program/ensureAttributes.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs");
/* harmony import */ var _utils_getGlTypeFromFormat_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/getGlTypeFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs");





"use strict";
const topologyToGlMap = {
  "point-list": 0,
  "line-list": 1,
  "line-strip": 3,
  "triangle-list": 4,
  "triangle-strip": 5
};
class GlGeometrySystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    const gl = this.gl = this._renderer.gl;
    if (!this._renderer.context.supports.vertexArrayObject) {
      throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
    }
    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
    if (nativeVaoExtension) {
      gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
      gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
    }
    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
    if (nativeInstancedExtension) {
      gl.drawArraysInstanced = (a, b, c, d) => {
        nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);
      };
      gl.drawElementsInstanced = (a, b, c, d, e) => {
        nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);
      };
      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);
    }
    this._activeGeometry = null;
    this._activeVao = null;
    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Binds geometry so that is can be drawn. Creating a Vao if required
   * @param geometry - Instance of geometry to bind.
   * @param program - Instance of program to use vao for.
   */
  bind(geometry, program) {
    const gl = this.gl;
    this._activeGeometry = geometry;
    const vao = this.getVao(geometry, program);
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      gl.bindVertexArray(vao);
    }
    this.updateBuffers();
  }
  /** Reset and unbind any active VAO and geometry. */
  resetState() {
    this.unbind();
  }
  /** Update buffers of the currently bound geometry. */
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this._renderer.buffer;
    for (let i = 0; i < geometry.buffers.length; i++) {
      const buffer = geometry.buffers[i];
      bufferSystem.updateBuffer(buffer);
    }
  }
  /**
   * Check compatibility between a geometry and a program
   * @param geometry - Geometry instance.
   * @param program - Program instance.
   */
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program._attributeData;
    for (const j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
      }
    }
  }
  /**
   * Takes a geometry and program and generates a unique signature for them.
   * @param geometry - To get signature from.
   * @param program - To test geometry against.
   * @returns - Unique signature of the geometry and program
   */
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program._attributeData;
    const strings = ["g", geometry.uid];
    for (const i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  }
  getVao(geometry, program) {
    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
  }
  /**
   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
   * attribute locations.
   * @param geometry - Instance of geometry to to generate Vao for.
   * @param program
   * @param _incRefCount - Increment refCount of all geometry buffers.
   */
  initGeometryVao(geometry, program, _incRefCount = true) {
    const gl = this._renderer.gl;
    const bufferSystem = this._renderer.buffer;
    this._renderer.shader._getProgramData(program);
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    if (!this._geometryVaoHash[geometry.uid]) {
      this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
      geometry.on("destroy", this.onGeometryDestroy, this);
    }
    const vaoObjectHash = this._geometryVaoHash[geometry.uid];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program._key] = vao;
      return vao;
    }
    (0,_shader_program_ensureAttributes_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureAttributes)(geometry, program._attributeData);
    const buffers = geometry.buffers;
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      bufferSystem.bind(buffer);
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program._key] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    return vao;
  }
  /**
   * Disposes geometry.
   * @param geometry - Geometry with buffers. Only VAO will be disposed
   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  onGeometryDestroy(geometry, contextLost) {
    const vaoObjectHash = this._geometryVaoHash[geometry.uid];
    const gl = this.gl;
    if (vaoObjectHash) {
      if (contextLost) {
        for (const i in vaoObjectHash) {
          if (this._activeVao !== vaoObjectHash[i]) {
            this.unbind();
          }
          gl.deleteVertexArray(vaoObjectHash[i]);
        }
      }
      this._geometryVaoHash[geometry.uid] = null;
    }
  }
  /**
   * Dispose all WebGL resources of all managed geometries.
   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  destroyAll(contextLost = false) {
    const gl = this.gl;
    for (const i in this._geometryVaoHash) {
      if (contextLost) {
        for (const j in this._geometryVaoHash[i]) {
          const vaoObjectHash = this._geometryVaoHash[i];
          if (this._activeVao !== vaoObjectHash) {
            this.unbind();
          }
          gl.deleteVertexArray(vaoObjectHash[j]);
        }
      }
      this._geometryVaoHash[i] = null;
    }
  }
  /**
   * Activate vertex array object.
   * @param geometry - Geometry instance.
   * @param program - Shader program instance.
   */
  activateVao(geometry, program) {
    const gl = this._renderer.gl;
    const bufferSystem = this._renderer.buffer;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j in attributes) {
      const attribute = attributes[j];
      const buffer = attribute.buffer;
      const glBuffer = bufferSystem.getGlBuffer(buffer);
      const programAttrib = program._attributeData[j];
      if (programAttrib) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location = programAttrib.location;
        gl.enableVertexAttribArray(location);
        const attributeInfo = (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.getAttributeInfoFromFormat)(attribute.format);
        const type = (0,_utils_getGlTypeFromFormat_mjs__WEBPACK_IMPORTED_MODULE_2__.getGlTypeFromFormat)(attribute.format);
        if (programAttrib.format?.substring(1, 4) === "int") {
          gl.vertexAttribIPointer(
            location,
            attributeInfo.size,
            type,
            attribute.stride,
            attribute.offset
          );
        } else {
          gl.vertexAttribPointer(
            location,
            attributeInfo.size,
            type,
            attributeInfo.normalised,
            attribute.stride,
            attribute.offset
          );
        }
        if (attribute.instance) {
          if (this.hasInstance) {
            const divisor = attribute.divisor ?? 1;
            gl.vertexAttribDivisor(location, divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  /**
   * Draws the currently bound geometry.
   * @param topology - The type primitive to render.
   * @param size - The number of elements to be rendered. If not specified, all vertices after the
   *  starting vertex will be drawn.
   * @param start - The starting vertex in the geometry to start drawing from. If not specified,
   *  drawing will start from the first vertex.
   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
   *  all instances will be drawn.
   */
  draw(topology, size, start, instanceCount) {
    const { gl } = this._renderer;
    const geometry = this._activeGeometry;
    const glTopology = topologyToGlMap[topology || geometry.topology];
    instanceCount ?? (instanceCount = geometry.instanceCount);
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (instanceCount > 1) {
        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
      } else {
        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
      }
    } else if (instanceCount > 1) {
      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
    } else {
      gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
    }
    return this;
  }
  /** Unbind/reset everything. */
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this._renderer = null;
    this.gl = null;
    this._activeVao = null;
    this._activeGeometry = null;
  }
}
/** @ignore */
GlGeometrySystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGLSystem
  ],
  name: "geometry"
};


//# sourceMappingURL=GlGeometrySystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlTypeFromFormat: () => (/* binding */ getGlTypeFromFormat)
/* harmony export */ });
/* harmony import */ var _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../texture/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs");


"use strict";
const infoMap = {
  uint8x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_BYTE,
  uint8x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_BYTE,
  sint8x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.BYTE,
  sint8x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.BYTE,
  unorm8x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_BYTE,
  unorm8x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_BYTE,
  snorm8x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.BYTE,
  snorm8x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.BYTE,
  uint16x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_SHORT,
  uint16x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_SHORT,
  sint16x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.SHORT,
  sint16x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.SHORT,
  unorm16x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_SHORT,
  unorm16x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_SHORT,
  snorm16x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.SHORT,
  snorm16x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.SHORT,
  float16x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.HALF_FLOAT,
  float16x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.HALF_FLOAT,
  float32: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.FLOAT,
  float32x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.FLOAT,
  float32x3: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.FLOAT,
  float32x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.FLOAT,
  uint32: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_INT,
  uint32x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_INT,
  uint32x3: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_INT,
  uint32x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_INT,
  sint32: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.INT,
  sint32x2: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.INT,
  sint32x3: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.INT,
  sint32x4: _texture_const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.INT
};
function getGlTypeFromFormat(format) {
  return infoMap[format] ?? infoMap.float32;
}


//# sourceMappingURL=getGlTypeFromFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlRenderTargetAdaptor: () => (/* binding */ GlRenderTargetAdaptor)
/* harmony export */ });
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/texture/sources/CanvasSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs");
/* harmony import */ var _GlRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GlRenderTarget.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs");






"use strict";
class GlRenderTargetAdaptor {
  constructor() {
    this._clearColorCache = [0, 0, 0, 0];
    this._viewPortCache = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
  }
  init(renderer, renderTargetSystem) {
    this._renderer = renderer;
    this._renderTargetSystem = renderTargetSystem;
    renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._clearColorCache = [0, 0, 0, 0];
    this._viewPortCache = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
  }
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    const renderTargetSystem = this._renderTargetSystem;
    const renderer = this._renderer;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
    const gl = renderer.gl;
    this.finishRenderPass(sourceRenderSurfaceTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
    renderer.texture.bind(destinationTexture, 0);
    gl.copyTexSubImage2D(
      gl.TEXTURE_2D,
      0,
      originDest.x,
      originDest.y,
      originSrc.x,
      originSrc.y,
      size.width,
      size.height
    );
    return destinationTexture;
  }
  startRenderPass(renderTarget, clear = true, clearColor, viewport) {
    const renderTargetSystem = this._renderTargetSystem;
    const source = renderTarget.colorTexture;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    let viewPortY = viewport.y;
    if (renderTarget.isRoot) {
      viewPortY = source.pixelHeight - viewport.height;
    }
    renderTarget.colorTextures.forEach((texture) => {
      this._renderer.texture.unbind(texture);
    });
    const gl = this._renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
    const viewPortCache = this._viewPortCache;
    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
      viewPortCache.x = viewport.x;
      viewPortCache.y = viewPortY;
      viewPortCache.width = viewport.width;
      viewPortCache.height = viewport.height;
      gl.viewport(
        viewport.x,
        viewPortY,
        viewport.width,
        viewport.height
      );
    }
    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
      this._initStencil(gpuRenderTarget);
    }
    this.clear(renderTarget, clear, clearColor);
  }
  finishRenderPass(renderTarget) {
    const renderTargetSystem = this._renderTargetSystem;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (!glRenderTarget.msaa)
      return;
    const gl = this._renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
    gl.blitFramebuffer(
      0,
      0,
      glRenderTarget.width,
      glRenderTarget.height,
      0,
      0,
      glRenderTarget.width,
      glRenderTarget.height,
      gl.COLOR_BUFFER_BIT,
      gl.NEAREST
    );
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
  }
  initGpuRenderTarget(renderTarget) {
    const renderer = this._renderer;
    const gl = renderer.gl;
    const glRenderTarget = new _GlRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_1__.GlRenderTarget();
    const colorTexture = renderTarget.colorTexture;
    if (_shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasSource.test(colorTexture.resource)) {
      this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
      glRenderTarget.framebuffer = null;
      return glRenderTarget;
    }
    this._initColor(renderTarget, glRenderTarget);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return glRenderTarget;
  }
  destroyGpuRenderTarget(gpuRenderTarget) {
    const gl = this._renderer.gl;
    if (gpuRenderTarget.framebuffer) {
      gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
      gpuRenderTarget.framebuffer = null;
    }
    if (gpuRenderTarget.resolveTargetFramebuffer) {
      gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
      gpuRenderTarget.resolveTargetFramebuffer = null;
    }
    if (gpuRenderTarget.depthStencilRenderBuffer) {
      gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
      gpuRenderTarget.depthStencilRenderBuffer = null;
    }
    gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
      gl.deleteRenderbuffer(renderBuffer);
    });
    gpuRenderTarget.msaaRenderBuffer = null;
  }
  clear(_renderTarget, clear, clearColor) {
    if (!clear)
      return;
    const renderTargetSystem = this._renderTargetSystem;
    if (typeof clear === "boolean") {
      clear = clear ? _const_mjs__WEBPACK_IMPORTED_MODULE_3__.CLEAR.ALL : _const_mjs__WEBPACK_IMPORTED_MODULE_3__.CLEAR.NONE;
    }
    const gl = this._renderer.gl;
    if (clear & _const_mjs__WEBPACK_IMPORTED_MODULE_3__.CLEAR.COLOR) {
      clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
      const clearColorCache = this._clearColorCache;
      const clearColorArray = clearColor;
      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
        clearColorCache[0] = clearColorArray[0];
        clearColorCache[1] = clearColorArray[1];
        clearColorCache[2] = clearColorArray[2];
        clearColorCache[3] = clearColorArray[3];
        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
      }
    }
    gl.clear(clear);
  }
  resizeGpuRenderTarget(renderTarget) {
    if (renderTarget.isRoot)
      return;
    const renderTargetSystem = this._renderTargetSystem;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    this._resizeColor(renderTarget, glRenderTarget);
    if (renderTarget.stencil || renderTarget.depth) {
      this._resizeStencil(glRenderTarget);
    }
  }
  _initColor(renderTarget, glRenderTarget) {
    const renderer = this._renderer;
    const gl = renderer.gl;
    const resolveTargetFramebuffer = gl.createFramebuffer();
    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
    renderTarget.colorTextures.forEach((colorTexture, i) => {
      const source = colorTexture.source;
      if (source.antialias) {
        if (renderer.context.supports.msaa) {
          glRenderTarget.msaa = true;
        } else {
          (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__.warn)("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
        }
      }
      renderer.texture.bindSource(source, 0);
      const glSource = renderer.texture.getGlSource(source);
      const glTexture = glSource.texture;
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0 + i,
        3553,
        // texture.target,
        glTexture,
        0
      );
    });
    if (glRenderTarget.msaa) {
      const viewFramebuffer = gl.createFramebuffer();
      glRenderTarget.framebuffer = viewFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
      renderTarget.colorTextures.forEach((_, i) => {
        const msaaRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;
      });
    } else {
      glRenderTarget.framebuffer = resolveTargetFramebuffer;
    }
    this._resizeColor(renderTarget, glRenderTarget);
  }
  _resizeColor(renderTarget, glRenderTarget) {
    const source = renderTarget.colorTexture.source;
    glRenderTarget.width = source.pixelWidth;
    glRenderTarget.height = source.pixelHeight;
    renderTarget.colorTextures.forEach((colorTexture, i) => {
      if (i === 0)
        return;
      colorTexture.source.resize(source.width, source.height, source._resolution);
    });
    if (glRenderTarget.msaa) {
      const renderer = this._renderer;
      const gl = renderer.gl;
      const viewFramebuffer = glRenderTarget.framebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        const source2 = colorTexture.source;
        renderer.texture.bindSource(source2, 0);
        const glSource = renderer.texture.getGlSource(source2);
        const glInternalFormat = glSource.internalFormat;
        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          msaaRenderBuffer
        );
        gl.renderbufferStorageMultisample(
          gl.RENDERBUFFER,
          4,
          glInternalFormat,
          source2.pixelWidth,
          source2.pixelHeight
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0 + i,
          gl.RENDERBUFFER,
          msaaRenderBuffer
        );
      });
    }
  }
  _initStencil(glRenderTarget) {
    if (glRenderTarget.framebuffer === null)
      return;
    const gl = this._renderer.gl;
    const depthStencilRenderBuffer = gl.createRenderbuffer();
    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
    gl.bindRenderbuffer(
      gl.RENDERBUFFER,
      depthStencilRenderBuffer
    );
    gl.framebufferRenderbuffer(
      gl.FRAMEBUFFER,
      gl.DEPTH_STENCIL_ATTACHMENT,
      gl.RENDERBUFFER,
      depthStencilRenderBuffer
    );
    this._resizeStencil(glRenderTarget);
  }
  _resizeStencil(glRenderTarget) {
    const gl = this._renderer.gl;
    gl.bindRenderbuffer(
      gl.RENDERBUFFER,
      glRenderTarget.depthStencilRenderBuffer
    );
    if (glRenderTarget.msaa) {
      gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        4,
        gl.DEPTH24_STENCIL8,
        glRenderTarget.width,
        glRenderTarget.height
      );
    } else {
      gl.renderbufferStorage(
        gl.RENDERBUFFER,
        this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
        glRenderTarget.width,
        glRenderTarget.height
      );
    }
  }
  prerender(renderTarget) {
    const resource = renderTarget.colorTexture.resource;
    if (this._renderer.context.multiView && _shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasSource.test(resource)) {
      this._renderer.context.ensureCanvasSize(resource);
    }
  }
  postrender(renderTarget) {
    if (!this._renderer.context.multiView)
      return;
    if (_shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasSource.test(renderTarget.colorTexture.resource)) {
      const contextCanvas = this._renderer.context.canvas;
      const canvasSource = renderTarget.colorTexture;
      canvasSource.context2D.drawImage(
        contextCanvas,
        0,
        canvasSource.pixelHeight - contextCanvas.height
      );
    }
  }
}


//# sourceMappingURL=GlRenderTargetAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlRenderTargetSystem: () => (/* binding */ GlRenderTargetSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_renderTarget_RenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/renderTarget/RenderTargetSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs");
/* harmony import */ var _GlRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlRenderTargetAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs");




"use strict";
class GlRenderTargetSystem extends _shared_renderTarget_RenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.RenderTargetSystem {
  constructor(renderer) {
    super(renderer);
    this.adaptor = new _GlRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__.GlRenderTargetAdaptor();
    this.adaptor.init(renderer, this);
  }
}
/** @ignore */
GlRenderTargetSystem.extension = {
  type: [_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLSystem],
  name: "renderTarget"
};


//# sourceMappingURL=GlRenderTargetSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateShaderSyncCode: () => (/* binding */ generateShaderSyncCode)
/* harmony export */ });
/* harmony import */ var _shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/buffer/BufferResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs");
/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");




"use strict";
function generateShaderSyncCode(shader, shaderSystem) {
  const funcFragments = [];
  const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
  let addedTextreSystem = false;
  let textureCount = 0;
  const programData = shaderSystem._getProgramData(shader.glProgram);
  for (const i in shader.groups) {
    const group = shader.groups[i];
    funcFragments.push(`
            resources = g[${i}].resources;
        `);
    for (const j in group.resources) {
      const resource = group.resources[j];
      if (resource instanceof _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.UniformGroup) {
        if (resource.ubo) {
          const resName = shader._uniformBindMap[i][Number(j)];
          funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j}],
                            '${resName}',
                            ${shader.glProgram._uniformBlockData[resName].index}
                        );
                    `);
        } else {
          funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j}], p, sD);
                    `);
        }
      } else if (resource instanceof _shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferResource) {
        const resName = shader._uniformBindMap[i][Number(j)];
        funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j}],
                        '${resName}',
                        ${shader.glProgram._uniformBlockData[resName].index}
                    );
                `);
      } else if (resource instanceof _shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_2__.TextureSource) {
        const uniformName = shader._uniformBindMap[i][j];
        const uniformData = programData.uniformData[uniformName];
        if (uniformData) {
          if (!addedTextreSystem) {
            addedTextreSystem = true;
            headerFragments.push(`
                        var tS = r.texture;
                        `);
          }
          shaderSystem._gl.uniform1i(uniformData.location, textureCount);
          funcFragments.push(`
                        tS.bind(resources[${j}], ${textureCount});
                    `);
          textureCount++;
        }
      }
    }
  }
  const functionSource = [...headerFragments, ...funcFragments].join("\n");
  return new Function("r", "s", "sD", functionSource);
}


//# sourceMappingURL=GenerateShaderSyncCode.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlProgram: () => (/* binding */ GlProgram)
/* harmony export */ });
/* harmony import */ var _shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/utils/createIdFromString.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs");
/* harmony import */ var _program_getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./program/getMaxFragmentPrecision.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs");
/* harmony import */ var _program_preprocessors_addProgramDefines_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./program/preprocessors/addProgramDefines.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs");
/* harmony import */ var _program_preprocessors_ensurePrecision_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./program/preprocessors/ensurePrecision.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs");
/* harmony import */ var _program_preprocessors_insertVersion_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./program/preprocessors/insertVersion.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs");
/* harmony import */ var _program_preprocessors_setProgramName_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./program/preprocessors/setProgramName.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs");
/* harmony import */ var _program_preprocessors_stripVersion_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./program/preprocessors/stripVersion.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs");








"use strict";
const processes = {
  // strips any version headers..
  stripVersion: _program_preprocessors_stripVersion_mjs__WEBPACK_IMPORTED_MODULE_0__.stripVersion,
  // adds precision string if not already present
  ensurePrecision: _program_preprocessors_ensurePrecision_mjs__WEBPACK_IMPORTED_MODULE_1__.ensurePrecision,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines: _program_preprocessors_addProgramDefines_mjs__WEBPACK_IMPORTED_MODULE_2__.addProgramDefines,
  // add the program name to the shader
  setProgramName: _program_preprocessors_setProgramName_mjs__WEBPACK_IMPORTED_MODULE_3__.setProgramName,
  // add the version string to the shader header
  insertVersion: _program_preprocessors_insertVersion_mjs__WEBPACK_IMPORTED_MODULE_4__.insertVersion
};
const programCache = /* @__PURE__ */ Object.create(null);
const _GlProgram = class _GlProgram {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(options) {
    options = { ..._GlProgram.defaultOptions, ...options };
    const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
    const preprocessorOptions = {
      stripVersion: isES300,
      ensurePrecision: {
        requestedFragmentPrecision: options.preferredFragmentPrecision,
        requestedVertexPrecision: options.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: (0,_program_getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_5__.getMaxFragmentPrecision)()
      },
      setProgramName: {
        name: options.name
      },
      addProgramDefines: isES300,
      insertVersion: isES300
    };
    let fragment = options.fragment;
    let vertex = options.vertex;
    Object.keys(processes).forEach((processKey) => {
      const processOptions = preprocessorOptions[processKey];
      fragment = processes[processKey](fragment, processOptions, true);
      vertex = processes[processKey](vertex, processOptions, false);
    });
    this.fragment = fragment;
    this.vertex = vertex;
    this.transformFeedbackVaryings = options.transformFeedbackVaryings;
    this._key = (0,_shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_6__.createIdFromString)(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null;
    this.vertex = null;
    this._attributeData = null;
    this._uniformData = null;
    this._uniformBlockData = null;
    this.transformFeedbackVaryings = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(options) {
    const key = `${options.vertex}:${options.fragment}`;
    if (!programCache[key]) {
      programCache[key] = new _GlProgram(options);
    }
    return programCache[key];
  }
};
/** The default options used by the program. */
_GlProgram.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let GlProgram = _GlProgram;


//# sourceMappingURL=GlProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlProgramData: () => (/* binding */ GlProgramData),
/* harmony export */   IGLUniformData: () => (/* binding */ IGLUniformData)
/* harmony export */ });

class IGLUniformData {
}
class GlProgramData {
  /**
   * Makes a new Pixi program.
   * @param program - webgl program
   * @param uniformData - uniforms
   */
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBlockBindings = {};
  }
  /** Destroys this program. */
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBlockBindings = null;
    this.program = null;
  }
}


//# sourceMappingURL=GlProgramData.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlShaderSystem: () => (/* binding */ GlShaderSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../batcher/gl/utils/maxRecommendedTextures.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs");
/* harmony import */ var _GenerateShaderSyncCode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GenerateShaderSyncCode.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs");
/* harmony import */ var _program_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./program/generateProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs");





"use strict";
const defaultSyncData = {
  textureCount: 0,
  blockIndex: 0
};
class GlShaderSystem {
  constructor(renderer) {
    /**
     * @internal
     * @private
     */
    this._activeProgram = null;
    this._programDataHash = /* @__PURE__ */ Object.create(null);
    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
  }
  contextChange(gl) {
    this._gl = gl;
    this._programDataHash = /* @__PURE__ */ Object.create(null);
    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
    this._activeProgram = null;
    this.maxTextures = (0,_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_0__.getMaxTexturesPerBatch)();
  }
  /**
   * Changes the current shader to the one given in parameter.
   * @param shader - the new shader
   * @param skipSync - false if the shader should automatically sync its uniforms.
   * @returns the glProgram that belongs to the shader.
   */
  bind(shader, skipSync) {
    this._setProgram(shader.glProgram);
    if (skipSync)
      return;
    defaultSyncData.textureCount = 0;
    defaultSyncData.blockIndex = 0;
    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
    if (!syncFunction) {
      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
    }
    this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);
    syncFunction(this._renderer, shader, defaultSyncData);
  }
  /**
   * Updates the uniform group.
   * @param uniformGroup - the uniform group to update
   */
  updateUniformGroup(uniformGroup) {
    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
  }
  /**
   * Binds a uniform block to the shader.
   * @param uniformGroup - the uniform group to bind
   * @param name - the name of the uniform block
   * @param index - the index of the uniform block
   */
  bindUniformBlock(uniformGroup, name, index = 0) {
    const bufferSystem = this._renderer.buffer;
    const programData = this._getProgramData(this._activeProgram);
    const isBufferResource = uniformGroup._bufferResource;
    if (!isBufferResource) {
      this._renderer.ubo.updateUniformGroup(uniformGroup);
    }
    const buffer = uniformGroup.buffer;
    const glBuffer = bufferSystem.updateBuffer(buffer);
    const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
    if (isBufferResource) {
      const { offset, size } = uniformGroup;
      if (offset === 0 && size === buffer.data.byteLength) {
        bufferSystem.bindBufferBase(glBuffer, boundLocation);
      } else {
        bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
      }
    } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
      bufferSystem.bindBufferBase(glBuffer, boundLocation);
    }
    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
    if (programData.uniformBlockBindings[index] === boundLocation)
      return;
    programData.uniformBlockBindings[index] = boundLocation;
    this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
  }
  _setProgram(program) {
    if (this._activeProgram === program)
      return;
    this._activeProgram = program;
    const programData = this._getProgramData(program);
    this._gl.useProgram(programData.program);
  }
  /**
   * @param program - the program to get the data for
   * @internal
   * @private
   */
  _getProgramData(program) {
    return this._programDataHash[program._key] || this._createProgramData(program);
  }
  _createProgramData(program) {
    const key = program._key;
    this._programDataHash[key] = (0,_program_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.generateProgram)(this._gl, program);
    return this._programDataHash[key];
  }
  destroy() {
    for (const key of Object.keys(this._programDataHash)) {
      const programData = this._programDataHash[key];
      programData.destroy();
      this._programDataHash[key] = null;
    }
    this._programDataHash = null;
  }
  /**
   * Creates a function that can be executed that will sync the shader as efficiently as possible.
   * Overridden by the unsafe eval package if you don't want eval used in your project.
   * @param shader - the shader to generate the sync function for
   * @param shaderSystem - the shader system to use
   * @returns - the generated sync function
   * @ignore
   */
  _generateShaderSync(shader, shaderSystem) {
    return (0,_GenerateShaderSyncCode_mjs__WEBPACK_IMPORTED_MODULE_2__.generateShaderSyncCode)(shader, shaderSystem);
  }
  resetState() {
    this._activeProgram = null;
  }
}
/** @ignore */
GlShaderSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGLSystem
  ],
  name: "shader"
};


//# sourceMappingURL=GlShaderSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlUniformGroupSystem: () => (/* binding */ GlUniformGroupSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/generateUniformsSync.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs");



"use strict";
class GlUniformGroupSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */
    this._cache = {};
    this._uniformGroupSyncHash = {};
    this._renderer = renderer;
    this.gl = null;
    this._cache = {};
  }
  contextChange(gl) {
    this.gl = gl;
  }
  /**
   * Uploads the uniforms values to the currently bound shader.
   * @param group - the uniforms values that be applied to the current shader
   * @param program
   * @param syncData
   * @param syncData.textureCount
   */
  updateUniformGroup(group, program, syncData) {
    const programData = this._renderer.shader._getProgramData(program);
    if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
      programData.uniformDirtyGroups[group.uid] = group._dirtyId;
      const syncFunc = this._getUniformSyncFunction(group, program);
      syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
    }
  }
  /**
   * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
   * @param group
   * @param program
   */
  _getUniformSyncFunction(group, program) {
    return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
  }
  _createUniformSyncFunction(group, program) {
    const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
    const id = this._getSignature(group, program._uniformData, "u");
    if (!this._cache[id]) {
      this._cache[id] = this._generateUniformsSync(group, program._uniformData);
    }
    uniformGroupSyncHash[program._key] = this._cache[id];
    return uniformGroupSyncHash[program._key];
  }
  _generateUniformsSync(group, uniformData) {
    return (0,_utils_generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_0__.generateUniformsSync)(group, uniformData);
  }
  /**
   * Takes a uniform group and data and generates a unique signature for them.
   * @param group - The uniform group to get signature of
   * @param group.uniforms
   * @param uniformData - Uniform information generated by the shader
   * @param preFix
   * @returns Unique signature of the uniform group
   */
  _getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  }
  /** Destroys this System and removes all its textures. */
  destroy() {
    this._renderer = null;
    this._cache = null;
  }
}
/** @ignore */
GlUniformGroupSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGLSystem
  ],
  name: "uniformGroup"
};


//# sourceMappingURL=GlUniformGroupSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBatchSamplersUniformGroup: () => (/* binding */ getBatchSamplersUniformGroup)
/* harmony export */ });
/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");


"use strict";
const batchSamplersUniformGroupHash = {};
function getBatchSamplersUniformGroup(maxTextures) {
  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
  if (batchSamplersUniformGroup)
    return batchSamplersUniformGroup;
  const sampleValues = new Int32Array(maxTextures);
  for (let i = 0; i < maxTextures; i++) {
    sampleValues[i] = i;
  }
  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.UniformGroup({
    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }
  }, { isStatic: true });
  return batchSamplersUniformGroup;
}


//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   migrateFragmentFromV7toV8: () => (/* binding */ migrateFragmentFromV7toV8)
/* harmony export */ });

function migrateFragmentFromV7toV8(fragmentShader) {
  fragmentShader = fragmentShader.replaceAll("texture2D", "texture").replaceAll("gl_FragColor", "finalColor").replaceAll("varying", "in");
  fragmentShader = `
        out vec4 finalColor;
    ${fragmentShader}
    `;
  return fragmentShader;
}


//# sourceMappingURL=migrateFragmentFromV7toV8.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compileShader: () => (/* binding */ compileShader)
/* harmony export */ });

function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}


//# sourceMappingURL=compileShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultValue: () => (/* binding */ defaultValue)
/* harmony export */ });

function booleanArray(size) {
  const array = new Array(size);
  for (let i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}


//# sourceMappingURL=defaultValue.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ensureAttributes: () => (/* binding */ ensureAttributes)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");



"use strict";
function ensureAttributes(geometry, extractedData) {
  for (const i in geometry.attributes) {
    const attribute = geometry.attributes[i];
    const attributeData = extractedData[i];
    if (attributeData) {
      attribute.format ?? (attribute.format = attributeData.format);
      attribute.offset ?? (attribute.offset = attributeData.offset);
      attribute.instance ?? (attribute.instance = attributeData.instance);
    } else {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_0__.warn)(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
  }
  ensureStartAndStride(geometry);
}
function ensureStartAndStride(geometry) {
  const { buffers, attributes } = geometry;
  const tempStride = {};
  const tempStart = {};
  for (const j in buffers) {
    const buffer = buffers[j];
    tempStride[buffer.uid] = 0;
    tempStart[buffer.uid] = 0;
  }
  for (const j in attributes) {
    const attribute = attributes[j];
    tempStride[attribute.buffer.uid] += (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.getAttributeInfoFromFormat)(attribute.format).stride;
  }
  for (const j in attributes) {
    const attribute = attributes[j];
    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
    tempStart[attribute.buffer.uid] += (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.getAttributeInfoFromFormat)(attribute.format).stride;
  }
}


//# sourceMappingURL=ensureAttributes.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractAttributesFromGlProgram: () => (/* binding */ extractAttributesFromGlProgram)
/* harmony export */ });
/* harmony import */ var _shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");
/* harmony import */ var _mapType_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mapType.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs");



"use strict";
function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const format = (0,_mapType_mjs__WEBPACK_IMPORTED_MODULE_0__.mapGlToVertexFormat)(gl, attribData.type);
    attributes[attribData.name] = {
      location: 0,
      // set further down..
      format,
      stride: (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.getAttributeInfoFromFormat)(format).stride,
      offset: 0,
      instance: false,
      start: 0
    };
  }
  const keys = Object.keys(attributes);
  if (sortAttributes) {
    keys.sort((a, b) => a > b ? 1 : -1);
    for (let i = 0; i < keys.length; i++) {
      attributes[keys[i]].location = i;
      gl.bindAttribLocation(program, i, keys[i]);
    }
    gl.linkProgram(program);
  } else {
    for (let i = 0; i < keys.length; i++) {
      attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);
    }
  }
  return attributes;
}


//# sourceMappingURL=extractAttributesFromGlProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateProgram: () => (/* binding */ generateProgram)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _GlProgramData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../GlProgramData.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs");
/* harmony import */ var _compileShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compileShader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs");
/* harmony import */ var _defaultValue_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./defaultValue.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs");
/* harmony import */ var _extractAttributesFromGlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractAttributesFromGlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs");
/* harmony import */ var _getUboData_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getUboData.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs");
/* harmony import */ var _getUniformData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getUniformData.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs");
/* harmony import */ var _logProgramError_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logProgramError.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs");









"use strict";
function generateProgram(gl, program) {
  const glVertShader = (0,_compileShader_mjs__WEBPACK_IMPORTED_MODULE_0__.compileShader)(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = (0,_compileShader_mjs__WEBPACK_IMPORTED_MODULE_0__.compileShader)(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__.warn)(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    (0,_logProgramError_mjs__WEBPACK_IMPORTED_MODULE_2__.logProgramError)(gl, webGLProgram, glVertShader, glFragShader);
  }
  program._attributeData = (0,_extractAttributesFromGlProgram_mjs__WEBPACK_IMPORTED_MODULE_3__.extractAttributesFromGlProgram)(
    webGLProgram,
    gl,
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
  );
  program._uniformData = (0,_getUniformData_mjs__WEBPACK_IMPORTED_MODULE_4__.getUniformData)(webGLProgram, gl);
  program._uniformBlockData = (0,_getUboData_mjs__WEBPACK_IMPORTED_MODULE_5__.getUboData)(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program._uniformData) {
    const data = program._uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: (0,_defaultValue_mjs__WEBPACK_IMPORTED_MODULE_6__.defaultValue)(data.type, data.size)
    };
  }
  const glProgram = new _GlProgramData_mjs__WEBPACK_IMPORTED_MODULE_7__.GlProgramData(webGLProgram, uniformData);
  return glProgram;
}


//# sourceMappingURL=generateProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMaxFragmentPrecision: () => (/* binding */ getMaxFragmentPrecision)
/* harmony export */ });
/* harmony import */ var _getTestContext_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getTestContext.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs");


"use strict";
let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = (0,_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_0__.getTestContext)();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}


//# sourceMappingURL=getMaxFragmentPrecision.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTestContext: () => (/* binding */ getTestContext)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
let context;
function getTestContext() {
  if (!context || context?.isContextLost()) {
    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().createCanvas();
    context = canvas.getContext("webgl", {});
  }
  return context;
}


//# sourceMappingURL=getTestContext.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getUboData: () => (/* binding */ getUboData)
/* harmony export */ });

function getUboData(program, gl) {
  if (!gl.ACTIVE_UNIFORM_BLOCKS)
    return {};
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i = 0; i < totalUniformsBlocks; i++) {
    const name = gl.getActiveUniformBlockName(program, i);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size
    };
  }
  return uniformBlocks;
}


//# sourceMappingURL=getUboData.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getUniformData: () => (/* binding */ getUniformData)
/* harmony export */ });
/* harmony import */ var _defaultValue_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultValue.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs");
/* harmony import */ var _mapType_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mapType.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs");



"use strict";
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = (0,_mapType_mjs__WEBPACK_IMPORTED_MODULE_0__.mapType)(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: (0,_defaultValue_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultValue)(type, uniformData.size)
    };
  }
  return uniforms;
}


//# sourceMappingURL=getUniformData.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logProgramError: () => (/* binding */ logProgramError)
/* harmony export */ });

function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}


//# sourceMappingURL=logProgramError.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapSize: () => (/* binding */ mapSize)
/* harmony export */ });

const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}


//# sourceMappingURL=mapSize.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapGlToVertexFormat: () => (/* binding */ mapGlToVertexFormat),
/* harmony export */   mapType: () => (/* binding */ mapType)
/* harmony export */ });

let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
const GLSL_TO_VERTEX_TYPES = {
  float: "float32",
  vec2: "float32x2",
  vec3: "float32x3",
  vec4: "float32x4",
  int: "sint32",
  ivec2: "sint32x2",
  ivec3: "sint32x3",
  ivec4: "sint32x4",
  uint: "uint32",
  uvec2: "uint32x2",
  uvec3: "uint32x3",
  uvec4: "uint32x4",
  bool: "uint32",
  bvec2: "uint32x2",
  bvec3: "uint32x3",
  bvec4: "uint32x4"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
function mapGlToVertexFormat(gl, type) {
  const typeValue = mapType(gl, type);
  return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
}


//# sourceMappingURL=mapType.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addProgramDefines: () => (/* binding */ addProgramDefines)
/* harmony export */ });

function addProgramDefines(src, isES300, isFragment) {
  if (isES300)
    return src;
  if (isFragment) {
    src = src.replace("out vec4 finalColor;", "");
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
  }
  return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
}


//# sourceMappingURL=addProgramDefines.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ensurePrecision: () => (/* binding */ ensurePrecision)
/* harmony export */ });

function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}


//# sourceMappingURL=ensurePrecision.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   insertVersion: () => (/* binding */ insertVersion)
/* harmony export */ });

function insertVersion(src, isES300) {
  if (!isES300)
    return src;
  return `#version 300 es
${src}`;
}


//# sourceMappingURL=insertVersion.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setProgramName: () => (/* binding */ setProgramName)
/* harmony export */ });

const fragmentNameCache = {};
const VertexNameCache = {};
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  return `${shaderName}
${src}`;
}


//# sourceMappingURL=setProgramName.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stripVersion: () => (/* binding */ stripVersion)
/* harmony export */ });

function stripVersion(src, isES300) {
  if (!isES300)
    return src;
  return src.replace("#version 300 es", "");
}


//# sourceMappingURL=stripVersion.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WGSL_TO_STD40_SIZE: () => (/* binding */ WGSL_TO_STD40_SIZE),
/* harmony export */   createUboElementsSTD40: () => (/* binding */ createUboElementsSTD40)
/* harmony export */ });

const WGSL_TO_STD40_SIZE = {
  f32: 4,
  i32: 4,
  "vec2<f32>": 8,
  "vec3<f32>": 12,
  "vec4<f32>": 16,
  "vec2<i32>": 8,
  "vec3<i32>": 12,
  "vec4<i32>": 16,
  "mat2x2<f32>": 16 * 2,
  "mat3x3<f32>": 16 * 3,
  "mat4x4<f32>": 16 * 4
  // TODO - not essential for now but support these in the future
  // int:      4,
  // ivec2:    8,
  // ivec3:    12,
  // ivec4:    16,
  // uint:     4,
  // uvec2:    8,
  // uvec3:    12,
  // uvec4:    16,
  // bool:     4,
  // bvec2:    8,
  // bvec3:    12,
  // bvec4:    16,
  // mat2:     16 * 2,
  // mat3:     16 * 3,
  // mat4:     16 * 4,
};
function createUboElementsSTD40(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  const chunkSize = 16;
  let size = 0;
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    size = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, chunkSize) * uboElement.data.size;
    }
    const boundary = size === 12 ? 16 : size;
    uboElement.size = size;
    const curOffset = offset % chunkSize;
    if (curOffset > 0 && chunkSize - curOffset < boundary) {
      offset += (chunkSize - curOffset) % 16;
    } else {
      offset += (size - curOffset % size) % size;
    }
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}


//# sourceMappingURL=createUboElementsSTD40.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUboSyncFunctionSTD40: () => (/* binding */ createUboSyncFunctionSTD40)
/* harmony export */ });
/* harmony import */ var _shared_shader_utils_createUboSyncFunction_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/shader/utils/createUboSyncFunction.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs");
/* harmony import */ var _shared_shader_utils_uboSyncFunctions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/shader/utils/uboSyncFunctions.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs");
/* harmony import */ var _generateArraySyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateArraySyncSTD40.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs");




"use strict";
function createUboSyncFunctionSTD40(uboElements) {
  return (0,_shared_shader_utils_createUboSyncFunction_mjs__WEBPACK_IMPORTED_MODULE_0__.createUboSyncFunction)(
    uboElements,
    "uboStd40",
    _generateArraySyncSTD40_mjs__WEBPACK_IMPORTED_MODULE_1__.generateArraySyncSTD40,
    _shared_shader_utils_uboSyncFunctions_mjs__WEBPACK_IMPORTED_MODULE_2__.uboSyncFunctionsSTD40
  );
}


//# sourceMappingURL=createUboSyncSTD40.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateArraySyncSTD40: () => (/* binding */ generateArraySyncSTD40)
/* harmony export */ });
/* harmony import */ var _createUboElementsSTD40_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createUboElementsSTD40.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs");


"use strict";
function generateArraySyncSTD40(uboElement, offsetToAdd) {
  const rowSize = Math.max(_createUboElementsSTD40_mjs__WEBPACK_IMPORTED_MODULE_0__.WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
  const elementSize = uboElement.data.value.length / uboElement.data.size;
  const remainder = (4 - elementSize % 4) % 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
}


//# sourceMappingURL=generateArraySyncSTD40.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateUniformsSync: () => (/* binding */ generateUniformsSync)
/* harmony export */ });
/* harmony import */ var _shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/buffer/BufferResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs");
/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _shared_shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/shader/utils/uniformParsers.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs");
/* harmony import */ var _generateUniformsSyncTypes_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generateUniformsSyncTypes.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs");





"use strict";
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
  for (const i in group.uniforms) {
    if (!uniformData[i]) {
      if (group.uniforms[i] instanceof _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.UniformGroup) {
        if (group.uniforms[i].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i});
                    `);
        }
      } else if (group.uniforms[i] instanceof _shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i}, "${i}");
                    `);
      }
      continue;
    }
    const uniform = group.uniformStructures[i];
    let parsed = false;
    for (let j = 0; j < _shared_shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_2__.uniformParsers.length; j++) {
      const parser = _shared_shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_2__.uniformParsers[j];
      if (uniform.type === parser.type && parser.test(uniform)) {
        funcFragments.push(`name = "${i}";`, _shared_shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_2__.uniformParsers[j].uniform);
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = uniform.size === 1 ? _generateUniformsSyncTypes_mjs__WEBPACK_IMPORTED_MODULE_3__.UNIFORM_TO_SINGLE_SETTERS : _generateUniformsSyncTypes_mjs__WEBPACK_IMPORTED_MODULE_3__.UNIFORM_TO_ARRAY_SETTERS;
      const template = templateType[uniform.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}


//# sourceMappingURL=generateUniformsSync.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UNIFORM_TO_ARRAY_SETTERS: () => (/* binding */ UNIFORM_TO_ARRAY_SETTERS),
/* harmony export */   UNIFORM_TO_SINGLE_SETTERS: () => (/* binding */ UNIFORM_TO_SINGLE_SETTERS)
/* harmony export */ });

const UNIFORM_TO_SINGLE_SETTERS = {
  f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
  "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
  "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
  "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
  i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
  "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
  "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
  "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
  u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
  "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
  "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
  "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
  bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
  "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
  "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
  "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
  "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
  "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
  "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
};
const UNIFORM_TO_ARRAY_SETTERS = {
  f32: `gl.uniform1fv(location, v);`,
  "vec2<f32>": `gl.uniform2fv(location, v);`,
  "vec3<f32>": `gl.uniform3fv(location, v);`,
  "vec4<f32>": `gl.uniform4fv(location, v);`,
  "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
  "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
  "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
  i32: `gl.uniform1iv(location, v);`,
  "vec2<i32>": `gl.uniform2iv(location, v);`,
  "vec3<i32>": `gl.uniform3iv(location, v);`,
  "vec4<i32>": `gl.uniform4iv(location, v);`,
  u32: `gl.uniform1iv(location, v);`,
  "vec2<u32>": `gl.uniform2iv(location, v);`,
  "vec3<u32>": `gl.uniform3iv(location, v);`,
  "vec4<u32>": `gl.uniform4iv(location, v);`,
  bool: `gl.uniform1iv(location, v);`,
  "vec2<bool>": `gl.uniform2iv(location, v);`,
  "vec3<bool>": `gl.uniform3iv(location, v);`,
  "vec4<bool>": `gl.uniform4iv(location, v);`
};


//# sourceMappingURL=generateUniformsSyncTypes.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlStateSystem: () => (/* binding */ GlStateSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _mapWebGLBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapWebGLBlendModesToPixi.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs");




"use strict";
const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _GlStateSystem = class _GlStateSystem {
  constructor(renderer) {
    /**
     * Whether to invert the front face when rendering
     * This is used for render textures where the Y-coordinate is flipped
     * @default false
     */
    this._invertFrontFace = false;
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = "none";
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = _shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(renderTarget) {
    this._invertFrontFace = !renderTarget.isRoot;
    if (this._cullFace) {
      this.setFrontFace(this._frontFace);
    } else {
      this._frontFaceDirty = true;
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModesMap = (0,_mapWebGLBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__.mapWebGLBlendModesToPixi)(gl);
    this.resetState();
  }
  /**
   * Sets the current state
   * @param {*} state - The state to set.
   */
  set(state) {
    state || (state = this.defaultState);
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff >>= 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  }
  /**
   * Sets the state, when previous state is unknown.
   * @param {*} state - The state to set
   */
  forceState(state) {
    state || (state = this.defaultState);
    for (let i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  }
  /**
   * Sets whether to enable or disable blending.
   * @param value - Turn on or off WebGl blending.
   */
  setBlend(value) {
    this._updateCheck(_GlStateSystem._checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  /**
   * Sets whether to enable or disable polygon offset fill.
   * @param value - Turn on or off webgl polygon offset testing.
   */
  setOffset(value) {
    this._updateCheck(_GlStateSystem._checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  /**
   * Sets whether to enable or disable depth test.
   * @param value - Turn on or off webgl depth testing.
   */
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  /**
   * Sets whether to enable or disable depth mask.
   * @param value - Turn on or off webgl depth mask.
   */
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  /**
   * Sets whether to enable or disable cull face.
   * @param {boolean} value - Turn on or off webgl cull face.
   */
  setCullFace(value) {
    this._cullFace = value;
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    if (this._cullFace && this._frontFaceDirty) {
      this.setFrontFace(this._frontFace);
    }
  }
  /**
   * Sets the gl front face.
   * @param {boolean} value - true is clockwise and false is counter-clockwise
   */
  setFrontFace(value) {
    this._frontFace = value;
    this._frontFaceDirty = false;
    const faceMode = this._invertFrontFace ? !value : value;
    if (this._glFrontFace !== faceMode) {
      this._glFrontFace = faceMode;
      this.gl.frontFace(this.gl[faceMode ? "CW" : "CCW"]);
    }
  }
  /**
   * Sets the blend mode.
   * @param {number} value - The blend mode to set to.
   */
  setBlendMode(value) {
    if (!this.blendModesMap[value]) {
      value = "normal";
    }
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModesMap[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  /**
   * Sets the polygon offset.
   * @param {number} value - the polygon offset
   * @param {number} scale - the polygon offset scale
   */
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  // used
  /** Resets all the logic and disables the VAOs. */
  resetState() {
    this._glFrontFace = false;
    this._frontFace = false;
    this._cullFace = false;
    this._frontFaceDirty = false;
    this._invertFrontFace = false;
    this.gl.frontFace(this.gl.CCW);
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = "";
    this.setBlendMode("normal");
  }
  /**
   * Checks to see which updates should be checked based on which settings have been activated.
   *
   * For example, if blend is enabled then we should check the blend modes each time the state is changed
   * or if polygon fill is activated then we need to check if the polygon offset changes.
   * The idea is that we only check what we have too.
   * @param func - the checking function to add or remove
   * @param value - should the check function be added or removed.
   */
  _updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  }
  /**
   * A private little wrapper function that we call to check the blend mode.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static _checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  /**
   * A private little wrapper function that we call to check the polygon offset.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static _checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  /**
   * @ignore
   */
  destroy() {
    this.gl = null;
    this.checks.length = 0;
  }
};
/** @ignore */
_GlStateSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLSystem
  ],
  name: "state"
};
let GlStateSystem = _GlStateSystem;


//# sourceMappingURL=GlStateSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapWebGLBlendModesToPixi: () => (/* binding */ mapWebGLBlendModesToPixi)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  const isWebGl2 = !(gl instanceof _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getWebGLRenderingContext());
  if (isWebGl2) {
    blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
    blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
  } else {
    const ext = gl.getExtension("EXT_blend_minmax");
    if (ext) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
    }
  }
  return blendMap;
}


//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlTexture: () => (/* binding */ GlTexture)
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs");


"use strict";
class GlTexture {
  constructor(texture) {
    this.target = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TARGETS.TEXTURE_2D;
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.type = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_TYPES.UNSIGNED_BYTE;
    this.internalFormat = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_FORMATS.RGBA;
    this.format = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.GL_FORMATS.RGBA;
    this.samplerType = 0;
  }
}


//# sourceMappingURL=GlTexture.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlTextureSystem: () => (/* binding */ GlTextureSystem)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _GlTexture_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GlTexture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs");
/* harmony import */ var _uploaders_glUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uploaders/glUploadBufferImageResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs");
/* harmony import */ var _uploaders_glUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uploaders/glUploadCompressedTextureResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs");
/* harmony import */ var _uploaders_glUploadImageResource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uploaders/glUploadImageResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs");
/* harmony import */ var _uploaders_glUploadVideoResource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./uploaders/glUploadVideoResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs");
/* harmony import */ var _utils_applyStyleParams_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/applyStyleParams.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs");
/* harmony import */ var _utils_mapFormatToGlFormat_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/mapFormatToGlFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs");
/* harmony import */ var _utils_mapFormatToGlInternalFormat_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/mapFormatToGlInternalFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs");
/* harmony import */ var _utils_mapFormatToGlType_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/mapFormatToGlType.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs");














"use strict";
const BYTES_PER_PIXEL = 4;
class GlTextureSystem {
  constructor(renderer) {
    this.managedTextures = [];
    this._glTextures = /* @__PURE__ */ Object.create(null);
    this._glSamplers = /* @__PURE__ */ Object.create(null);
    this._boundTextures = [];
    this._activeTextureLocation = -1;
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    this._uploads = {
      image: _uploaders_glUploadImageResource_mjs__WEBPACK_IMPORTED_MODULE_0__.glUploadImageResource,
      buffer: _uploaders_glUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_1__.glUploadBufferImageResource,
      video: _uploaders_glUploadVideoResource_mjs__WEBPACK_IMPORTED_MODULE_2__.glUploadVideoResource,
      compressed: _uploaders_glUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_3__.glUploadCompressedTextureResource
    };
    this._premultiplyAlpha = false;
    // TODO - separate samplers will be a cool thing to add, but not right now!
    this._useSeparateSamplers = false;
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_glTextures");
    this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
  }
  contextChange(gl) {
    this._gl = gl;
    if (!this._mapFormatToInternalFormat) {
      this._mapFormatToInternalFormat = (0,_utils_mapFormatToGlInternalFormat_mjs__WEBPACK_IMPORTED_MODULE_4__.mapFormatToGlInternalFormat)(gl, this._renderer.context.extensions);
      this._mapFormatToType = (0,_utils_mapFormatToGlType_mjs__WEBPACK_IMPORTED_MODULE_5__.mapFormatToGlType)(gl);
      this._mapFormatToFormat = (0,_utils_mapFormatToGlFormat_mjs__WEBPACK_IMPORTED_MODULE_6__.mapFormatToGlFormat)(gl);
    }
    this._glTextures = /* @__PURE__ */ Object.create(null);
    this._glSamplers = /* @__PURE__ */ Object.create(null);
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    this._premultiplyAlpha = false;
    for (let i = 0; i < 16; i++) {
      this.bind(_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__.Texture.EMPTY, i);
    }
  }
  initSource(source) {
    this.bind(source);
  }
  bind(texture, location = 0) {
    const source = texture.source;
    if (texture) {
      this.bindSource(source, location);
      if (this._useSeparateSamplers) {
        this._bindSampler(source.style, location);
      }
    } else {
      this.bindSource(null, location);
      if (this._useSeparateSamplers) {
        this._bindSampler(null, location);
      }
    }
  }
  bindSource(source, location = 0) {
    const gl = this._gl;
    source._touched = this._renderer.textureGC.count;
    if (this._boundTextures[location] !== source) {
      this._boundTextures[location] = source;
      this._activateLocation(location);
      source || (source = _shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__.Texture.EMPTY.source);
      const glTexture = this.getGlSource(source);
      gl.bindTexture(glTexture.target, glTexture.texture);
    }
  }
  _bindSampler(style, location = 0) {
    const gl = this._gl;
    if (!style) {
      this._boundSamplers[location] = null;
      gl.bindSampler(location, null);
      return;
    }
    const sampler = this._getGlSampler(style);
    if (this._boundSamplers[location] !== sampler) {
      this._boundSamplers[location] = sampler;
      gl.bindSampler(location, sampler);
    }
  }
  unbind(texture) {
    const source = texture.source;
    const boundTextures = this._boundTextures;
    const gl = this._gl;
    for (let i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === source) {
        this._activateLocation(i);
        const glTexture = this.getGlSource(source);
        gl.bindTexture(glTexture.target, null);
        boundTextures[i] = null;
      }
    }
  }
  _activateLocation(location) {
    if (this._activeTextureLocation !== location) {
      this._activeTextureLocation = location;
      this._gl.activeTexture(this._gl.TEXTURE0 + location);
    }
  }
  _initSource(source) {
    const gl = this._gl;
    const glTexture = new _GlTexture_mjs__WEBPACK_IMPORTED_MODULE_8__.GlTexture(gl.createTexture());
    glTexture.type = this._mapFormatToType[source.format];
    glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];
    glTexture.format = this._mapFormatToFormat[source.format];
    if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {
      const biggestDimension = Math.max(source.width, source.height);
      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
    }
    this._glTextures[source.uid] = glTexture;
    if (!this.managedTextures.includes(source)) {
      source.on("update", this.onSourceUpdate, this);
      source.on("resize", this.onSourceUpdate, this);
      source.on("styleChange", this.onStyleChange, this);
      source.on("destroy", this.onSourceDestroy, this);
      source.on("unload", this.onSourceUnload, this);
      source.on("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.push(source);
    }
    this.onSourceUpdate(source);
    this.updateStyle(source, false);
    return glTexture;
  }
  onStyleChange(source) {
    this.updateStyle(source, false);
  }
  updateStyle(source, firstCreation) {
    const gl = this._gl;
    const glTexture = this.getGlSource(source);
    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
    this._boundTextures[this._activeTextureLocation] = source;
    (0,_utils_applyStyleParams_mjs__WEBPACK_IMPORTED_MODULE_9__.applyStyleParams)(
      source.style,
      gl,
      source.mipLevelCount > 1,
      this._renderer.context.extensions.anisotropicFiltering,
      "texParameteri",
      gl.TEXTURE_2D,
      // will force a clamp to edge if the texture is not a power of two
      !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,
      firstCreation
    );
  }
  onSourceUnload(source) {
    const glTexture = this._glTextures[source.uid];
    if (!glTexture)
      return;
    this.unbind(source);
    this._glTextures[source.uid] = null;
    this._gl.deleteTexture(glTexture.texture);
  }
  onSourceUpdate(source) {
    const gl = this._gl;
    const glTexture = this.getGlSource(source);
    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
    this._boundTextures[this._activeTextureLocation] = source;
    const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";
    if (this._premultiplyAlpha !== premultipliedAlpha) {
      this._premultiplyAlpha = premultipliedAlpha;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
    }
    if (this._uploads[source.uploadMethodId]) {
      this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {
      this.onUpdateMipmaps(source, false);
    }
  }
  onUpdateMipmaps(source, bind = true) {
    if (bind)
      this.bindSource(source, 0);
    const glTexture = this.getGlSource(source);
    this._gl.generateMipmap(glTexture.target);
  }
  onSourceDestroy(source) {
    source.off("destroy", this.onSourceDestroy, this);
    source.off("update", this.onSourceUpdate, this);
    source.off("resize", this.onSourceUpdate, this);
    source.off("unload", this.onSourceUnload, this);
    source.off("styleChange", this.onStyleChange, this);
    source.off("updateMipmaps", this.onUpdateMipmaps, this);
    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);
    this.onSourceUnload(source);
  }
  _initSampler(style) {
    const gl = this._gl;
    const glSampler = this._gl.createSampler();
    this._glSamplers[style._resourceId] = glSampler;
    (0,_utils_applyStyleParams_mjs__WEBPACK_IMPORTED_MODULE_9__.applyStyleParams)(
      style,
      gl,
      this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
      this._renderer.context.extensions.anisotropicFiltering,
      "samplerParameteri",
      glSampler,
      false,
      true
    );
    return this._glSamplers[style._resourceId];
  }
  _getGlSampler(sampler) {
    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
  }
  getGlSource(source) {
    return this._glTextures[source.uid] || this._initSource(source);
  }
  generateCanvas(texture) {
    const { pixels, width, height } = this.getPixels(texture);
    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_10__.DOMAdapter.get().createCanvas();
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (ctx) {
      const imageData = ctx.createImageData(width, height);
      imageData.data.set(pixels);
      ctx.putImageData(imageData, 0, 0);
    }
    return canvas;
  }
  getPixels(texture) {
    const resolution = texture.source.resolution;
    const frame = texture.frame;
    const width = Math.max(Math.round(frame.width * resolution), 1);
    const height = Math.max(Math.round(frame.height * resolution), 1);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const renderer = this._renderer;
    const renderTarget = renderer.renderTarget.getRenderTarget(texture);
    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
    const gl = renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
    gl.readPixels(
      Math.round(frame.x * resolution),
      Math.round(frame.y * resolution),
      width,
      height,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      pixels
    );
    if (false) // removed by dead control flow
{}
    return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
  }
  destroy() {
    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));
    this.managedTextures = null;
    this._renderer = null;
  }
  resetState() {
    this._activeTextureLocation = -1;
    this._boundTextures.fill(_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__.Texture.EMPTY.source);
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    const gl = this._gl;
    this._premultiplyAlpha = false;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
  }
}
/** @ignore */
GlTextureSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__.ExtensionType.WebGLSystem
  ],
  name: "texture"
};


//# sourceMappingURL=GlTextureSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GL_FORMATS: () => (/* binding */ GL_FORMATS),
/* harmony export */   GL_TARGETS: () => (/* binding */ GL_TARGETS),
/* harmony export */   GL_TYPES: () => (/* binding */ GL_TYPES),
/* harmony export */   GL_WRAP_MODES: () => (/* binding */ GL_WRAP_MODES)
/* harmony export */ });

var GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
  GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
  GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
  GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
  GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
  GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
  GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return GL_FORMATS2;
})(GL_FORMATS || {});
var GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
  GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return GL_TARGETS2;
})(GL_TARGETS || {});
var GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {
  GL_WRAP_MODES2[GL_WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  GL_WRAP_MODES2[GL_WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  GL_WRAP_MODES2[GL_WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return GL_WRAP_MODES2;
})(GL_WRAP_MODES || {});
var GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
  GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
  GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
  GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
  GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
  GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return GL_TYPES2;
})(GL_TYPES || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   glUploadBufferImageResource: () => (/* binding */ glUploadBufferImageResource)
/* harmony export */ });

const glUploadBufferImageResource = {
  id: "buffer",
  upload(source, glTexture, gl) {
    if (glTexture.width === source.width || glTexture.height === source.height) {
      gl.texSubImage2D(
        gl.TEXTURE_2D,
        0,
        0,
        0,
        source.width,
        source.height,
        glTexture.format,
        glTexture.type,
        source.resource
      );
    } else {
      gl.texImage2D(
        glTexture.target,
        0,
        glTexture.internalFormat,
        source.width,
        source.height,
        0,
        glTexture.format,
        glTexture.type,
        source.resource
      );
    }
    glTexture.width = source.width;
    glTexture.height = source.height;
  }
};


//# sourceMappingURL=glUploadBufferImageResource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   glUploadCompressedTextureResource: () => (/* binding */ glUploadCompressedTextureResource)
/* harmony export */ });

const compressedFormatMap = {
  "bc1-rgba-unorm": true,
  "bc1-rgba-unorm-srgb": true,
  "bc2-rgba-unorm": true,
  "bc2-rgba-unorm-srgb": true,
  "bc3-rgba-unorm": true,
  "bc3-rgba-unorm-srgb": true,
  "bc4-r-unorm": true,
  "bc4-r-snorm": true,
  "bc5-rg-unorm": true,
  "bc5-rg-snorm": true,
  "bc6h-rgb-ufloat": true,
  "bc6h-rgb-float": true,
  "bc7-rgba-unorm": true,
  "bc7-rgba-unorm-srgb": true,
  // ETC2 compressed formats usable if "texture-compression-etc2" is both
  // supported by the device/user agent and enabled in requestDevice.
  "etc2-rgb8unorm": true,
  "etc2-rgb8unorm-srgb": true,
  "etc2-rgb8a1unorm": true,
  "etc2-rgb8a1unorm-srgb": true,
  "etc2-rgba8unorm": true,
  "etc2-rgba8unorm-srgb": true,
  "eac-r11unorm": true,
  "eac-r11snorm": true,
  "eac-rg11unorm": true,
  "eac-rg11snorm": true,
  // ASTC compressed formats usable if "texture-compression-astc" is both
  // supported by the device/user agent and enabled in requestDevice.
  "astc-4x4-unorm": true,
  "astc-4x4-unorm-srgb": true,
  "astc-5x4-unorm": true,
  "astc-5x4-unorm-srgb": true,
  "astc-5x5-unorm": true,
  "astc-5x5-unorm-srgb": true,
  "astc-6x5-unorm": true,
  "astc-6x5-unorm-srgb": true,
  "astc-6x6-unorm": true,
  "astc-6x6-unorm-srgb": true,
  "astc-8x5-unorm": true,
  "astc-8x5-unorm-srgb": true,
  "astc-8x6-unorm": true,
  "astc-8x6-unorm-srgb": true,
  "astc-8x8-unorm": true,
  "astc-8x8-unorm-srgb": true,
  "astc-10x5-unorm": true,
  "astc-10x5-unorm-srgb": true,
  "astc-10x6-unorm": true,
  "astc-10x6-unorm-srgb": true,
  "astc-10x8-unorm": true,
  "astc-10x8-unorm-srgb": true,
  "astc-10x10-unorm": true,
  "astc-10x10-unorm-srgb": true,
  "astc-12x10-unorm": true,
  "astc-12x10-unorm-srgb": true,
  "astc-12x12-unorm": true,
  "astc-12x12-unorm-srgb": true
};
const glUploadCompressedTextureResource = {
  id: "compressed",
  upload(source, glTexture, gl) {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    let mipWidth = source.pixelWidth;
    let mipHeight = source.pixelHeight;
    const compressed = !!compressedFormatMap[source.format];
    for (let i = 0; i < source.resource.length; i++) {
      const levelBuffer = source.resource[i];
      if (compressed) {
        gl.compressedTexImage2D(
          gl.TEXTURE_2D,
          i,
          glTexture.internalFormat,
          mipWidth,
          mipHeight,
          0,
          levelBuffer
        );
      } else {
        gl.texImage2D(
          gl.TEXTURE_2D,
          i,
          glTexture.internalFormat,
          mipWidth,
          mipHeight,
          0,
          glTexture.format,
          glTexture.type,
          levelBuffer
        );
      }
      mipWidth = Math.max(mipWidth >> 1, 1);
      mipHeight = Math.max(mipHeight >> 1, 1);
    }
  }
};


//# sourceMappingURL=glUploadCompressedTextureResource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   glUploadImageResource: () => (/* binding */ glUploadImageResource)
/* harmony export */ });

const glUploadImageResource = {
  id: "image",
  upload(source, glTexture, gl, webGLVersion) {
    const glWidth = glTexture.width;
    const glHeight = glTexture.height;
    const textureWidth = source.pixelWidth;
    const textureHeight = source.pixelHeight;
    const resourceWidth = source.resourceWidth;
    const resourceHeight = source.resourceHeight;
    if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
      if (glWidth !== textureWidth || glHeight !== textureHeight) {
        gl.texImage2D(
          glTexture.target,
          0,
          glTexture.internalFormat,
          textureWidth,
          textureHeight,
          0,
          glTexture.format,
          glTexture.type,
          null
        );
      }
      if (webGLVersion === 2) {
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          resourceWidth,
          resourceHeight,
          glTexture.format,
          glTexture.type,
          source.resource
        );
      } else {
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          glTexture.format,
          glTexture.type,
          source.resource
        );
      }
    } else if (glWidth === textureWidth && glHeight === textureHeight) {
      gl.texSubImage2D(
        gl.TEXTURE_2D,
        0,
        0,
        0,
        glTexture.format,
        glTexture.type,
        source.resource
      );
    } else if (webGLVersion === 2) {
      gl.texImage2D(
        glTexture.target,
        0,
        glTexture.internalFormat,
        textureWidth,
        textureHeight,
        0,
        glTexture.format,
        glTexture.type,
        source.resource
      );
    } else {
      gl.texImage2D(
        glTexture.target,
        0,
        glTexture.internalFormat,
        glTexture.format,
        glTexture.type,
        source.resource
      );
    }
    glTexture.width = textureWidth;
    glTexture.height = textureHeight;
  }
};


//# sourceMappingURL=glUploadImageResource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   glUploadVideoResource: () => (/* binding */ glUploadVideoResource)
/* harmony export */ });
/* harmony import */ var _glUploadImageResource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./glUploadImageResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs");


"use strict";
const glUploadVideoResource = {
  id: "video",
  upload(source, glTexture, gl, webGLVersion) {
    if (!source.isValid) {
      gl.texImage2D(
        glTexture.target,
        0,
        glTexture.internalFormat,
        1,
        1,
        0,
        glTexture.format,
        glTexture.type,
        null
      );
      return;
    }
    _glUploadImageResource_mjs__WEBPACK_IMPORTED_MODULE_0__.glUploadImageResource.upload(source, glTexture, gl, webGLVersion);
  }
};


//# sourceMappingURL=glUploadVideoResource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyStyleParams: () => (/* binding */ applyStyleParams)
/* harmony export */ });
/* harmony import */ var _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pixiToGlMaps.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs");


"use strict";
function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
  const castParam = firstParam;
  if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
    const wrapModeS = _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__.wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
    const wrapModeT = _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__.wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
    const wrapModeR = _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__.wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
    if (gl.TEXTURE_WRAP_R)
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
  }
  if (!firstCreation || style.magFilter !== "linear") {
    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__.scaleModeToGlFilter[style.magFilter]);
  }
  if (mipmaps) {
    if (!firstCreation || style.mipmapFilter !== "linear") {
      const glFilterMode = _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__.mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
    }
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__.scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, _pixiToGlMaps_mjs__WEBPACK_IMPORTED_MODULE_0__.compareModeToGlCompare[style.compare]);
  }
}


//# sourceMappingURL=applyStyleParams.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSupportedGlCompressedTextureFormats: () => (/* binding */ getSupportedGlCompressedTextureFormats)
/* harmony export */ });

let supportedGLCompressedTextureFormats;
function getSupportedGlCompressedTextureFormats() {
  if (supportedGLCompressedTextureFormats)
    return supportedGLCompressedTextureFormats;
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl");
  if (!gl) {
    return [];
  }
  supportedGLCompressedTextureFormats = [
    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    // 'bc6h-rgb-ufloat'
    // 'bc6h-rgb-float'
    // 'bc7-rgba-unorm',
    // 'bc7-rgba-unorm-srgb',
    ...gl.getExtension("EXT_texture_compression_bptc") ? [
      "bc6h-rgb-ufloat",
      "bc6h-rgb-float",
      "bc7-rgba-unorm",
      "bc7-rgba-unorm-srgb"
    ] : [],
    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    // 'bc1-rgba-unorm',
    // 'bc1-rgba-unorm-srgb',
    // 'bc4-r-unorm'
    // 'bc4-r-snorm'
    // 'bc5-rg-unorm'
    // 'bc5-rg-snorm'
    ...gl.getExtension("WEBGL_compressed_texture_s3tc") ? [
      "bc1-rgba-unorm",
      "bc2-rgba-unorm",
      "bc3-rgba-unorm"
    ] : [],
    ...gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? [
      "bc1-rgba-unorm-srgb",
      "bc2-rgba-unorm-srgb",
      "bc3-rgba-unorm-srgb"
    ] : [],
    ...gl.getExtension("EXT_texture_compression_rgtc") ? [
      "bc4-r-unorm",
      "bc4-r-snorm",
      "bc5-rg-unorm",
      "bc5-rg-snorm"
    ] : [],
    // ETC2 compressed formats usable if "texture-compression-etc2" is both
    // supported by the device/user agent and enabled in requestDevice.
    ...gl.getExtension("WEBGL_compressed_texture_etc") ? [
      "etc2-rgb8unorm",
      "etc2-rgb8unorm-srgb",
      "etc2-rgba8unorm",
      "etc2-rgba8unorm-srgb",
      "etc2-rgb8a1unorm",
      "etc2-rgb8a1unorm-srgb",
      "eac-r11unorm",
      "eac-rg11unorm"
    ] : [],
    // 'eac-r11snorm',
    // 'eac-rg11snorm',
    // ASTC compressed formats usable if "texture-compression-astc" is both
    // supported by the device/user agent and enabled in requestDevice.
    ...gl.getExtension("WEBGL_compressed_texture_astc") ? [
      "astc-4x4-unorm",
      "astc-4x4-unorm-srgb",
      "astc-5x4-unorm",
      "astc-5x4-unorm-srgb",
      "astc-5x5-unorm",
      "astc-5x5-unorm-srgb",
      "astc-6x5-unorm",
      "astc-6x5-unorm-srgb",
      "astc-6x6-unorm",
      "astc-6x6-unorm-srgb",
      "astc-8x5-unorm",
      "astc-8x5-unorm-srgb",
      "astc-8x6-unorm",
      "astc-8x6-unorm-srgb",
      "astc-8x8-unorm",
      "astc-8x8-unorm-srgb",
      "astc-10x5-unorm",
      "astc-10x5-unorm-srgb",
      "astc-10x6-unorm",
      "astc-10x6-unorm-srgb",
      "astc-10x8-unorm",
      "astc-10x8-unorm-srgb",
      "astc-10x10-unorm",
      "astc-10x10-unorm-srgb",
      "astc-12x10-unorm",
      "astc-12x10-unorm-srgb",
      "astc-12x12-unorm",
      "astc-12x12-unorm-srgb"
    ] : []
  ];
  return supportedGLCompressedTextureFormats;
}


//# sourceMappingURL=getSupportedGlCompressedTextureFormats.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapFormatToGlFormat: () => (/* binding */ mapFormatToGlFormat)
/* harmony export */ });

function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}


//# sourceMappingURL=mapFormatToGlFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapFormatToGlInternalFormat: () => (/* binding */ mapFormatToGlInternalFormat)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
function mapFormatToGlInternalFormat(gl, extensions) {
  let srgb = {};
  let bgra8unorm = gl.RGBA;
  if (!(gl instanceof _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getWebGLRenderingContext())) {
    srgb = {
      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
      "bgra8unorm-srgb": gl.SRGB8_ALPHA8
    };
    bgra8unorm = gl.RGBA8;
  } else if (extensions.srgb) {
    srgb = {
      "rgba8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT
    };
  }
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    ...srgb,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
    // Compressed formats
    ...extensions.s3tc ? {
      "bc1-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {},
    ...extensions.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {},
    ...extensions.rgtc ? {
      "bc4-r-unorm": extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {},
    ...extensions.bptc ? {
      "bc6h-rgb-float": extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {},
    ...extensions.etc ? {
      "etc2-rgb8unorm": extensions.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": extensions.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {},
    ...extensions.astc ? {
      "astc-4x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {}
  };
}


//# sourceMappingURL=mapFormatToGlInternalFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapFormatToGlType: () => (/* binding */ mapFormatToGlType)
/* harmony export */ });

function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}


//# sourceMappingURL=mapFormatToGlType.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareModeToGlCompare: () => (/* binding */ compareModeToGlCompare),
/* harmony export */   mipmapScaleModeToGlFilter: () => (/* binding */ mipmapScaleModeToGlFilter),
/* harmony export */   scaleModeToGlFilter: () => (/* binding */ scaleModeToGlFilter),
/* harmony export */   wrapModeToGlAddress: () => (/* binding */ wrapModeToGlAddress)
/* harmony export */ });

const scaleModeToGlFilter = {
  linear: 9729,
  nearest: 9728
};
const mipmapScaleModeToGlFilter = {
  linear: {
    linear: 9987,
    nearest: 9985
  },
  nearest: {
    linear: 9986,
    nearest: 9984
  }
};
const wrapModeToGlAddress = {
  "clamp-to-edge": 33071,
  repeat: 10497,
  "mirror-repeat": 33648
};
const compareModeToGlCompare = {
  never: 512,
  less: 513,
  equal: 514,
  "less-equal": 515,
  greater: 516,
  "not-equal": 517,
  "greater-equal": 518,
  always: 519
};


//# sourceMappingURL=pixiToGlMaps.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   unpremultiplyAlpha: () => (/* binding */ unpremultiplyAlpha)
/* harmony export */ });

function unpremultiplyAlpha(pixels) {
  if (pixels instanceof Uint8ClampedArray) {
    pixels = new Uint8Array(pixels.buffer);
  }
  const n = pixels.length;
  for (let i = 0; i < n; i += 4) {
    const alpha = pixels[i + 3];
    if (alpha !== 0) {
      const a = 255.001 / alpha;
      pixels[i] = pixels[i] * a + 0.5;
      pixels[i + 1] = pixels[i + 1] * a + 0.5;
      pixels[i + 2] = pixels[i + 2] * a + 0.5;
    }
  }
}


//# sourceMappingURL=unpremultiplyAlpha.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindGroupSystem: () => (/* binding */ BindGroupSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class BindGroupSystem {
  constructor(renderer) {
    this._hash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_hash");
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getBindGroup(bindGroup, program, groupIndex) {
    bindGroup._updateKey();
    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
    return gpuBindGroup;
  }
  _createBindGroup(group, program, groupIndex) {
    const device = this._gpu.device;
    const groupLayout = program.layout[groupIndex];
    const entries = [];
    const renderer = this._renderer;
    for (const j in groupLayout) {
      const resource = group.resources[j] ?? group.resources[groupLayout[j]];
      let gpuResource;
      if (resource._resourceType === "uniformGroup") {
        const uniformGroup = resource;
        renderer.ubo.updateUniformGroup(uniformGroup);
        const buffer = uniformGroup.buffer;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(buffer),
          offset: 0,
          size: buffer.descriptor.size
        };
      } else if (resource._resourceType === "buffer") {
        const buffer = resource;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(buffer),
          offset: 0,
          size: buffer.descriptor.size
        };
      } else if (resource._resourceType === "bufferResource") {
        const bufferResource = resource;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
          offset: bufferResource.offset,
          size: bufferResource.size
        };
      } else if (resource._resourceType === "textureSampler") {
        const sampler = resource;
        gpuResource = renderer.texture.getGpuSampler(sampler);
      } else if (resource._resourceType === "textureSource") {
        const texture = resource;
        gpuResource = renderer.texture.getGpuSource(texture).createView({});
      }
      entries.push({
        binding: groupLayout[j],
        resource: gpuResource
      });
    }
    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
    const gpuBindGroup = device.createBindGroup({
      layout,
      entries
    });
    this._hash[group._key] = gpuBindGroup;
    return gpuBindGroup;
  }
  destroy() {
    for (const key of Object.keys(this._hash)) {
      this._hash[key] = null;
    }
    this._hash = null;
    this._renderer = null;
  }
}
/** @ignore */
BindGroupSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUSystem
  ],
  name: "bindGroup"
};


//# sourceMappingURL=BindGroupSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuColorMaskSystem: () => (/* binding */ GpuColorMaskSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class GpuColorMaskSystem {
  constructor(renderer) {
    this._colorMaskCache = 15;
    this._renderer = renderer;
  }
  setMask(colorMask) {
    if (this._colorMaskCache === colorMask)
      return;
    this._colorMaskCache = colorMask;
    this._renderer.pipeline.setColorMask(colorMask);
  }
  destroy() {
    this._renderer = null;
    this._colorMaskCache = null;
  }
}
/** @ignore */
GpuColorMaskSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUSystem
  ],
  name: "colorMask"
};


//# sourceMappingURL=GpuColorMaskSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuDeviceSystem: () => (/* binding */ GpuDeviceSystem)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");



"use strict";
class GpuDeviceSystem {
  /**
   * @param {WebGPURenderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this._renderer = renderer;
  }
  async init(options) {
    if (this._initPromise)
      return this._initPromise;
    this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {
      this.gpu = gpu;
      this._renderer.runners.contextChange.emit(this.gpu);
    });
    return this._initPromise;
  }
  /**
   * Handle the context change event
   * @param gpu
   */
  contextChange(gpu) {
    this._renderer.gpu = gpu;
  }
  /**
   * Helper class to create a WebGL Context
   * @param {object} options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */
  async _createDeviceAndAdaptor(options) {
    const adapter = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getNavigator().gpu.requestAdapter({
      powerPreference: options.powerPreference,
      forceFallbackAdapter: options.forceFallbackAdapter
    });
    const requiredFeatures = [
      "texture-compression-bc",
      "texture-compression-astc",
      "texture-compression-etc2"
    ].filter((feature) => adapter.features.has(feature));
    const device = await adapter.requestDevice({
      requiredFeatures
    });
    return { adapter, device };
  }
  destroy() {
    this.gpu = null;
    this._renderer = null;
  }
}
/** @ignore */
GpuDeviceSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem
  ],
  name: "device"
};
/** The default options for the GpuDeviceSystem. */
GpuDeviceSystem.defaultOptions = {
  /**
   * {@link WebGPUOptions.powerPreference}
   * @default default
   */
  powerPreference: void 0,
  /**
   * Force the use of the fallback adapter
   * @default false
   */
  forceFallbackAdapter: false
};


//# sourceMappingURL=GpuDeviceSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuEncoderSystem: () => (/* binding */ GpuEncoderSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class GpuEncoderSystem {
  constructor(renderer) {
    this._boundBindGroup = /* @__PURE__ */ Object.create(null);
    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
  }
  renderStart() {
    this.commandFinished = new Promise((resolve) => {
      this._resolveCommandFinished = resolve;
    });
    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
  }
  beginRenderPass(gpuRenderTarget) {
    this.endRenderPass();
    this._clearCache();
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
  }
  endRenderPass() {
    if (this.renderPassEncoder) {
      this.renderPassEncoder.end();
    }
    this.renderPassEncoder = null;
  }
  setViewport(viewport) {
    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
  }
  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
    this.setPipeline(pipeline);
  }
  setPipeline(pipeline) {
    if (this._boundPipeline === pipeline)
      return;
    this._boundPipeline = pipeline;
    this.renderPassEncoder.setPipeline(pipeline);
  }
  _setVertexBuffer(index, buffer) {
    if (this._boundVertexBuffer[index] === buffer)
      return;
    this._boundVertexBuffer[index] = buffer;
    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
  }
  _setIndexBuffer(buffer) {
    if (this._boundIndexBuffer === buffer)
      return;
    this._boundIndexBuffer = buffer;
    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
  }
  resetBindGroup(index) {
    this._boundBindGroup[index] = null;
  }
  setBindGroup(index, bindGroup, program) {
    if (this._boundBindGroup[index] === bindGroup)
      return;
    this._boundBindGroup[index] = bindGroup;
    bindGroup._touch(this._renderer.textureGC.count);
    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
  }
  setGeometry(geometry, program) {
    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
    for (const i in buffersToBind) {
      this._setVertexBuffer(i, geometry.attributes[buffersToBind[i]].buffer);
    }
    if (geometry.indexBuffer) {
      this._setIndexBuffer(geometry.indexBuffer);
    }
  }
  _setShaderBindGroups(shader, skipSync) {
    for (const i in shader.groups) {
      const bindGroup = shader.groups[i];
      if (!skipSync) {
        this._syncBindGroup(bindGroup);
      }
      this.setBindGroup(i, bindGroup, shader.gpuProgram);
    }
  }
  _syncBindGroup(bindGroup) {
    for (const j in bindGroup.resources) {
      const resource = bindGroup.resources[j];
      if (resource.isUniformGroup) {
        this._renderer.ubo.updateUniformGroup(resource);
      }
    }
  }
  draw(options) {
    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
    this.setGeometry(geometry, shader.gpuProgram);
    this._setShaderBindGroups(shader, skipSync);
    if (geometry.indexBuffer) {
      this.renderPassEncoder.drawIndexed(
        size || geometry.indexBuffer.data.length,
        instanceCount ?? geometry.instanceCount,
        start || 0
      );
    } else {
      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);
    }
  }
  finishRenderPass() {
    if (this.renderPassEncoder) {
      this.renderPassEncoder.end();
      this.renderPassEncoder = null;
    }
  }
  postrender() {
    this.finishRenderPass();
    this._gpu.device.queue.submit([this.commandEncoder.finish()]);
    this._resolveCommandFinished();
    this.commandEncoder = null;
  }
  // restores a render pass if finishRenderPass was called
  // not optimised as really used for debugging!
  // used when we want to stop drawing and log a texture..
  restoreRenderPass() {
    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
      this._renderer.renderTarget.renderTarget,
      false,
      [0, 0, 0, 1]
    );
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
    const boundPipeline = this._boundPipeline;
    const boundVertexBuffer = { ...this._boundVertexBuffer };
    const boundIndexBuffer = this._boundIndexBuffer;
    const boundBindGroup = { ...this._boundBindGroup };
    this._clearCache();
    const viewport = this._renderer.renderTarget.viewport;
    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
    this.setPipeline(boundPipeline);
    for (const i in boundVertexBuffer) {
      this._setVertexBuffer(i, boundVertexBuffer[i]);
    }
    for (const i in boundBindGroup) {
      this.setBindGroup(i, boundBindGroup[i], null);
    }
    this._setIndexBuffer(boundIndexBuffer);
  }
  _clearCache() {
    for (let i = 0; i < 16; i++) {
      this._boundBindGroup[i] = null;
      this._boundVertexBuffer[i] = null;
    }
    this._boundIndexBuffer = null;
    this._boundPipeline = null;
  }
  destroy() {
    this._renderer = null;
    this._gpu = null;
    this._boundBindGroup = null;
    this._boundVertexBuffer = null;
    this._boundIndexBuffer = null;
    this._boundPipeline = null;
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
}
/** @ignore */
GpuEncoderSystem.extension = {
  type: [_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUSystem],
  name: "encoder",
  priority: 1
};


//# sourceMappingURL=GpuEncoderSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuStencilSystem: () => (/* binding */ GpuStencilSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/state/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");



"use strict";
class GpuStencilSystem {
  constructor(renderer) {
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(renderTarget) {
    let stencilState = this._renderTargetStencilState[renderTarget.uid];
    if (!stencilState) {
      stencilState = this._renderTargetStencilState[renderTarget.uid] = {
        stencilMode: _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.DISABLED,
        stencilReference: 0
      };
    }
    this._activeRenderTarget = renderTarget;
    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
  }
  setStencilMode(stencilMode, stencilReference) {
    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
    stencilState.stencilMode = stencilMode;
    stencilState.stencilReference = stencilReference;
    const renderer = this._renderer;
    renderer.pipeline.setStencilMode(stencilMode);
    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
  }
  destroy() {
    this._renderer.renderTarget.onRenderTargetChange.remove(this);
    this._renderer = null;
    this._activeRenderTarget = null;
    this._renderTargetStencilState = null;
  }
}
/** @ignore */
GpuStencilSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem
  ],
  name: "stencil"
};


//# sourceMappingURL=GpuStencilSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuUboSystem: () => (/* binding */ GpuUboSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_shader_UboSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/shader/UboSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs");
/* harmony import */ var _shader_utils_createUboElementsWGSL_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader/utils/createUboElementsWGSL.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs");
/* harmony import */ var _shader_utils_createUboSyncFunctionWGSL_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader/utils/createUboSyncFunctionWGSL.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs");





"use strict";
class GpuUboSystem extends _shared_shader_UboSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.UboSystem {
  constructor() {
    super({
      createUboElements: _shader_utils_createUboElementsWGSL_mjs__WEBPACK_IMPORTED_MODULE_1__.createUboElementsWGSL,
      generateUboSync: _shader_utils_createUboSyncFunctionWGSL_mjs__WEBPACK_IMPORTED_MODULE_2__.createUboSyncFunctionWGSL
    });
  }
}
/** @ignore */
GpuUboSystem.extension = {
  type: [_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGPUSystem],
  name: "ubo"
};


//# sourceMappingURL=GpuUboSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuUniformBatchPipe: () => (/* binding */ GpuUniformBatchPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/buffer/BufferResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs");
/* harmony import */ var _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");
/* harmony import */ var _buffer_UboBatch_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer/UboBatch.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs");
/* harmony import */ var _shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");







"use strict";
const minUniformOffsetAlignment = 128;
class GpuUniformBatchPipe {
  constructor(renderer) {
    this._bindGroupHash = /* @__PURE__ */ Object.create(null);
    // number of buffers..
    this._buffers = [];
    this._bindGroups = [];
    this._bufferResources = [];
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
    this._batchBuffer = new _buffer_UboBatch_mjs__WEBPACK_IMPORTED_MODULE_0__.UboBatch({ minUniformOffsetAlignment });
    const totalBuffers = 256 / minUniformOffsetAlignment;
    for (let i = 0; i < totalBuffers; i++) {
      let usage = _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.UNIFORM | _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.COPY_DST;
      if (i === 0)
        usage |= _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.COPY_SRC;
      this._buffers.push(new _shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__.Buffer({
        data: this._batchBuffer.data,
        usage
      }));
    }
  }
  renderEnd() {
    this._uploadBindGroups();
    this._resetBindGroups();
  }
  _resetBindGroups() {
    for (const i in this._bindGroupHash) {
      this._bindGroupHash[i] = null;
    }
    this._batchBuffer.clear();
  }
  // just works for single bind groups for now
  getUniformBindGroup(group, duplicate) {
    if (!duplicate && this._bindGroupHash[group.uid]) {
      return this._bindGroupHash[group.uid];
    }
    this._renderer.ubo.ensureUniformGroup(group);
    const data = group.buffer.data;
    const offset = this._batchBuffer.addEmptyGroup(data.length);
    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
    return this._bindGroupHash[group.uid];
  }
  getUboResource(group) {
    this._renderer.ubo.updateUniformGroup(group);
    const data = group.buffer.data;
    const offset = this._batchBuffer.addGroup(data);
    return this._getBufferResource(offset / minUniformOffsetAlignment);
  }
  getArrayBindGroup(data) {
    const offset = this._batchBuffer.addGroup(data);
    return this._getBindGroup(offset / minUniformOffsetAlignment);
  }
  getArrayBufferResource(data) {
    const offset = this._batchBuffer.addGroup(data);
    const index = offset / minUniformOffsetAlignment;
    return this._getBufferResource(index);
  }
  _getBufferResource(index) {
    if (!this._bufferResources[index]) {
      const buffer = this._buffers[index % 2];
      this._bufferResources[index] = new _shared_buffer_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_3__.BufferResource({
        buffer,
        offset: (index / 2 | 0) * 256,
        size: minUniformOffsetAlignment
      });
    }
    return this._bufferResources[index];
  }
  _getBindGroup(index) {
    if (!this._bindGroups[index]) {
      const bindGroup = new _shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_4__.BindGroup({
        0: this._getBufferResource(index)
      });
      this._bindGroups[index] = bindGroup;
    }
    return this._bindGroups[index];
  }
  _uploadBindGroups() {
    const bufferSystem = this._renderer.buffer;
    const firstBuffer = this._buffers[0];
    firstBuffer.update(this._batchBuffer.byteIndex);
    bufferSystem.updateBuffer(firstBuffer);
    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    for (let i = 1; i < this._buffers.length; i++) {
      const buffer = this._buffers[i];
      commandEncoder.copyBufferToBuffer(
        bufferSystem.getGPUBuffer(firstBuffer),
        minUniformOffsetAlignment,
        bufferSystem.getGPUBuffer(buffer),
        0,
        this._batchBuffer.byteIndex
      );
    }
    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
  }
  destroy() {
    for (let i = 0; i < this._bindGroups.length; i++) {
      this._bindGroups[i].destroy();
    }
    this._bindGroups = null;
    this._bindGroupHash = null;
    for (let i = 0; i < this._buffers.length; i++) {
      this._buffers[i].destroy();
    }
    this._buffers = null;
    for (let i = 0; i < this._bufferResources.length; i++) {
      this._bufferResources[i].destroy();
    }
    this._bufferResources = null;
    this._batchBuffer.destroy();
    this._bindGroupHash = null;
    this._renderer = null;
  }
}
/** @ignore */
GpuUniformBatchPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__.ExtensionType.WebGPUPipes
  ],
  name: "uniformBatch"
};


//# sourceMappingURL=GpuUniformBatchPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGPURenderer: () => (/* binding */ WebGPURenderer)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _scene_graphics_gpu_GpuGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../scene/graphics/gpu/GpuGraphicsAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs");
/* harmony import */ var _scene_mesh_gpu_GpuMeshAdapter_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../scene/mesh/gpu/GpuMeshAdapter.mjs */ "./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs");
/* harmony import */ var _batcher_gpu_GpuBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../batcher/gpu/GpuBatchAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs");
/* harmony import */ var _shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../shared/system/AbstractRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs");
/* harmony import */ var _shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/system/SharedSystems.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _BindGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./BindGroupSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs");
/* harmony import */ var _buffer_GpuBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buffer/GpuBufferSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs");
/* harmony import */ var _GpuColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./GpuColorMaskSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs");
/* harmony import */ var _GpuDeviceSystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GpuDeviceSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs");
/* harmony import */ var _GpuEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GpuEncoderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs");
/* harmony import */ var _GpuStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./GpuStencilSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs");
/* harmony import */ var _GpuUboSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GpuUboSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs");
/* harmony import */ var _GpuUniformBatchPipe_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./GpuUniformBatchPipe.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs");
/* harmony import */ var _pipeline_PipelineSystem_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pipeline/PipelineSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs");
/* harmony import */ var _renderTarget_GpuRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderTarget/GpuRenderTargetSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs");
/* harmony import */ var _shader_GpuShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shader/GpuShaderSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs");
/* harmony import */ var _state_GpuStateSystem_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./state/GpuStateSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs");
/* harmony import */ var _texture_GpuTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture/GpuTextureSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs");





















"use strict";
const DefaultWebGPUSystems = [
  ..._shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_0__.SharedSystems,
  _GpuUboSystem_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuUboSystem,
  _GpuEncoderSystem_mjs__WEBPACK_IMPORTED_MODULE_2__.GpuEncoderSystem,
  _GpuDeviceSystem_mjs__WEBPACK_IMPORTED_MODULE_3__.GpuDeviceSystem,
  _buffer_GpuBufferSystem_mjs__WEBPACK_IMPORTED_MODULE_4__.GpuBufferSystem,
  _texture_GpuTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_5__.GpuTextureSystem,
  _renderTarget_GpuRenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_6__.GpuRenderTargetSystem,
  _shader_GpuShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_7__.GpuShaderSystem,
  _state_GpuStateSystem_mjs__WEBPACK_IMPORTED_MODULE_8__.GpuStateSystem,
  _pipeline_PipelineSystem_mjs__WEBPACK_IMPORTED_MODULE_9__.PipelineSystem,
  _GpuColorMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_10__.GpuColorMaskSystem,
  _GpuStencilSystem_mjs__WEBPACK_IMPORTED_MODULE_11__.GpuStencilSystem,
  _BindGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.BindGroupSystem
];
const DefaultWebGPUPipes = [..._shared_system_SharedSystems_mjs__WEBPACK_IMPORTED_MODULE_0__.SharedRenderPipes, _GpuUniformBatchPipe_mjs__WEBPACK_IMPORTED_MODULE_13__.GpuUniformBatchPipe];
const DefaultWebGPUAdapters = [_batcher_gpu_GpuBatchAdaptor_mjs__WEBPACK_IMPORTED_MODULE_14__.GpuBatchAdaptor, _scene_mesh_gpu_GpuMeshAdapter_mjs__WEBPACK_IMPORTED_MODULE_15__.GpuMeshAdapter, _scene_graphics_gpu_GpuGraphicsAdaptor_mjs__WEBPACK_IMPORTED_MODULE_16__.GpuGraphicsAdaptor];
const systems = [];
const renderPipes = [];
const renderPipeAdaptors = [];
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.handleByNamedList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.ExtensionType.WebGPUSystem, systems);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.handleByNamedList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.ExtensionType.WebGPUPipes, renderPipes);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.handleByNamedList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_17__.extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
class WebGPURenderer extends _shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_18__.AbstractRenderer {
  constructor() {
    const systemConfig = {
      name: "webgpu",
      type: _types_mjs__WEBPACK_IMPORTED_MODULE_19__.RendererType.WEBGPU,
      systems,
      renderPipes,
      renderPipeAdaptors
    };
    super(systemConfig);
  }
}


//# sourceMappingURL=WebGPURenderer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuBufferSystem: () => (/* binding */ GpuBufferSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_buffer_utils_fastCopy_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/buffer/utils/fastCopy.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs");



"use strict";
class GpuBufferSystem {
  constructor(renderer) {
    this._gpuBuffers = /* @__PURE__ */ Object.create(null);
    this._managedBuffers = [];
    renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getGPUBuffer(buffer) {
    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
  }
  updateBuffer(buffer) {
    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
    const data = buffer.data;
    if (buffer._updateID && data) {
      buffer._updateID = 0;
      this._gpu.device.queue.writeBuffer(
        gpuBuffer,
        0,
        data.buffer,
        0,
        // round to the nearest 4 bytes
        (buffer._updateSize || data.byteLength) + 3 & ~3
      );
    }
    return gpuBuffer;
  }
  /** dispose all WebGL resources of all managed buffers */
  destroyAll() {
    for (const id in this._gpuBuffers) {
      this._gpuBuffers[id].destroy();
    }
    this._gpuBuffers = {};
  }
  createGPUBuffer(buffer) {
    if (!this._gpuBuffers[buffer.uid]) {
      buffer.on("update", this.updateBuffer, this);
      buffer.on("change", this.onBufferChange, this);
      buffer.on("destroy", this.onBufferDestroy, this);
      this._managedBuffers.push(buffer);
    }
    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
    buffer._updateID = 0;
    if (buffer.data) {
      (0,_shared_buffer_utils_fastCopy_mjs__WEBPACK_IMPORTED_MODULE_0__.fastCopy)(buffer.data.buffer, gpuBuffer.getMappedRange());
      gpuBuffer.unmap();
    }
    this._gpuBuffers[buffer.uid] = gpuBuffer;
    return gpuBuffer;
  }
  onBufferChange(buffer) {
    const gpuBuffer = this._gpuBuffers[buffer.uid];
    gpuBuffer.destroy();
    buffer._updateID = 0;
    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
  }
  /**
   * Disposes buffer
   * @param buffer - buffer with data
   */
  onBufferDestroy(buffer) {
    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
    this._destroyBuffer(buffer);
  }
  destroy() {
    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
    this._managedBuffers = null;
    this._gpuBuffers = null;
  }
  _destroyBuffer(buffer) {
    const gpuBuffer = this._gpuBuffers[buffer.uid];
    gpuBuffer.destroy();
    buffer.off("update", this.updateBuffer, this);
    buffer.off("change", this.onBufferChange, this);
    buffer.off("destroy", this.onBufferDestroy, this);
    this._gpuBuffers[buffer.uid] = null;
  }
}
/** @ignore */
GpuBufferSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem
  ],
  name: "buffer"
};


//# sourceMappingURL=GpuBufferSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuReadBuffer.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuReadBuffer.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuReadBuffer: () => (/* binding */ GpuReadBuffer)
/* harmony export */ });
/* harmony import */ var _shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");



"use strict";
function GpuReadBuffer(buffer, renderer) {
  const bufferSize = buffer.descriptor.size;
  const device = renderer.gpu.device;
  const stagingBuffer = new _shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.Buffer({
    data: new Float32Array(24e5),
    usage: _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.MAP_READ | _shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.COPY_DST
  });
  const stagingGPUBuffer = renderer.buffer.createGPUBuffer(stagingBuffer);
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyBufferToBuffer(
    renderer.buffer.getGPUBuffer(buffer),
    0,
    // Source offset
    stagingGPUBuffer,
    0,
    // Destination offset
    bufferSize
  );
  device.queue.submit([commandEncoder.finish()]);
  void stagingGPUBuffer.mapAsync(
    GPUMapMode.READ,
    0,
    // Offset
    bufferSize
    // Length
  ).then(() => {
    stagingGPUBuffer.getMappedRange(0, bufferSize);
    stagingGPUBuffer.unmap();
  });
}


//# sourceMappingURL=GpuReadBuffer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UboBatch: () => (/* binding */ UboBatch)
/* harmony export */ });

class UboBatch {
  constructor({ minUniformOffsetAlignment }) {
    this._minUniformOffsetAlignment = 256;
    this.byteIndex = 0;
    this._minUniformOffsetAlignment = minUniformOffsetAlignment;
    this.data = new Float32Array(65535);
  }
  clear() {
    this.byteIndex = 0;
  }
  addEmptyGroup(size) {
    if (size > this._minUniformOffsetAlignment / 4) {
      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
    }
    const start = this.byteIndex;
    let newSize = start + size * 4;
    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
    if (newSize > this.data.length * 4) {
      throw new Error("UniformBufferBatch: ubo batch got too big");
    }
    this.byteIndex = newSize;
    return start;
  }
  addGroup(array) {
    const offset = this.addEmptyGroup(array.length);
    for (let i = 0; i < array.length; i++) {
      this.data[offset / 4 + i] = array[i];
    }
    return offset;
  }
  destroy() {
    this.data = null;
  }
}


//# sourceMappingURL=UboBatch.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PipelineSystem: () => (/* binding */ PipelineSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _gl_shader_program_ensureAttributes_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../gl/shader/program/ensureAttributes.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs");
/* harmony import */ var _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/state/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");
/* harmony import */ var _shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/utils/createIdFromString.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs");
/* harmony import */ var _state_GpuStencilModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../state/GpuStencilModesToPixi.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs");







"use strict";
const topologyStringToId = {
  "point-list": 0,
  "line-list": 1,
  "line-strip": 2,
  "triangle-list": 3,
  "triangle-strip": 4
};
function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
}
function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
}
class PipelineSystem {
  constructor(renderer) {
    this._moduleCache = /* @__PURE__ */ Object.create(null);
    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
    this._pipeCache = /* @__PURE__ */ Object.create(null);
    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
    this._colorMask = 15;
    this._multisampleCount = 1;
    this._renderer = renderer;
  }
  contextChange(gpu) {
    this._gpu = gpu;
    this.setStencilMode(_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.DISABLED);
    this._updatePipeHash();
  }
  setMultisampleCount(multisampleCount) {
    if (this._multisampleCount === multisampleCount)
      return;
    this._multisampleCount = multisampleCount;
    this._updatePipeHash();
  }
  setRenderTarget(renderTarget) {
    this._multisampleCount = renderTarget.msaaSamples;
    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
    this._updatePipeHash();
  }
  setColorMask(colorMask) {
    if (this._colorMask === colorMask)
      return;
    this._colorMask = colorMask;
    this._updatePipeHash();
  }
  setStencilMode(stencilMode) {
    if (this._stencilMode === stencilMode)
      return;
    this._stencilMode = stencilMode;
    this._stencilState = _state_GpuStencilModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuStencilModesToPixi[stencilMode];
    this._updatePipeHash();
  }
  setPipeline(geometry, program, state, passEncoder) {
    const pipeline = this.getPipeline(geometry, program, state);
    passEncoder.setPipeline(pipeline);
  }
  getPipeline(geometry, program, state, topology) {
    if (!geometry._layoutKey) {
      (0,_gl_shader_program_ensureAttributes_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureAttributes)(geometry, program.attributeData);
      this._generateBufferKey(geometry);
    }
    topology || (topology = geometry.topology);
    const key = getGraphicsStateKey(
      geometry._layoutKey,
      program._layoutKey,
      state.data,
      state._blendModeId,
      topologyStringToId[topology]
    );
    if (this._pipeCache[key])
      return this._pipeCache[key];
    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
    return this._pipeCache[key];
  }
  _createPipeline(geometry, program, state, topology) {
    const device = this._gpu.device;
    const buffers = this._createVertexBufferLayouts(geometry, program);
    const blendModes = this._renderer.state.getColorTargets(state);
    blendModes[0].writeMask = this._stencilMode === _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
    const layout = this._renderer.shader.getProgramData(program).pipeline;
    const descriptor = {
      // TODO later check if its helpful to create..
      // layout,
      vertex: {
        module: this._getModule(program.vertex.source),
        entryPoint: program.vertex.entryPoint,
        // geometry..
        buffers
      },
      fragment: {
        module: this._getModule(program.fragment.source),
        entryPoint: program.fragment.entryPoint,
        targets: blendModes
      },
      primitive: {
        topology,
        cullMode: state.cullMode
      },
      layout,
      multisample: {
        count: this._multisampleCount
      },
      // depthStencil,
      label: `PIXI Pipeline`
    };
    if (this._depthStencilAttachment) {
      descriptor.depthStencil = {
        ...this._stencilState,
        format: "depth24plus-stencil8",
        depthWriteEnabled: state.depthTest,
        depthCompare: state.depthTest ? "less" : "always"
      };
    }
    const pipeline = device.createRenderPipeline(descriptor);
    return pipeline;
  }
  _getModule(code) {
    return this._moduleCache[code] || this._createModule(code);
  }
  _createModule(code) {
    const device = this._gpu.device;
    this._moduleCache[code] = device.createShaderModule({
      code
    });
    return this._moduleCache[code];
  }
  _generateBufferKey(geometry) {
    const keyGen = [];
    let index = 0;
    const attributeKeys = Object.keys(geometry.attributes).sort();
    for (let i = 0; i < attributeKeys.length; i++) {
      const attribute = geometry.attributes[attributeKeys[i]];
      keyGen[index++] = attribute.offset;
      keyGen[index++] = attribute.format;
      keyGen[index++] = attribute.stride;
      keyGen[index++] = attribute.instance;
    }
    const stringKey = keyGen.join("|");
    geometry._layoutKey = (0,_shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_3__.createIdFromString)(stringKey, "geometry");
    return geometry._layoutKey;
  }
  _generateAttributeLocationsKey(program) {
    const keyGen = [];
    let index = 0;
    const attributeKeys = Object.keys(program.attributeData).sort();
    for (let i = 0; i < attributeKeys.length; i++) {
      const attribute = program.attributeData[attributeKeys[i]];
      keyGen[index++] = attribute.location;
    }
    const stringKey = keyGen.join("|");
    program._attributeLocationsKey = (0,_shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_3__.createIdFromString)(stringKey, "programAttributes");
    return program._attributeLocationsKey;
  }
  /**
   * Returns a hash of buffer names mapped to bind locations.
   * This is used to bind the correct buffer to the correct location in the shader.
   * @param geometry - The geometry where to get the buffer names
   * @param program - The program where to get the buffer names
   * @returns An object of buffer names mapped to the bind location.
   */
  getBufferNamesToBind(geometry, program) {
    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
    if (this._bindingNamesCache[key])
      return this._bindingNamesCache[key];
    const data = this._createVertexBufferLayouts(geometry, program);
    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
    const attributeData = program.attributeData;
    for (let i = 0; i < data.length; i++) {
      const attributes = Object.values(data[i].attributes);
      const shaderLocation = attributes[0].shaderLocation;
      for (const j in attributeData) {
        if (attributeData[j].location === shaderLocation) {
          bufferNamesToBind[i] = j;
          break;
        }
      }
    }
    this._bindingNamesCache[key] = bufferNamesToBind;
    return bufferNamesToBind;
  }
  _createVertexBufferLayouts(geometry, program) {
    if (!program._attributeLocationsKey)
      this._generateAttributeLocationsKey(program);
    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
    if (this._bufferLayoutsCache[key]) {
      return this._bufferLayoutsCache[key];
    }
    const vertexBuffersLayout = [];
    geometry.buffers.forEach((buffer) => {
      const bufferEntry = {
        arrayStride: 0,
        stepMode: "vertex",
        attributes: []
      };
      const bufferEntryAttributes = bufferEntry.attributes;
      for (const i in program.attributeData) {
        const attribute = geometry.attributes[i];
        if ((attribute.divisor ?? 1) !== 1) {
          (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__.warn)(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
        }
        if (attribute.buffer === buffer) {
          bufferEntry.arrayStride = attribute.stride;
          bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
          bufferEntryAttributes.push({
            shaderLocation: program.attributeData[i].location,
            offset: attribute.offset,
            format: attribute.format
          });
        }
      }
      if (bufferEntryAttributes.length) {
        vertexBuffersLayout.push(bufferEntry);
      }
    });
    this._bufferLayoutsCache[key] = vertexBuffersLayout;
    return vertexBuffersLayout;
  }
  _updatePipeHash() {
    const key = getGlobalStateKey(
      this._stencilMode,
      this._multisampleCount,
      this._colorMask,
      this._depthStencilAttachment
    );
    if (!this._pipeStateCaches[key]) {
      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
    }
    this._pipeCache = this._pipeStateCaches[key];
  }
  destroy() {
    this._renderer = null;
    this._bufferLayoutsCache = null;
  }
}
/** @ignore */
PipelineSystem.extension = {
  type: [_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__.ExtensionType.WebGPUSystem],
  name: "pipeline"
};


//# sourceMappingURL=PipelineSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuRenderTarget: () => (/* binding */ GpuRenderTarget)
/* harmony export */ });

class GpuRenderTarget {
  constructor() {
    this.contexts = [];
    this.msaaTextures = [];
    this.msaaSamples = 1;
  }
}


//# sourceMappingURL=GpuRenderTarget.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuRenderTargetAdaptor: () => (/* binding */ GpuRenderTargetAdaptor)
/* harmony export */ });
/* harmony import */ var _gl_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../gl/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs");
/* harmony import */ var _shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/texture/sources/CanvasSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs");
/* harmony import */ var _shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _GpuRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GpuRenderTarget.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs");





"use strict";
class GpuRenderTargetAdaptor {
  init(renderer, renderTargetSystem) {
    this._renderer = renderer;
    this._renderTargetSystem = renderTargetSystem;
  }
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    const renderer = this._renderer;
    const baseGpuTexture = this._getGpuColorTexture(
      sourceRenderSurfaceTexture
    );
    const backGpuTexture = renderer.texture.getGpuSource(
      destinationTexture.source
    );
    renderer.encoder.commandEncoder.copyTextureToTexture(
      {
        texture: baseGpuTexture,
        origin: originSrc
      },
      {
        texture: backGpuTexture,
        origin: originDest
      },
      size
    );
    return destinationTexture;
  }
  startRenderPass(renderTarget, clear = true, clearColor, viewport) {
    const renderTargetSystem = this._renderTargetSystem;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
    gpuRenderTarget.descriptor = descriptor;
    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
    this._renderer.encoder.beginRenderPass(gpuRenderTarget);
    this._renderer.encoder.setViewport(viewport);
  }
  finishRenderPass() {
    this._renderer.encoder.endRenderPass();
  }
  /**
   * returns the gpu texture for the first color texture in the render target
   * mainly used by the filter manager to get copy the texture for blending
   * @param renderTarget
   * @returns a gpu texture
   */
  _getGpuColorTexture(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (gpuRenderTarget.contexts[0]) {
      return gpuRenderTarget.contexts[0].getCurrentTexture();
    }
    return this._renderer.texture.getGpuSource(
      renderTarget.colorTextures[0].source
    );
  }
  getDescriptor(renderTarget, clear, clearValue) {
    if (typeof clear === "boolean") {
      clear = clear ? _gl_const_mjs__WEBPACK_IMPORTED_MODULE_0__.CLEAR.ALL : _gl_const_mjs__WEBPACK_IMPORTED_MODULE_0__.CLEAR.NONE;
    }
    const renderTargetSystem = this._renderTargetSystem;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    const colorAttachments = renderTarget.colorTextures.map(
      (texture, i) => {
        const context = gpuRenderTarget.contexts[i];
        let view;
        let resolveTarget;
        if (context) {
          const currentTexture = context.getCurrentTexture();
          const canvasTextureView = currentTexture.createView();
          view = canvasTextureView;
        } else {
          view = this._renderer.texture.getGpuSource(texture).createView({
            mipLevelCount: 1
          });
        }
        if (gpuRenderTarget.msaaTextures[i]) {
          resolveTarget = view;
          view = this._renderer.texture.getTextureView(
            gpuRenderTarget.msaaTextures[i]
          );
        }
        const loadOp = clear & _gl_const_mjs__WEBPACK_IMPORTED_MODULE_0__.CLEAR.COLOR ? "clear" : "load";
        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
        return {
          view,
          resolveTarget,
          clearValue,
          storeOp: "store",
          loadOp
        };
      }
    );
    let depthStencilAttachment;
    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
      renderTarget.ensureDepthStencilTexture();
      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
    }
    if (renderTarget.depthStencilTexture) {
      const stencilLoadOp = clear & _gl_const_mjs__WEBPACK_IMPORTED_MODULE_0__.CLEAR.STENCIL ? "clear" : "load";
      const depthLoadOp = clear & _gl_const_mjs__WEBPACK_IMPORTED_MODULE_0__.CLEAR.DEPTH ? "clear" : "load";
      depthStencilAttachment = {
        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
        stencilStoreOp: "store",
        stencilLoadOp,
        depthClearValue: 1,
        depthLoadOp,
        depthStoreOp: "store"
      };
    }
    const descriptor = {
      colorAttachments,
      depthStencilAttachment
    };
    return descriptor;
  }
  clear(renderTarget, clear = true, clearColor, viewport) {
    if (!clear)
      return;
    const { gpu, encoder } = this._renderer;
    const device = gpu.device;
    const standAlone = encoder.commandEncoder === null;
    if (standAlone) {
      const commandEncoder = device.createCommandEncoder();
      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      passEncoder.end();
      const gpuCommands = commandEncoder.finish();
      device.queue.submit([gpuCommands]);
    } else {
      this.startRenderPass(renderTarget, clear, clearColor, viewport);
    }
  }
  initGpuRenderTarget(renderTarget) {
    renderTarget.isRoot = true;
    const gpuRenderTarget = new _GpuRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuRenderTarget();
    renderTarget.colorTextures.forEach((colorTexture, i) => {
      if (_shared_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasSource.test(colorTexture.resource)) {
        const context = colorTexture.resource.getContext(
          "webgpu"
        );
        const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
        try {
          context.configure({
            device: this._renderer.gpu.device,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            format: "bgra8unorm",
            alphaMode
          });
        } catch (e) {
          console.error(e);
        }
        gpuRenderTarget.contexts[i] = context;
      }
      gpuRenderTarget.msaa = colorTexture.source.antialias;
      if (colorTexture.source.antialias) {
        const msaaTexture = new _shared_texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__.TextureSource({
          width: 0,
          height: 0,
          sampleCount: 4
        });
        gpuRenderTarget.msaaTextures[i] = msaaTexture;
      }
    });
    if (gpuRenderTarget.msaa) {
      gpuRenderTarget.msaaSamples = 4;
      if (renderTarget.depthStencilTexture) {
        renderTarget.depthStencilTexture.source.sampleCount = 4;
      }
    }
    return gpuRenderTarget;
  }
  destroyGpuRenderTarget(gpuRenderTarget) {
    gpuRenderTarget.contexts.forEach((context) => {
      context.unconfigure();
    });
    gpuRenderTarget.msaaTextures.forEach((texture) => {
      texture.destroy();
    });
    gpuRenderTarget.msaaTextures.length = 0;
    gpuRenderTarget.contexts.length = 0;
  }
  ensureDepthStencilTexture(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
      renderTarget.depthStencilTexture.source.sampleCount = 4;
    }
  }
  resizeGpuRenderTarget(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    gpuRenderTarget.width = renderTarget.width;
    gpuRenderTarget.height = renderTarget.height;
    if (gpuRenderTarget.msaa) {
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        const msaaTexture = gpuRenderTarget.msaaTextures[i];
        msaaTexture?.resize(
          colorTexture.source.width,
          colorTexture.source.height,
          colorTexture.source._resolution
        );
      });
    }
  }
}


//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuRenderTargetSystem: () => (/* binding */ GpuRenderTargetSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_renderTarget_RenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/renderTarget/RenderTargetSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs");
/* harmony import */ var _GpuRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GpuRenderTargetAdaptor.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs");




"use strict";
class GpuRenderTargetSystem extends _shared_renderTarget_RenderTargetSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.RenderTargetSystem {
  constructor(renderer) {
    super(renderer);
    this.adaptor = new _GpuRenderTargetAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuRenderTargetAdaptor();
    this.adaptor.init(renderer, this);
  }
}
/** @ignore */
GpuRenderTargetSystem.extension = {
  type: [_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUSystem],
  name: "renderTarget"
};


//# sourceMappingURL=GpuRenderTargetSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateProjection: () => (/* binding */ calculateProjection)
/* harmony export */ });

function calculateProjection(pm, x, y, width, height, flipY) {
  const sign = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign * (1 / height * 2);
  pm.tx = -1 - x * pm.a;
  pm.ty = -sign - y * pm.d;
  return pm;
}


//# sourceMappingURL=calculateProjection.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BindGroup: () => (/* binding */ BindGroup)
/* harmony export */ });

class BindGroup {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(resources) {
    /** The resources that are bound together for use by a shader. */
    this.resources = /* @__PURE__ */ Object.create(null);
    this._dirty = true;
    let index = 0;
    for (const i in resources) {
      const resource = resources[i];
      this.setResource(resource, index++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   * @ignore
   */
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = false;
    const keyParts = [];
    let index = 0;
    for (const i in this.resources) {
      keyParts[index++] = this.resources[i]._resourceId;
    }
    this._key = keyParts.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(resource, index) {
    const currentResource = this.resources[index];
    if (resource === currentResource)
      return;
    if (currentResource) {
      resource.off?.("change", this.onResourceChange, this);
    }
    resource.on?.("change", this.onResourceChange, this);
    this.resources[index] = resource;
    this._dirty = true;
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(index) {
    return this.resources[index];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param tick - The current tick.
   * @internal
   * @ignore
   */
  _touch(tick) {
    const resources = this.resources;
    for (const i in resources) {
      resources[i]._touched = tick;
    }
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    const resources = this.resources;
    for (const i in resources) {
      const resource = resources[i];
      resource.off?.("change", this.onResourceChange, this);
    }
    this.resources = null;
  }
  onResourceChange(resource) {
    this._dirty = true;
    if (resource.destroyed) {
      const resources = this.resources;
      for (const i in resources) {
        if (resources[i] === resource) {
          resources[i] = null;
        }
      }
    } else {
      this._updateKey();
    }
  }
}


//# sourceMappingURL=BindGroup.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuProgram: () => (/* binding */ GpuProgram)
/* harmony export */ });
/* harmony import */ var _shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../shared/utils/createIdFromString.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs");
/* harmony import */ var _utils_extractAttributesFromGpuProgram_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/extractAttributesFromGpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs");
/* harmony import */ var _utils_extractStructAndGroups_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/extractStructAndGroups.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs");
/* harmony import */ var _utils_generateGpuLayoutGroups_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/generateGpuLayoutGroups.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs");
/* harmony import */ var _utils_generateLayoutHash_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/generateLayoutHash.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs");
/* harmony import */ var _utils_removeStructAndGroupDuplicates_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/removeStructAndGroupDuplicates.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs");







"use strict";
const programCache = /* @__PURE__ */ Object.create(null);
class GpuProgram {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(options) {
    /**
     * @internal
     * @ignore
     */
    this._layoutKey = 0;
    /**
     * @internal
     * @ignore
     */
    this._attributeLocationsKey = 0;
    const { fragment, vertex, layout, gpuLayout, name } = options;
    this.name = name;
    this.fragment = fragment;
    this.vertex = vertex;
    if (fragment.source === vertex.source) {
      const structsAndGroups = (0,_utils_extractStructAndGroups_mjs__WEBPACK_IMPORTED_MODULE_0__.extractStructAndGroups)(fragment.source);
      this.structsAndGroups = structsAndGroups;
    } else {
      const vertexStructsAndGroups = (0,_utils_extractStructAndGroups_mjs__WEBPACK_IMPORTED_MODULE_0__.extractStructAndGroups)(vertex.source);
      const fragmentStructsAndGroups = (0,_utils_extractStructAndGroups_mjs__WEBPACK_IMPORTED_MODULE_0__.extractStructAndGroups)(fragment.source);
      this.structsAndGroups = (0,_utils_removeStructAndGroupDuplicates_mjs__WEBPACK_IMPORTED_MODULE_1__.removeStructAndGroupDuplicates)(vertexStructsAndGroups, fragmentStructsAndGroups);
    }
    this.layout = layout ?? (0,_utils_generateLayoutHash_mjs__WEBPACK_IMPORTED_MODULE_2__.generateLayoutHash)(this.structsAndGroups);
    this.gpuLayout = gpuLayout ?? (0,_utils_generateGpuLayoutGroups_mjs__WEBPACK_IMPORTED_MODULE_3__.generateGpuLayoutGroups)(this.structsAndGroups);
    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
    this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex, fragment } = this;
    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;
    this._layoutKey = (0,_shared_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_4__.createIdFromString)(bigKey, "program");
  }
  get attributeData() {
    this._attributeData ?? (this._attributeData = (0,_utils_extractAttributesFromGpuProgram_mjs__WEBPACK_IMPORTED_MODULE_5__.extractAttributesFromGpuProgram)(this.vertex));
    return this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null;
    this.layout = null;
    this.structsAndGroups = null;
    this.fragment = null;
    this.vertex = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(options) {
    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
    if (!programCache[key]) {
      programCache[key] = new GpuProgram(options);
    }
    return programCache[key];
  }
}


//# sourceMappingURL=GpuProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuShaderSystem: () => (/* binding */ GpuShaderSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class GpuShaderSystem {
  constructor() {
    this._gpuProgramData = /* @__PURE__ */ Object.create(null);
  }
  contextChange(gpu) {
    this._gpu = gpu;
    this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;
  }
  getProgramData(program) {
    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
  }
  _createGPUProgramData(program) {
    const device = this._gpu.device;
    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
    this._gpuProgramData[program._layoutKey] = {
      bindGroups,
      pipeline: device.createPipelineLayout(pipelineLayoutDesc)
    };
    return this._gpuProgramData[program._layoutKey];
  }
  destroy() {
    this._gpu = null;
    this._gpuProgramData = null;
  }
}
/** @ignore */
GpuShaderSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUSystem
  ],
  name: "shader"
};


//# sourceMappingURL=GpuShaderSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WGSL_ALIGN_SIZE_DATA: () => (/* binding */ WGSL_ALIGN_SIZE_DATA),
/* harmony export */   createUboElementsWGSL: () => (/* binding */ createUboElementsWGSL)
/* harmony export */ });

const WGSL_ALIGN_SIZE_DATA = {
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  f16: { align: 2, size: 2 },
  "vec2<i32>": { align: 8, size: 8 },
  "vec2<u32>": { align: 8, size: 8 },
  "vec2<f32>": { align: 8, size: 8 },
  "vec2<f16>": { align: 4, size: 4 },
  "vec3<i32>": { align: 16, size: 12 },
  "vec3<u32>": { align: 16, size: 12 },
  "vec3<f32>": { align: 16, size: 12 },
  "vec3<f16>": { align: 8, size: 6 },
  "vec4<i32>": { align: 16, size: 16 },
  "vec4<u32>": { align: 16, size: 16 },
  "vec4<f32>": { align: 16, size: 16 },
  "vec4<f16>": { align: 8, size: 8 },
  "mat2x2<f32>": { align: 8, size: 16 },
  "mat2x2<f16>": { align: 4, size: 8 },
  "mat3x2<f32>": { align: 8, size: 24 },
  "mat3x2<f16>": { align: 4, size: 12 },
  "mat4x2<f32>": { align: 8, size: 32 },
  "mat4x2<f16>": { align: 4, size: 16 },
  "mat2x3<f32>": { align: 16, size: 32 },
  "mat2x3<f16>": { align: 8, size: 16 },
  "mat3x3<f32>": { align: 16, size: 48 },
  "mat3x3<f16>": { align: 8, size: 24 },
  "mat4x3<f32>": { align: 16, size: 64 },
  "mat4x3<f16>": { align: 8, size: 32 },
  "mat2x4<f32>": { align: 16, size: 32 },
  "mat2x4<f16>": { align: 8, size: 16 },
  "mat3x4<f32>": { align: 16, size: 48 },
  "mat3x4<f16>": { align: 8, size: 24 },
  "mat4x4<f32>": { align: 16, size: 64 },
  "mat4x4<f16>": { align: 8, size: 32 }
};
function createUboElementsWGSL(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, align) * uboElement.data.size;
    }
    offset = Math.ceil(offset / align) * align;
    uboElement.size = size;
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}


//# sourceMappingURL=createUboElementsWGSL.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUboSyncFunctionWGSL: () => (/* binding */ createUboSyncFunctionWGSL)
/* harmony export */ });
/* harmony import */ var _shared_shader_utils_createUboSyncFunction_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/shader/utils/createUboSyncFunction.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs");
/* harmony import */ var _shared_shader_utils_uboSyncFunctions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/shader/utils/uboSyncFunctions.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs");
/* harmony import */ var _generateArraySyncWGSL_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateArraySyncWGSL.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs");




"use strict";
function createUboSyncFunctionWGSL(uboElements) {
  return (0,_shared_shader_utils_createUboSyncFunction_mjs__WEBPACK_IMPORTED_MODULE_0__.createUboSyncFunction)(
    uboElements,
    "uboWgsl",
    _generateArraySyncWGSL_mjs__WEBPACK_IMPORTED_MODULE_1__.generateArraySyncWGSL,
    _shared_shader_utils_uboSyncFunctions_mjs__WEBPACK_IMPORTED_MODULE_2__.uboSyncFunctionsWGSL
  );
}


//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractAttributesFromGpuProgram: () => (/* binding */ extractAttributesFromGpuProgram)
/* harmony export */ });
/* harmony import */ var _shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");


"use strict";
const WGSL_TO_VERTEX_TYPES = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
function extractAttributesFromGpuProgram({ source, entryPoint }) {
  const results = {};
  const mainVertStart = source.indexOf(`fn ${entryPoint}`);
  if (mainVertStart !== -1) {
    const arrowFunctionStart = source.indexOf("->", mainVertStart);
    if (arrowFunctionStart !== -1) {
      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);
      const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let match;
      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
        results[match[2]] = {
          location: parseInt(match[1], 10),
          format,
          stride: (0,_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_0__.getAttributeInfoFromFormat)(format).stride,
          offset: 0,
          instance: false,
          start: 0
        };
      }
    }
  }
  return results;
}


//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractStructAndGroups: () => (/* binding */ extractStructAndGroups)
/* harmony export */ });

function extractStructAndGroups(wgsl) {
  const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type] = member.split(":");
      acc[name2.trim()] = type.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}


//# sourceMappingURL=extractStructAndGroups.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateArraySyncWGSL: () => (/* binding */ generateArraySyncWGSL)
/* harmony export */ });
/* harmony import */ var _createUboElementsWGSL_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createUboElementsWGSL.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs");


"use strict";
function generateArraySyncWGSL(uboElement, offsetToAdd) {
  const { size, align } = _createUboElementsWGSL_mjs__WEBPACK_IMPORTED_MODULE_0__.WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
  const remainder = (align - size) / 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
}


//# sourceMappingURL=generateArraySyncWGSL.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateGpuLayoutGroups: () => (/* binding */ generateGpuLayoutGroups)
/* harmony export */ });
/* harmony import */ var _shared_shader_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/shader/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs");


"use strict";
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: _shared_shader_const_mjs__WEBPACK_IMPORTED_MODULE_0__.ShaderStage.VERTEX | _shared_shader_const_mjs__WEBPACK_IMPORTED_MODULE_0__.ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: _shared_shader_const_mjs__WEBPACK_IMPORTED_MODULE_0__.ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: _shared_shader_const_mjs__WEBPACK_IMPORTED_MODULE_0__.ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}


//# sourceMappingURL=generateGpuLayoutGroups.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateLayoutHash: () => (/* binding */ generateLayoutHash)
/* harmony export */ });

function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}


//# sourceMappingURL=generateLayoutHash.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeStructAndGroupDuplicates: () => (/* binding */ removeStructAndGroupDuplicates)
/* harmony export */ });

function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  });
  return { structs, groups };
}


//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuBlendModesToPixi: () => (/* binding */ GpuBlendModesToPixi)
/* harmony export */ });

const GpuBlendModesToPixi = {};
GpuBlendModesToPixi.normal = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
GpuBlendModesToPixi.add = {
  alpha: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  }
};
GpuBlendModesToPixi.multiply = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "dst",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
GpuBlendModesToPixi.screen = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.overlay = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.none = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "zero",
    operation: "add"
  }
};
GpuBlendModesToPixi["normal-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
GpuBlendModesToPixi["add-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one",
    operation: "add"
  }
};
GpuBlendModesToPixi["screen-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.erase = {
  alpha: {
    srcFactor: "zero",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.min = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  }
};
GpuBlendModesToPixi.max = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  }
};


//# sourceMappingURL=GpuBlendModesToPixi.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuStateSystem: () => (/* binding */ GpuStateSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _GpuBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GpuBlendModesToPixi.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs");




"use strict";
class GpuStateSystem {
  constructor() {
    this.defaultState = new _shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State();
    this.defaultState.blend = true;
  }
  contextChange(gpu) {
    this.gpu = gpu;
  }
  /**
   * Gets the blend mode data for the current state
   * @param state - The state to get the blend mode from
   */
  getColorTargets(state) {
    const blend = _GpuBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuBlendModesToPixi[state.blendMode] || _GpuBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuBlendModesToPixi.normal;
    return [
      {
        format: "bgra8unorm",
        writeMask: 0,
        blend
      }
    ];
  }
  destroy() {
    this.gpu = null;
  }
}
/** @ignore */
GpuStateSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUSystem
  ],
  name: "state"
};


//# sourceMappingURL=GpuStateSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuStencilModesToPixi: () => (/* binding */ GpuStencilModesToPixi)
/* harmony export */ });
/* harmony import */ var _shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/state/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");


"use strict";
const GpuStencilModesToPixi = [];
GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.NONE] = void 0;
GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.DISABLED] = {
  stencilWriteMask: 0,
  stencilReadMask: 0
};
GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.RENDERING_MASK_ADD] = {
  stencilFront: {
    compare: "equal",
    passOp: "increment-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "increment-clamp"
  }
};
GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.RENDERING_MASK_REMOVE] = {
  stencilFront: {
    compare: "equal",
    passOp: "decrement-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "decrement-clamp"
  }
};
GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "equal",
    passOp: "keep"
  },
  stencilBack: {
    compare: "equal",
    passOp: "keep"
  }
};
GpuStencilModesToPixi[_shared_state_const_mjs__WEBPACK_IMPORTED_MODULE_0__.STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "not-equal",
    passOp: "replace"
  },
  stencilBack: {
    compare: "not-equal",
    passOp: "replace"
  }
};


//# sourceMappingURL=GpuStencilModesToPixi.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuTextureSystem: () => (/* binding */ GpuTextureSystem)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../shared/texture/CanvasPool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");
/* harmony import */ var _shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");
/* harmony import */ var _uploaders_gpuUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uploaders/gpuUploadBufferImageResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs");
/* harmony import */ var _uploaders_gpuUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uploaders/gpuUploadCompressedTextureResource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs");
/* harmony import */ var _uploaders_gpuUploadImageSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uploaders/gpuUploadImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs");
/* harmony import */ var _uploaders_gpuUploadVideoSource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./uploaders/gpuUploadVideoSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs");
/* harmony import */ var _utils_GpuMipmapGenerator_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/GpuMipmapGenerator.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs");











"use strict";
class GpuTextureSystem {
  constructor(renderer) {
    this.managedTextures = [];
    this._gpuSources = /* @__PURE__ */ Object.create(null);
    this._gpuSamplers = /* @__PURE__ */ Object.create(null);
    this._bindGroupHash = /* @__PURE__ */ Object.create(null);
    this._textureViewHash = /* @__PURE__ */ Object.create(null);
    this._uploads = {
      image: _uploaders_gpuUploadImageSource_mjs__WEBPACK_IMPORTED_MODULE_0__.gpuUploadImageResource,
      buffer: _uploaders_gpuUploadBufferImageResource_mjs__WEBPACK_IMPORTED_MODULE_1__.gpuUploadBufferImageResource,
      video: _uploaders_gpuUploadVideoSource_mjs__WEBPACK_IMPORTED_MODULE_2__.gpuUploadVideoResource,
      compressed: _uploaders_gpuUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_3__.gpuUploadCompressedTextureResource
    };
    this._renderer = renderer;
    renderer.renderableGC.addManagedHash(this, "_gpuSources");
    renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
    renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
    renderer.renderableGC.addManagedHash(this, "_textureViewHash");
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  initSource(source) {
    if (source.autoGenerateMipmaps) {
      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);
      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
    }
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    if (source.uploadMethodId !== "compressed") {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
      usage |= GPUTextureUsage.COPY_SRC;
    }
    const blockData = _uploaders_gpuUploadCompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_3__.blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
    const textureDescriptor = {
      label: source.label,
      size: { width, height },
      format: source.format,
      sampleCount: source.sampleCount,
      mipLevelCount: source.mipLevelCount,
      dimension: source.dimension,
      usage
    };
    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
    this._gpuSources[source.uid] = gpuTexture;
    if (!this.managedTextures.includes(source)) {
      source.on("update", this.onSourceUpdate, this);
      source.on("resize", this.onSourceResize, this);
      source.on("destroy", this.onSourceDestroy, this);
      source.on("unload", this.onSourceUnload, this);
      source.on("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.push(source);
    }
    this.onSourceUpdate(source);
    return gpuTexture;
  }
  onSourceUpdate(source) {
    const gpuTexture = this.getGpuSource(source);
    if (!gpuTexture)
      return;
    if (this._uploads[source.uploadMethodId]) {
      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);
    }
    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {
      this.onUpdateMipmaps(source);
    }
  }
  onSourceUnload(source) {
    const gpuTexture = this._gpuSources[source.uid];
    if (gpuTexture) {
      this._gpuSources[source.uid] = null;
      gpuTexture.destroy();
    }
  }
  onUpdateMipmaps(source) {
    if (!this._mipmapGenerator) {
      this._mipmapGenerator = new _utils_GpuMipmapGenerator_mjs__WEBPACK_IMPORTED_MODULE_4__.GpuMipmapGenerator(this._gpu.device);
    }
    const gpuTexture = this.getGpuSource(source);
    this._mipmapGenerator.generateMipmap(gpuTexture);
  }
  onSourceDestroy(source) {
    source.off("update", this.onSourceUpdate, this);
    source.off("unload", this.onSourceUnload, this);
    source.off("destroy", this.onSourceDestroy, this);
    source.off("resize", this.onSourceResize, this);
    source.off("updateMipmaps", this.onUpdateMipmaps, this);
    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);
    this.onSourceUnload(source);
  }
  onSourceResize(source) {
    const gpuTexture = this._gpuSources[source.uid];
    if (!gpuTexture) {
      this.initSource(source);
    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {
      this._textureViewHash[source.uid] = null;
      this._bindGroupHash[source.uid] = null;
      this.onSourceUnload(source);
      this.initSource(source);
    }
  }
  _initSampler(sampler) {
    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
    return this._gpuSamplers[sampler._resourceId];
  }
  getGpuSampler(sampler) {
    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
  }
  getGpuSource(source) {
    return this._gpuSources[source.uid] || this.initSource(source);
  }
  /**
   * this returns s bind group for a specific texture, the bind group contains
   * - the texture source
   * - the texture style
   * - the texture matrix
   * This is cached so the bind group should only be created once per texture
   * @param texture - the texture you want the bindgroup for
   * @returns the bind group for the texture
   */
  getTextureBindGroup(texture) {
    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
  }
  _createTextureBindGroup(texture) {
    const source = texture.source;
    this._bindGroupHash[texture.uid] = new _shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.BindGroup({
      0: source,
      1: source.style,
      2: new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_6__.UniformGroup({
        uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
      })
    });
    return this._bindGroupHash[texture.uid];
  }
  getTextureView(texture) {
    const source = texture.source;
    return this._textureViewHash[source.uid] ?? this._createTextureView(source);
  }
  _createTextureView(texture) {
    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
    return this._textureViewHash[texture.uid];
  }
  generateCanvas(texture) {
    const renderer = this._renderer;
    const commandEncoder = renderer.gpu.device.createCommandEncoder();
    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_7__.DOMAdapter.get().createCanvas();
    canvas.width = texture.source.pixelWidth;
    canvas.height = texture.source.pixelHeight;
    const context = canvas.getContext("webgpu");
    context.configure({
      device: renderer.gpu.device,
      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
      format: _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_7__.DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
      alphaMode: "premultiplied"
    });
    commandEncoder.copyTextureToTexture({
      texture: renderer.texture.getGpuSource(texture.source),
      origin: {
        x: 0,
        y: 0
      }
    }, {
      texture: context.getCurrentTexture()
    }, {
      width: canvas.width,
      height: canvas.height
    });
    renderer.gpu.device.queue.submit([commandEncoder.finish()]);
    return canvas;
  }
  getPixels(texture) {
    const webGPUCanvas = this.generateCanvas(texture);
    const canvasAndContext = _shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_8__.CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
    const context = canvasAndContext.context;
    context.drawImage(webGPUCanvas, 0, 0);
    const { width, height } = webGPUCanvas;
    const imageData = context.getImageData(0, 0, width, height);
    const pixels = new Uint8ClampedArray(imageData.data.buffer);
    _shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_8__.CanvasPool.returnCanvasAndContext(canvasAndContext);
    return { pixels, width, height };
  }
  destroy() {
    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));
    this.managedTextures = null;
    for (const k of Object.keys(this._bindGroupHash)) {
      const key = Number(k);
      const bindGroup = this._bindGroupHash[key];
      bindGroup?.destroy();
      this._bindGroupHash[key] = null;
    }
    this._gpu = null;
    this._mipmapGenerator = null;
    this._gpuSources = null;
    this._bindGroupHash = null;
    this._textureViewHash = null;
    this._gpuSamplers = null;
  }
}
/** @ignore */
GpuTextureSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_9__.ExtensionType.WebGPUSystem
  ],
  name: "texture"
};


//# sourceMappingURL=GpuTextureSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gpuUploadBufferImageResource: () => (/* binding */ gpuUploadBufferImageResource)
/* harmony export */ });

const gpuUploadBufferImageResource = {
  type: "image",
  upload(source, gpuTexture, gpu) {
    const resource = source.resource;
    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);
    const bytesPerPixel = resource.byteLength / total;
    gpu.device.queue.writeTexture(
      { texture: gpuTexture },
      resource,
      {
        offset: 0,
        rowsPerImage: source.pixelHeight,
        bytesPerRow: source.pixelHeight * bytesPerPixel
      },
      {
        width: source.pixelWidth,
        height: source.pixelHeight,
        depthOrArrayLayers: 1
      }
    );
  }
};


//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blockDataMap: () => (/* binding */ blockDataMap),
/* harmony export */   gpuUploadCompressedTextureResource: () => (/* binding */ gpuUploadCompressedTextureResource)
/* harmony export */ });

const blockDataMap = {
  "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
};
const defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
const gpuUploadCompressedTextureResource = {
  type: "compressed",
  upload(source, gpuTexture, gpu) {
    let mipWidth = source.pixelWidth;
    let mipHeight = source.pixelHeight;
    const blockData = blockDataMap[source.format] || defaultBlockData;
    for (let i = 0; i < source.resource.length; i++) {
      const levelBuffer = source.resource[i];
      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
      gpu.device.queue.writeTexture(
        {
          texture: gpuTexture,
          mipLevel: i
        },
        levelBuffer,
        {
          offset: 0,
          bytesPerRow
        },
        {
          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
          depthOrArrayLayers: 1
        }
      );
      mipWidth = Math.max(mipWidth >> 1, 1);
      mipHeight = Math.max(mipHeight >> 1, 1);
    }
  }
};


//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gpuUploadImageResource: () => (/* binding */ gpuUploadImageResource)
/* harmony export */ });

const gpuUploadImageResource = {
  type: "image",
  upload(source, gpuTexture, gpu) {
    const resource = source.resource;
    if (!resource)
      return;
    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);
    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);
    const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";
    gpu.device.queue.copyExternalImageToTexture(
      { source: resource },
      { texture: gpuTexture, premultipliedAlpha },
      {
        width,
        height
      }
    );
  }
};


//# sourceMappingURL=gpuUploadImageSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gpuUploadVideoResource: () => (/* binding */ gpuUploadVideoResource)
/* harmony export */ });
/* harmony import */ var _gpuUploadImageSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gpuUploadImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs");


"use strict";
const gpuUploadVideoResource = {
  type: "video",
  upload(source, gpuTexture, gpu) {
    _gpuUploadImageSource_mjs__WEBPACK_IMPORTED_MODULE_0__.gpuUploadImageResource.upload(source, gpuTexture, gpu);
  }
};


//# sourceMappingURL=gpuUploadVideoSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuMipmapGenerator: () => (/* binding */ GpuMipmapGenerator)
/* harmony export */ });

class GpuMipmapGenerator {
  constructor(device) {
    this.device = device;
    this.sampler = device.createSampler({ minFilter: "linear" });
    this.pipelines = {};
  }
  _getMipmapPipeline(format) {
    let pipeline = this.pipelines[format];
    if (!pipeline) {
      if (!this.mipmapShaderModule) {
        this.mipmapShaderModule = this.device.createShaderModule({
          code: (
            /* wgsl */
            `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
          )
        });
      }
      pipeline = this.device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: this.mipmapShaderModule,
          entryPoint: "vertexMain"
        },
        fragment: {
          module: this.mipmapShaderModule,
          entryPoint: "fragmentMain",
          targets: [{ format }]
        }
      });
      this.pipelines[format] = pipeline;
    }
    return pipeline;
  }
  /**
   * Generates mipmaps for the given GPUTexture from the data in level 0.
   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
   * @returns {module:External.GPUTexture} - The originally passed texture
   */
  generateMipmap(texture) {
    const pipeline = this._getMipmapPipeline(texture.format);
    if (texture.dimension === "3d" || texture.dimension === "1d") {
      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
    }
    let mipTexture = texture;
    const arrayLayerCount = texture.depthOrArrayLayers || 1;
    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
    if (!renderToSource) {
      const mipTextureDescriptor = {
        size: {
          width: Math.ceil(texture.width / 2),
          height: Math.ceil(texture.height / 2),
          depthOrArrayLayers: arrayLayerCount
        },
        format: texture.format,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
        mipLevelCount: texture.mipLevelCount - 1
      };
      mipTexture = this.device.createTexture(mipTextureDescriptor);
    }
    const commandEncoder = this.device.createCommandEncoder({});
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
      let srcView = texture.createView({
        baseMipLevel: 0,
        mipLevelCount: 1,
        dimension: "2d",
        baseArrayLayer: arrayLayer,
        arrayLayerCount: 1
      });
      let dstMipLevel = renderToSource ? 1 : 0;
      for (let i = 1; i < texture.mipLevelCount; ++i) {
        const dstView = mipTexture.createView({
          baseMipLevel: dstMipLevel++,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: arrayLayer,
          arrayLayerCount: 1
        });
        const passEncoder = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: dstView,
            storeOp: "store",
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 0 }
          }]
        });
        const bindGroup = this.device.createBindGroup({
          layout: bindGroupLayout,
          entries: [{
            binding: 0,
            resource: this.sampler
          }, {
            binding: 1,
            resource: srcView
          }]
        });
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(3, 1, 0, 0);
        passEncoder.end();
        srcView = dstView;
      }
    }
    if (!renderToSource) {
      const mipLevelSize = {
        width: Math.ceil(texture.width / 2),
        height: Math.ceil(texture.height / 2),
        depthOrArrayLayers: arrayLayerCount
      };
      for (let i = 1; i < texture.mipLevelCount; ++i) {
        commandEncoder.copyTextureToTexture({
          texture: mipTexture,
          mipLevel: i - 1
        }, {
          texture,
          mipLevel: i
        }, mipLevelSize);
        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
      }
    }
    this.device.queue.submit([commandEncoder.finish()]);
    if (!renderToSource) {
      mipTexture.destroy();
    }
    return texture;
  }
}


//# sourceMappingURL=GpuMipmapGenerator.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSupportedGPUCompressedTextureFormats: () => (/* binding */ getSupportedGPUCompressedTextureFormats)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
let supportedGPUCompressedTextureFormats;
async function getSupportedGPUCompressedTextureFormats() {
  if (supportedGPUCompressedTextureFormats)
    return supportedGPUCompressedTextureFormats;
  const adapter = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getNavigator().gpu.requestAdapter();
  supportedGPUCompressedTextureFormats = [
    ...adapter.features.has("texture-compression-bc") ? [
      // BC compressed formats usable if "texture-compression-bc" is both
      // supported by the device/user agent and enabled in requestDevice.
      "bc1-rgba-unorm",
      "bc1-rgba-unorm-srgb",
      "bc2-rgba-unorm",
      "bc2-rgba-unorm-srgb",
      "bc3-rgba-unorm",
      "bc3-rgba-unorm-srgb",
      "bc4-r-unorm",
      "bc4-r-snorm",
      "bc5-rg-unorm",
      "bc5-rg-snorm",
      "bc6h-rgb-ufloat",
      "bc6h-rgb-float",
      "bc7-rgba-unorm",
      "bc7-rgba-unorm-srgb"
    ] : [],
    ...adapter.features.has("texture-compression-etc2") ? [
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      "etc2-rgb8unorm",
      "etc2-rgb8unorm-srgb",
      "etc2-rgb8a1unorm",
      "etc2-rgb8a1unorm-srgb",
      "etc2-rgba8unorm",
      "etc2-rgba8unorm-srgb",
      "eac-r11unorm",
      "eac-r11snorm",
      "eac-rg11unorm",
      "eac-rg11snorm"
    ] : [],
    ...adapter.features.has("texture-compression-astc") ? [
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      "astc-4x4-unorm",
      "astc-4x4-unorm-srgb",
      "astc-5x4-unorm",
      "astc-5x4-unorm-srgb",
      "astc-5x5-unorm",
      "astc-5x5-unorm-srgb",
      "astc-6x5-unorm",
      "astc-6x5-unorm-srgb",
      "astc-6x6-unorm",
      "astc-6x6-unorm-srgb",
      "astc-8x5-unorm",
      "astc-8x5-unorm-srgb",
      "astc-8x6-unorm",
      "astc-8x6-unorm-srgb",
      "astc-8x8-unorm",
      "astc-8x8-unorm-srgb",
      "astc-10x5-unorm",
      "astc-10x5-unorm-srgb",
      "astc-10x6-unorm",
      "astc-10x6-unorm-srgb",
      "astc-10x8-unorm",
      "astc-10x8-unorm-srgb",
      "astc-10x10-unorm",
      "astc-10x10-unorm-srgb",
      "astc-12x10-unorm",
      "astc-12x10-unorm-srgb",
      "astc-12x12-unorm",
      "astc-12x12-unorm-srgb"
    ] : []
  ];
  return supportedGPUCompressedTextureFormats;
}


//# sourceMappingURL=getSupportedGPUCompressedTextureFormats.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SchedulerSystem: () => (/* binding */ SchedulerSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../ticker/Ticker.mjs */ "./node_modules/pixi.js/lib/ticker/Ticker.mjs");



"use strict";
let uid = 1;
class SchedulerSystem {
  constructor() {
    this._tasks = [];
    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */
    this._offset = 0;
  }
  /** Initializes the scheduler system and starts the ticker. */
  init() {
    _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.add(this._update, this);
  }
  /**
   * Schedules a repeating task.
   * @param func - The function to execute.
   * @param duration - The interval duration in milliseconds.
   * @param useOffset - this will spread out tasks so that they do not all run at the same time
   * @returns The unique identifier for the scheduled task.
   */
  repeat(func, duration, useOffset = true) {
    const id = uid++;
    let offset = 0;
    if (useOffset) {
      this._offset += 1e3;
      offset = this._offset;
    }
    this._tasks.push({
      func,
      duration,
      start: performance.now(),
      offset,
      last: performance.now(),
      repeat: true,
      id
    });
    return id;
  }
  /**
   * Cancels a scheduled task.
   * @param id - The unique identifier of the task to cancel.
   */
  cancel(id) {
    for (let i = 0; i < this._tasks.length; i++) {
      if (this._tasks[i].id === id) {
        this._tasks.splice(i, 1);
        return;
      }
    }
  }
  /**
   * Updates and executes the scheduled tasks.
   * @private
   */
  _update() {
    const now = performance.now();
    for (let i = 0; i < this._tasks.length; i++) {
      const task = this._tasks[i];
      if (now - task.offset - task.last >= task.duration) {
        const elapsed = now - task.start;
        task.func(elapsed);
        task.last = now;
      }
    }
  }
  /**
   * Destroys the scheduler system and removes all tasks.
   * @internal
   * @ignore
   */
  destroy() {
    _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.remove(this._update, this);
    this._tasks.length = 0;
  }
}
/** @ignore */
SchedulerSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.CanvasSystem
  ],
  name: "scheduler",
  priority: 0
};


//# sourceMappingURL=SchedulerSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundSystem: () => (/* binding */ BackgroundSystem)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");



"use strict";
const _BackgroundSystem = class _BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color(0);
    this.color = this._backgroundColor;
    this.alpha = 1;
  }
  /**
   * initiates the background system
   * @param options - the options for the background colors
   */
  init(options) {
    options = { ..._BackgroundSystem.defaultOptions, ...options };
    this.clearBeforeRender = options.clearBeforeRender;
    this.color = options.background || options.backgroundColor || this._backgroundColor;
    this.alpha = options.backgroundAlpha;
    this._backgroundColor.setAlpha(options.backgroundAlpha);
  }
  /** The background color to fill if not transparent */
  get color() {
    return this._backgroundColor;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  /** The background color alpha. Setting this to 0 will make the canvas transparent. */
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  /** The background color as an [R, G, B, A] array. */
  get colorRgba() {
    return this._backgroundColor.toArray();
  }
  /**
   * destroys the background system
   * @internal
   * @ignore
   */
  destroy() {
  }
};
/** @ignore */
_BackgroundSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.CanvasSystem
  ],
  name: "background",
  priority: 0
};
/** default options used by the system */
_BackgroundSystem.defaultOptions = {
  /**
   * {@link WebGLOptions.backgroundAlpha}
   * @default 1
   */
  backgroundAlpha: 1,
  /**
   * {@link WebGLOptions.backgroundColor}
   * @default 0x000000
   */
  backgroundColor: 0,
  /**
   * {@link WebGLOptions.clearBeforeRender}
   * @default true
   */
  clearBeforeRender: true
};
let BackgroundSystem = _BackgroundSystem;


//# sourceMappingURL=BackgroundSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BlendModePipe: () => (/* binding */ BlendModePipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../filters/FilterEffect.mjs */ "./node_modules/pixi.js/lib/filters/FilterEffect.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");




"use strict";
const BLEND_MODE_FILTERS = {};
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions.handle(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.BlendMode, (value) => {
  if (!value.name) {
    throw new Error("BlendMode extension must have a name property");
  }
  BLEND_MODE_FILTERS[value.name] = value.ref;
}, (value) => {
  delete BLEND_MODE_FILTERS[value.name];
});
class BlendModePipe {
  constructor(renderer) {
    this._isAdvanced = false;
    this._filterHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._renderer.runners.prerender.add(this);
  }
  prerender() {
    this._activeBlendMode = "normal";
    this._isAdvanced = false;
  }
  /**
   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
   * @param renderable - The renderable we are adding to the instruction set
   * @param blendMode - The blend mode of the renderable
   * @param instructionSet - The instruction set we are adding to
   */
  setBlendMode(renderable, blendMode, instructionSet) {
    if (this._activeBlendMode === blendMode) {
      if (this._isAdvanced)
        this._renderableList.push(renderable);
      return;
    }
    this._activeBlendMode = blendMode;
    if (this._isAdvanced) {
      this._endAdvancedBlendMode(instructionSet);
    }
    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
    if (this._isAdvanced) {
      this._beginAdvancedBlendMode(instructionSet);
      this._renderableList.push(renderable);
    }
  }
  _beginAdvancedBlendMode(instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    const blendMode = this._activeBlendMode;
    if (!BLEND_MODE_FILTERS[blendMode]) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__.warn)(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
      return;
    }
    let filterEffect = this._filterHash[blendMode];
    if (!filterEffect) {
      filterEffect = this._filterHash[blendMode] = new _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_2__.FilterEffect();
      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
    }
    const instruction = {
      renderPipeId: "filter",
      action: "pushFilter",
      renderables: [],
      filterEffect,
      canBundle: false
    };
    this._renderableList = instruction.renderables;
    instructionSet.add(instruction);
  }
  _endAdvancedBlendMode(instructionSet) {
    this._renderableList = null;
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: false
    });
  }
  /**
   * called when the instruction build process is starting this will reset internally to the default blend mode
   * @internal
   * @ignore
   */
  buildStart() {
    this._isAdvanced = false;
  }
  /**
   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
   * active, we add the final render instructions added to the instruction set
   * @param instructionSet - The instruction set we are adding to
   * @internal
   * @ignore
   */
  buildEnd(instructionSet) {
    if (this._isAdvanced) {
      this._endAdvancedBlendMode(instructionSet);
    }
  }
  /**
   * @internal
   * @ignore
   */
  destroy() {
    this._renderer = null;
    this._renderableList = null;
    for (const i in this._filterHash) {
      this._filterHash[i].destroy();
    }
    this._filterHash = null;
  }
}
/** @ignore */
BlendModePipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasPipes
  ],
  name: "blendMode"
};


//# sourceMappingURL=BlendModePipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Buffer: () => (/* binding */ Buffer)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");




"use strict";
class Buffer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(options) {
    let { data, size } = options;
    const { usage, label, shrinkToFit } = options;
    super();
    /**
     * emits when the underlying buffer has changed shape (i.e. resized)
     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one
     * @event change
     */
    /**
     * emits when the underlying buffer data has been updated. letting the renderer know
     * that it needs to update the buffer on the GPU
     * @event update
     */
    /**
     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU
     * @event destroy
     */
    /** a unique id for this uniform group used through the renderer */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("buffer");
    /**
     * a resource type, used to identify how to handle it when its in a bind group / shader resource
     * @internal
     * @ignore
     */
    this._resourceType = "buffer";
    /**
     * the resource id used internally by the renderer to build bind group keys
     * @internal
     * @ignore
     */
    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
    /**
     * used internally to know if a uniform group was used in the last render pass
     * @internal
     * @ignore
     */
    this._touched = 0;
    /**
     * @internal
     * @ignore
     */
    this._updateID = 1;
    this._dataInt32 = null;
    /**
     * should the GPU buffer be shrunk when the data becomes smaller?
     * changing this will cause the buffer to be destroyed and a new one created on the GPU
     * this can be expensive, especially if the buffer is already big enough!
     * setting this to false will prevent the buffer from being shrunk. This will yield better performance
     * if you are constantly setting data that is changing size often.
     * @default true
     */
    this.shrinkToFit = true;
    /**
     * Has the buffer been destroyed?
     * @readonly
     */
    this.destroyed = false;
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this._data = data;
    size ?? (size = data?.byteLength);
    const mappedAtCreation = !!data;
    this.descriptor = {
      size,
      usage,
      mappedAtCreation,
      label
    };
    this.shrinkToFit = shrinkToFit ?? true;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(value) {
    this.setDataWithSize(value, value.length, true);
  }
  get dataInt32() {
    if (!this._dataInt32) {
      this._dataInt32 = new Int32Array(this.data.buffer);
    }
    return this._dataInt32;
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & _const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.STATIC);
  }
  set static(value) {
    if (value) {
      this.descriptor.usage |= _const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.STATIC;
    } else {
      this.descriptor.usage &= ~_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.STATIC;
    }
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(value, size, syncGPU) {
    this._updateID++;
    this._updateSize = size * value.BYTES_PER_ELEMENT;
    if (this._data === value) {
      if (syncGPU)
        this.emit("update", this);
      return;
    }
    const oldData = this._data;
    this._data = value;
    this._dataInt32 = null;
    if (!oldData || oldData.length !== value.length) {
      if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
        if (syncGPU)
          this.emit("update", this);
      } else {
        this.descriptor.size = value.byteLength;
        this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
        this.emit("change", this);
      }
      return;
    }
    if (syncGPU)
      this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(sizeInBytes) {
    this._updateSize = sizeInBytes ?? this._updateSize;
    this._updateID++;
    this.emit("update", this);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = true;
    this.emit("destroy", this);
    this.emit("change", this);
    this._data = null;
    this.descriptor = null;
    this.removeAllListeners();
  }
}


//# sourceMappingURL=Buffer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferResource: () => (/* binding */ BufferResource)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");



"use strict";
class BufferResource extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * Create a new Buffer Resource.
   * @param options - The options for the buffer resource
   * @param options.buffer - The underlying buffer that this resource is using
   * @param options.offset - The offset of the buffer this resource is using.
   * If not provided, then it will use the offset of the buffer.
   * @param options.size - The size of the buffer this resource is using.
   * If not provided, then it will use the size of the buffer.
   */
  constructor({ buffer, offset, size }) {
    super();
    /**
     * emits when the underlying buffer has changed shape (i.e. resized)
     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one
     * @event change
     */
    /** a unique id for this uniform group used through the renderer */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("buffer");
    /**
     * a resource type, used to identify how to handle it when its in a bind group / shader resource
     * @internal
     * @ignore
     */
    this._resourceType = "bufferResource";
    /**
     * used internally to know if a uniform group was used in the last render pass
     * @internal
     * @ignore
     */
    this._touched = 0;
    /**
     * the resource id used internally by the renderer to build bind group keys
     * @internal
     * @ignore
     */
    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
    /**
     * A cheeky hint to the GL renderer to let it know this is a BufferResource
     * @internal
     * @ignore
     */
    this._bufferResource = true;
    /**
     * Has the Buffer resource been destroyed?
     * @readonly
     */
    this.destroyed = false;
    this.buffer = buffer;
    this.offset = offset | 0;
    this.size = size;
    this.buffer.on("change", this.onBufferChange, this);
  }
  onBufferChange() {
    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
    this.emit("change", this);
  }
  /**
   * Destroys this resource. Make sure the underlying buffer is not used anywhere else
   * if you want to destroy it as well, or code will explode
   * @param destroyBuffer - Should the underlying buffer be destroyed as well?
   */
  destroy(destroyBuffer = false) {
    this.destroyed = true;
    if (destroyBuffer) {
      this.buffer.destroy();
    }
    this.emit("change", this);
    this.buffer = null;
  }
}


//# sourceMappingURL=BufferResource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferUsage: () => (/* binding */ BufferUsage)
/* harmony export */ });

var BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
  return BufferUsage2;
})(BufferUsage || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fastCopy: () => (/* binding */ fastCopy)
/* harmony export */ });

function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  destinationFloat64View.set(sourceFloat64View);
  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
  if (remainingBytes > 0) {
    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
    destinationUint8View.set(sourceUint8View);
  }
}


//# sourceMappingURL=fastCopy.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtractSystem: () => (/* binding */ ExtractSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");




"use strict";
const imageTypes = {
  png: "image/png",
  jpg: "image/jpeg",
  webp: "image/webp"
};
const _ExtractSystem = class _ExtractSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this._renderer = renderer;
  }
  _normalizeOptions(options, defaults = {}) {
    if (options instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__.Container || options instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      return {
        target: options,
        ...defaults
      };
    }
    return {
      ...defaults,
      ...options
    };
  }
  /**
   * Will return a HTML Image of the target
   * @param options - The options for creating the image, or the target to extract
   * @returns - HTML Image of the target
   */
  async image(options) {
    const image = new Image();
    image.src = await this.base64(options);
    return image;
  }
  /**
   * Will return a base64 encoded string of this target. It works by calling
   * `Extract.canvas` and then running toDataURL on that.
   * @param options - The options for creating the image, or the target to extract
   */
  async base64(options) {
    options = this._normalizeOptions(
      options,
      _ExtractSystem.defaultImageOptions
    );
    const { format, quality } = options;
    const canvas = this.canvas(options);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, imageTypes[format], quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(imageTypes[format], quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  /**
   * Creates a Canvas element, renders this target to it and then returns it.
   * @param options - The options for creating the canvas, or the target to extract
   * @returns - A Canvas element with the texture rendered on.
   */
  canvas(options) {
    options = this._normalizeOptions(options);
    const target = options.target;
    const renderer = this._renderer;
    if (target instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      return renderer.texture.generateCanvas(target);
    }
    const texture = renderer.textureGenerator.generateTexture(options);
    const canvas = renderer.texture.generateCanvas(texture);
    texture.destroy(true);
    return canvas;
  }
  /**
   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
   * order, with integer values between 0 and 255 (included).
   * @param options - The options for extracting the image, or the target to extract
   * @returns - One-dimensional array containing the pixel data of the entire texture
   */
  pixels(options) {
    options = this._normalizeOptions(options);
    const target = options.target;
    const renderer = this._renderer;
    const texture = target instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture ? target : renderer.textureGenerator.generateTexture(options);
    const pixelInfo = renderer.texture.getPixels(texture);
    if (target instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__.Container) {
      texture.destroy(true);
    }
    return pixelInfo;
  }
  /**
   * Will return a texture of the target
   * @param options - The options for creating the texture, or the target to extract
   * @returns - A texture of the target
   */
  texture(options) {
    options = this._normalizeOptions(options);
    if (options.target instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture)
      return options.target;
    return this._renderer.textureGenerator.generateTexture(options);
  }
  /**
   * Will extract a HTMLImage of the target and download it
   * @param options - The options for downloading and extracting the image, or the target to extract
   */
  download(options) {
    options = this._normalizeOptions(options);
    const canvas = this.canvas(options);
    const link = document.createElement("a");
    link.download = options.filename ?? "image.png";
    link.href = canvas.toDataURL("image/png");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
  /**
   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
   * @param options - The options for logging the image, or the target to log
   */
  log(options) {
    const width = options.width ?? 200;
    options = this._normalizeOptions(options);
    const canvas = this.canvas(options);
    const base64 = canvas.toDataURL();
    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
    const style = [
      "font-size: 1px;",
      `padding: ${width}px ${300}px;`,
      `background: url(${base64}) no-repeat;`,
      "background-size: contain;"
    ].join(" ");
    console.log("%c ", style);
  }
  destroy() {
    this._renderer = null;
  }
};
/** @ignore */
_ExtractSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUSystem
  ],
  name: "extract"
};
/** Default options for creating an image. */
_ExtractSystem.defaultImageOptions = {
  /** The format of the image. */
  format: "png",
  /** The quality of the image. */
  quality: 1
};
let ExtractSystem = _ExtractSystem;


//# sourceMappingURL=ExtractSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GenerateTextureSystem: () => (/* binding */ GenerateTextureSystem)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../scene/container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _scene_container_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../scene/container/bounds/getLocalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs");
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _texture_RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../texture/RenderTexture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs");









"use strict";
const tempRect = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
const tempBounds = new _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds();
const noColor = [0, 0, 0, 0];
class GenerateTextureSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  /**
   * A Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your container is complicated and needs to be reused multiple times.
   * @param {GenerateTextureOptions | Container} options - Generate texture options.
   * @param {Container} [options.container] - If not given, the renderer's resolution is used.
   * @param {Rectangle} options.region - The region of the container, that shall be rendered,
   * @param {number} [options.resolution] - The resolution of the texture being generated.
   *        if no region is specified, defaults to the local bounds of the container.
   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
   * @returns a shiny new texture of the container passed in
   */
  generateTexture(options) {
    if (options instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__.Container) {
      options = {
        target: options,
        frame: void 0,
        textureSourceOptions: {},
        resolution: void 0
      };
    }
    const resolution = options.resolution || this._renderer.resolution;
    const antialias = options.antialias || this._renderer.view.antialias;
    const container = options.target;
    let clearColor = options.clearColor;
    if (clearColor) {
      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
      clearColor = isRGBAArray ? clearColor : _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__.Color.shared.setValue(clearColor).toArray();
    } else {
      clearColor = noColor;
    }
    const region = options.frame?.copyTo(tempRect) || (0,_scene_container_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_4__.getLocalBounds)(container, tempBounds).rectangle;
    region.width = Math.max(region.width, 1 / resolution) | 0;
    region.height = Math.max(region.height, 1 / resolution) | 0;
    const target = _texture_RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_5__.RenderTexture.create({
      ...options.textureSourceOptions,
      width: region.width,
      height: region.height,
      resolution,
      antialias
    });
    const transform = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__.Matrix.shared.translate(-region.x, -region.y);
    this._renderer.render({
      container,
      transform,
      target,
      clearColor
    });
    target.source.updateMipmaps();
    return target;
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
GenerateTextureSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.WebGPUSystem
  ],
  name: "textureGenerator"
};


//# sourceMappingURL=GenerateTextureSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Geometry: () => (/* binding */ Geometry)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../scene/container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _utils_ensureIsBuffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/ensureIsBuffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs");
/* harmony import */ var _utils_getGeometryBounds_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/getGeometryBounds.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs");







"use strict";
function ensureIsAttribute(attribute) {
  if (attribute instanceof _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
    attribute = {
      buffer: attribute
    };
  }
  attribute.buffer = (0,_utils_ensureIsBuffer_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureIsBuffer)(attribute.buffer, false);
  return attribute;
}
class Geometry extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(options = {}) {
    super();
    /** The unique id of the geometry. */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_3__.uid)("geometry");
    /**
     * the layout key will be generated by WebGPU all geometries that have the same structure
     * will have the same layout key. This is used to cache the pipeline layout
     * @internal
     * @ignore
     */
    this._layoutKey = 0;
    /** the instance count of the geometry to draw */
    this.instanceCount = 1;
    this._bounds = new _scene_container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_4__.Bounds();
    this._boundsDirty = true;
    const { attributes, indexBuffer, topology } = options;
    this.buffers = [];
    this.attributes = {};
    if (attributes) {
      for (const i in attributes) {
        this.addAttribute(i, attributes[i]);
      }
    }
    this.instanceCount = options.instanceCount ?? 1;
    if (indexBuffer) {
      this.addIndex(indexBuffer);
    }
    this.topology = topology || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = true;
    this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(id) {
    return this.attributes[id];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(id) {
    return this.getAttribute(id).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = attribute.buffer;
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(name, attributeOption) {
    const attribute = ensureIsAttribute(attributeOption);
    const bufferIndex = this.buffers.indexOf(attribute.buffer);
    if (bufferIndex === -1) {
      this.buffers.push(attribute.buffer);
      attribute.buffer.on("update", this.onBufferUpdate, this);
      attribute.buffer.on("change", this.onBufferUpdate, this);
    }
    this.attributes[name] = attribute;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(indexBuffer) {
    this.indexBuffer = (0,_utils_ensureIsBuffer_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureIsBuffer)(indexBuffer, true);
    this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    this._boundsDirty = false;
    return (0,_utils_getGeometryBounds_mjs__WEBPACK_IMPORTED_MODULE_5__.getGeometryBounds)(this, "aPosition", this._bounds);
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(destroyBuffers = false) {
    this.emit("destroy", this);
    this.removeAllListeners();
    if (destroyBuffers) {
      this.buffers.forEach((buffer) => buffer.destroy());
    }
    this.attributes = null;
    this.buffers = null;
    this.indexBuffer = null;
    this._bounds = null;
  }
}


//# sourceMappingURL=Geometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DRAW_MODES: () => (/* binding */ DRAW_MODES)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");


"use strict";
const DEPRECATED_DRAW_MODES = {
  POINTS: "point-list",
  LINES: "line-list",
  LINE_STRIP: "line-strip",
  TRIANGLES: "triangle-list",
  TRIANGLE_STRIP: "triangle-strip"
};
const DRAW_MODES = new Proxy(DEPRECATED_DRAW_MODES, {
  get(target, prop) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_DRAW_MODES[prop]}' instead`);
    return target[prop];
  }
});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildSimpleUvs: () => (/* binding */ buildSimpleUvs),
/* harmony export */   buildUvs: () => (/* binding */ buildUvs)
/* harmony export */ });

function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a = matrix.a;
  const b = matrix.b;
  const c = matrix.c;
  const d = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size) {
    const x = vertices[verticesOffset];
    const y = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a * x + c * y + tx;
    uvs[uvsOffset + 1] = b * x + d * y + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}


//# sourceMappingURL=buildUvs.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ensureIsBuffer: () => (/* binding */ ensureIsBuffer)
/* harmony export */ });
/* harmony import */ var _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");



"use strict";
function ensureIsBuffer(buffer, index) {
  if (!(buffer instanceof _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.Buffer)) {
    let usage = index ? _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.INDEX : _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index) {
        buffer = new Uint32Array(buffer);
        usage = _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.INDEX | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.VERTEX | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferUsage.COPY_DST;
      }
    }
    buffer = new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.Buffer({
      data: buffer,
      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage
    });
  }
  return buffer;
}


//# sourceMappingURL=ensureIsBuffer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAttributeInfoFromFormat: () => (/* binding */ getAttributeInfoFromFormat)
/* harmony export */ });

const attributeFormatData = {
  uint8x2: { size: 2, stride: 2, normalised: false },
  uint8x4: { size: 4, stride: 4, normalised: false },
  sint8x2: { size: 2, stride: 2, normalised: false },
  sint8x4: { size: 4, stride: 4, normalised: false },
  unorm8x2: { size: 2, stride: 2, normalised: true },
  unorm8x4: { size: 4, stride: 4, normalised: true },
  snorm8x2: { size: 2, stride: 2, normalised: true },
  snorm8x4: { size: 4, stride: 4, normalised: true },
  uint16x2: { size: 2, stride: 4, normalised: false },
  uint16x4: { size: 4, stride: 8, normalised: false },
  sint16x2: { size: 2, stride: 4, normalised: false },
  sint16x4: { size: 4, stride: 8, normalised: false },
  unorm16x2: { size: 2, stride: 4, normalised: true },
  unorm16x4: { size: 4, stride: 8, normalised: true },
  snorm16x2: { size: 2, stride: 4, normalised: true },
  snorm16x4: { size: 4, stride: 8, normalised: true },
  float16x2: { size: 2, stride: 4, normalised: false },
  float16x4: { size: 4, stride: 8, normalised: false },
  float32: { size: 1, stride: 4, normalised: false },
  float32x2: { size: 2, stride: 8, normalised: false },
  float32x3: { size: 3, stride: 12, normalised: false },
  float32x4: { size: 4, stride: 16, normalised: false },
  uint32: { size: 1, stride: 4, normalised: false },
  uint32x2: { size: 2, stride: 8, normalised: false },
  uint32x3: { size: 3, stride: 12, normalised: false },
  uint32x4: { size: 4, stride: 16, normalised: false },
  sint32: { size: 1, stride: 4, normalised: false },
  sint32x2: { size: 2, stride: 8, normalised: false },
  sint32x3: { size: 3, stride: 12, normalised: false },
  sint32x4: { size: 4, stride: 16, normalised: false }
};
function getAttributeInfoFromFormat(format) {
  return attributeFormatData[format] ?? attributeFormatData.float32;
}


//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGeometryBounds: () => (/* binding */ getGeometryBounds)
/* harmony export */ });

function getGeometryBounds(geometry, attributeId, bounds) {
  const attribute = geometry.getAttribute(attributeId);
  if (!attribute) {
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = 0;
    bounds.maxY = 0;
    return bounds;
  }
  const data = attribute.buffer.data;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  const byteSize = data.BYTES_PER_ELEMENT;
  const offset = (attribute.offset || 0) / byteSize;
  const stride = (attribute.stride || 2 * 4) / byteSize;
  for (let i = offset; i < data.length; i += stride) {
    const x = data[i];
    const y = data[i + 1];
    if (x > maxX)
      maxX = x;
    if (y > maxY)
      maxY = y;
    if (x < minX)
      minX = x;
    if (y < minY)
      minY = y;
  }
  bounds.minX = minX;
  bounds.minY = minY;
  bounds.maxX = maxX;
  bounds.maxY = maxY;
  return bounds;
}


//# sourceMappingURL=getGeometryBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   transformVertices: () => (/* binding */ transformVertices)
/* harmony export */ });

function transformVertices(vertices, m, offset, stride, size) {
  const a = m.a;
  const b = m.b;
  const c = m.c;
  const d = m.d;
  const tx = m.tx;
  const ty = m.ty;
  offset || (offset = 0);
  stride || (stride = 2);
  size || (size = vertices.length / stride - offset);
  let index = offset * stride;
  for (let i = 0; i < size; i++) {
    const x = vertices[index];
    const y = vertices[index + 1];
    vertices[index] = a * x + c * y + tx;
    vertices[index + 1] = b * x + d * y + ty;
    index += stride;
  }
}


//# sourceMappingURL=transformVertices.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InstructionSet: () => (/* binding */ InstructionSet)
/* harmony export */ });
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");


"use strict";
class InstructionSet {
  constructor() {
    /** a unique id for this instruction set used through the renderer */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.uid)("instructionSet");
    /** the array of instructions */
    this.instructions = [];
    /** the actual size of the array (any instructions passed this should be ignored) */
    this.instructionSize = 0;
    this.renderables = [];
    /** used by the garbage collector to track when the instruction set was last used */
    this.gcTick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(instruction) {
    this.instructions[this.instructionSize++] = instruction;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   * @ignore
   */
  log() {
    this.instructions.length = this.instructionSize;
    console.table(this.instructions, ["type", "action"]);
  }
}


//# sourceMappingURL=InstructionSet.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlobalUniformSystem: () => (/* binding */ GlobalUniformSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _scene_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../scene/graphics/gpu/colorToUniform.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs");
/* harmony import */ var _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../gpu/shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");








"use strict";
class GlobalUniformSystem {
  constructor(renderer) {
    this._stackIndex = 0;
    this._globalUniformDataStack = [];
    this._uniformsPool = [];
    this._activeUniforms = [];
    this._bindGroupPool = [];
    this._activeBindGroups = [];
    this._renderer = renderer;
  }
  reset() {
    this._stackIndex = 0;
    for (let i = 0; i < this._activeUniforms.length; i++) {
      this._uniformsPool.push(this._activeUniforms[i]);
    }
    for (let i = 0; i < this._activeBindGroups.length; i++) {
      this._bindGroupPool.push(this._activeBindGroups[i]);
    }
    this._activeUniforms.length = 0;
    this._activeBindGroups.length = 0;
  }
  start(options) {
    this.reset();
    this.push(options);
  }
  bind({
    size,
    projectionMatrix,
    worldTransformMatrix,
    worldColor,
    offset
  }) {
    const renderTarget = this._renderer.renderTarget.renderTarget;
    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
      projectionData: renderTarget,
      worldTransformMatrix: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix(),
      worldColor: 4294967295,
      offset: new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point()
    };
    const globalUniformData = {
      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
      resolution: size || renderTarget.size,
      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
      worldColor: worldColor || currentGlobalUniformData.worldColor,
      offset: offset || currentGlobalUniformData.offset,
      bindGroup: null
    };
    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
    this._activeUniforms.push(uniformGroup);
    const uniforms = uniformGroup.uniforms;
    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
    uniforms.uResolution = globalUniformData.resolution;
    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
    (0,_scene_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_2__.color32BitToUniform)(
      globalUniformData.worldColor,
      uniforms.uWorldColorAlpha,
      0
    );
    uniformGroup.update();
    let bindGroup;
    if (this._renderer.renderPipes.uniformBatch) {
      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
    } else {
      bindGroup = this._bindGroupPool.pop() || new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.BindGroup();
      this._activeBindGroups.push(bindGroup);
      bindGroup.setResource(uniformGroup, 0);
    }
    globalUniformData.bindGroup = bindGroup;
    this._currentGlobalUniformData = globalUniformData;
  }
  push(options) {
    this.bind(options);
    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
  }
  pop() {
    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
    if (this._renderer.type === _types_mjs__WEBPACK_IMPORTED_MODULE_4__.RendererType.WEBGL) {
      this._currentGlobalUniformData.bindGroup.resources[0].update();
    }
  }
  get bindGroup() {
    return this._currentGlobalUniformData.bindGroup;
  }
  get globalUniformData() {
    return this._currentGlobalUniformData;
  }
  get uniformGroup() {
    return this._currentGlobalUniformData.bindGroup.resources[0];
  }
  _createUniforms() {
    const globalUniforms = new _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.UniformGroup({
      uProjectionMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix(), type: "mat3x3<f32>" },
      uWorldTransformMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix(), type: "mat3x3<f32>" },
      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
      uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    }, {
      isStatic: true
    });
    return globalUniforms;
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
GlobalUniformSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.CanvasSystem
  ],
  name: "globalUniforms"
};


//# sourceMappingURL=GlobalUniformSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderTarget: () => (/* binding */ RenderTarget)
/* harmony export */ });
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");




"use strict";
const _RenderTarget = class _RenderTarget {
  /**
   * @param [descriptor] - Options for creating a render target.
   */
  constructor(descriptor = {}) {
    /** unique id for this render target */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.uid)("renderTarget");
    /**
     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could
     * write to multiple if required! (eg deferred lighting)
     */
    this.colorTextures = [];
    this.dirtyId = 0;
    this.isRoot = false;
    this._size = new Float32Array(2);
    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */
    this._managedColorTextures = false;
    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };
    this.stencil = descriptor.stencil;
    this.depth = descriptor.depth;
    this.isRoot = descriptor.isRoot;
    if (typeof descriptor.colorTextures === "number") {
      this._managedColorTextures = true;
      for (let i = 0; i < descriptor.colorTextures; i++) {
        this.colorTextures.push(
          new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureSource({
            width: descriptor.width,
            height: descriptor.height,
            resolution: descriptor.resolution,
            antialias: descriptor.antialias
          })
        );
      }
    } else {
      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
      const colorSource = this.colorTexture.source;
      this.resize(colorSource.width, colorSource.height, colorSource._resolution);
    }
    this.colorTexture.source.on("resize", this.onSourceResize, this);
    if (descriptor.depthStencilTexture || this.stencil) {
      if (descriptor.depthStencilTexture instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.Texture || descriptor.depthStencilTexture instanceof _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureSource) {
        this.depthStencilTexture = descriptor.depthStencilTexture.source;
      } else {
        this.ensureDepthStencilTexture();
      }
    }
  }
  get size() {
    const _size = this._size;
    _size[0] = this.pixelWidth;
    _size[1] = this.pixelHeight;
    return _size;
  }
  get width() {
    return this.colorTexture.source.width;
  }
  get height() {
    return this.colorTexture.source.height;
  }
  get pixelWidth() {
    return this.colorTexture.source.pixelWidth;
  }
  get pixelHeight() {
    return this.colorTexture.source.pixelHeight;
  }
  get resolution() {
    return this.colorTexture.source._resolution;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  onSourceResize(source) {
    this.resize(source.width, source.height, source._resolution, true);
  }
  /**
   * This will ensure a depthStencil texture is created for this render target.
   * Most likely called by the mask system to make sure we have stencil buffer added.
   * @internal
   * @ignore
   */
  ensureDepthStencilTexture() {
    if (!this.depthStencilTexture) {
      this.depthStencilTexture = new _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureSource({
        width: this.width,
        height: this.height,
        resolution: this.resolution,
        format: "depth24plus-stencil8",
        autoGenerateMipmaps: false,
        antialias: false,
        mipLevelCount: 1
        // sampleCount: handled by the render target system..
      });
    }
  }
  resize(width, height, resolution = this.resolution, skipColorTexture = false) {
    this.dirtyId++;
    this.colorTextures.forEach((colorTexture, i) => {
      if (skipColorTexture && i === 0)
        return;
      colorTexture.source.resize(width, height, resolution);
    });
    if (this.depthStencilTexture) {
      this.depthStencilTexture.source.resize(width, height, resolution);
    }
  }
  destroy() {
    this.colorTexture.source.off("resize", this.onSourceResize, this);
    if (this._managedColorTextures) {
      this.colorTextures.forEach((texture) => {
        texture.destroy();
      });
    }
    if (this.depthStencilTexture) {
      this.depthStencilTexture.destroy();
      delete this.depthStencilTexture;
    }
  }
};
/** The default options for a render target */
_RenderTarget.defaultOptions = {
  /** the width of the RenderTarget */
  width: 0,
  /** the height of the RenderTarget */
  height: 0,
  /** the resolution of the RenderTarget */
  resolution: 1,
  /** an array of textures, or a number indicating how many color textures there should be */
  colorTextures: 1,
  /** should this render target have a stencil buffer? */
  stencil: false,
  /** should this render target have a depth buffer? */
  depth: false,
  /** should this render target be antialiased? */
  antialias: false,
  // save on perf by default!
  /** is this a root element, true if this is gl context owners render target */
  isRoot: false
};
let RenderTarget = _RenderTarget;


//# sourceMappingURL=RenderTarget.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderTargetSystem: () => (/* binding */ RenderTargetSystem)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _gl_const_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../gl/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs");
/* harmony import */ var _gpu_renderTarget_calculateProjection_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../gpu/renderTarget/calculateProjection.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs");
/* harmony import */ var _system_SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../system/SystemRunner.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs");
/* harmony import */ var _texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../texture/sources/CanvasSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs");
/* harmony import */ var _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../texture/sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _texture_utils_getCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../texture/utils/getCanvasTexture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs");
/* harmony import */ var _isRenderingToScreen_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isRenderingToScreen.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs");
/* harmony import */ var _RenderTarget_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./RenderTarget.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs");












"use strict";
class RenderTargetSystem {
  constructor(renderer) {
    /** This is the root viewport for the render pass*/
    this.rootViewPort = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
    /** the current viewport that the gpu is using */
    this.viewport = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
    /**
     * a runner that lets systems know if the active render target has changed.
     * Eg the Stencil System needs to know so it can manage the stencil buffer
     */
    this.onRenderTargetChange = new _system_SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_1__.SystemRunner("onRenderTargetChange");
    /** the projection matrix that is used by the shaders based on the active render target and the viewport */
    this.projectionMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix();
    /** the default clear color for render targets */
    this.defaultClearColor = [0, 0, 0, 0];
    /**
     * a hash that stores the render target for a given render surface. When you pass in a texture source,
     * a render target is created for it. This map stores and makes it easy to retrieve the render target
     */
    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
    /** A hash that stores a gpu render target for a given render target. */
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    /**
     * A stack that stores the render target and frame that is currently being rendered to.
     * When push is called, the current render target is stored in this stack.
     * When pop is called, the previous render target is restored.
     */
    this._renderTargetStack = [];
    this._renderer = renderer;
    renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
  }
  /** called when dev wants to finish a render pass */
  finishRenderPass() {
    this.adaptor.finishRenderPass(this.renderTarget);
  }
  /**
   * called when the renderer starts to render a scene.
   * @param options
   * @param options.target - the render target to render to
   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param options.clearColor - the color to clear to
   * @param options.frame - the frame to render to
   */
  renderStart({
    target,
    clear,
    clearColor,
    frame
  }) {
    this._renderTargetStack.length = 0;
    this.push(
      target,
      clear,
      clearColor,
      frame
    );
    this.rootViewPort.copyFrom(this.viewport);
    this.rootRenderTarget = this.renderTarget;
    this.renderingToScreen = (0,_isRenderingToScreen_mjs__WEBPACK_IMPORTED_MODULE_3__.isRenderingToScreen)(this.rootRenderTarget);
    this.adaptor.prerender?.(this.rootRenderTarget);
  }
  postrender() {
    this.adaptor.postrender?.(this.rootRenderTarget);
  }
  /**
   * Binding a render surface! This is the main function of the render target system.
   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
   * Once bound all draw calls will be rendered to the render surface.
   *
   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
   * @param renderSurface - the render surface to bind
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to render to
   * @returns the render target that was bound
   */
  bind(renderSurface, clear = true, clearColor, frame) {
    const renderTarget = this.getRenderTarget(renderSurface);
    const didChange = this.renderTarget !== renderTarget;
    this.renderTarget = renderTarget;
    this.renderSurface = renderSurface;
    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
      this.adaptor.resizeGpuRenderTarget(renderTarget);
      gpuRenderTarget.width = renderTarget.pixelWidth;
      gpuRenderTarget.height = renderTarget.pixelHeight;
    }
    const source = renderTarget.colorTexture;
    const viewport = this.viewport;
    const pixelWidth = source.pixelWidth;
    const pixelHeight = source.pixelHeight;
    if (!frame && renderSurface instanceof _texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_4__.Texture) {
      frame = renderSurface.frame;
    }
    if (frame) {
      const resolution = source._resolution;
      viewport.x = frame.x * resolution + 0.5 | 0;
      viewport.y = frame.y * resolution + 0.5 | 0;
      viewport.width = frame.width * resolution + 0.5 | 0;
      viewport.height = frame.height * resolution + 0.5 | 0;
    } else {
      viewport.x = 0;
      viewport.y = 0;
      viewport.width = pixelWidth;
      viewport.height = pixelHeight;
    }
    (0,_gpu_renderTarget_calculateProjection_mjs__WEBPACK_IMPORTED_MODULE_5__.calculateProjection)(
      this.projectionMatrix,
      0,
      0,
      viewport.width / source.resolution,
      viewport.height / source.resolution,
      !renderTarget.isRoot
    );
    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
    if (didChange) {
      this.onRenderTargetChange.emit(renderTarget);
    }
    return renderTarget;
  }
  clear(target, clear = _gl_const_mjs__WEBPACK_IMPORTED_MODULE_6__.CLEAR.ALL, clearColor) {
    if (!clear)
      return;
    if (target) {
      target = this.getRenderTarget(target);
    }
    this.adaptor.clear(
      target || this.renderTarget,
      clear,
      clearColor,
      this.viewport
    );
  }
  contextChange() {
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Push a render surface to the renderer. This will bind the render surface to the renderer,
   * @param renderSurface - the render surface to push
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to use when rendering to the render surface
   */
  push(renderSurface, clear = _gl_const_mjs__WEBPACK_IMPORTED_MODULE_6__.CLEAR.ALL, clearColor, frame) {
    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
    this._renderTargetStack.push({
      renderTarget,
      frame
    });
    return renderTarget;
  }
  /** Pops the current render target from the renderer and restores the previous render target. */
  pop() {
    this._renderTargetStack.pop();
    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
  }
  /**
   * Gets the render target from the provide render surface. Eg if its a texture,
   * it will return the render target for the texture.
   * If its a render target, it will return the same render target.
   * @param renderSurface - the render surface to get the render target for
   * @returns the render target for the render surface
   */
  getRenderTarget(renderSurface) {
    if (renderSurface.isTexture) {
      renderSurface = renderSurface.source;
    }
    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
  }
  /**
   * Copies a render surface to another texture.
   *
   * NOTE:
   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer
   *
   * The following is not valid:
   * @example
   * const canvas = document.createElement('canvas')
   * canvas.width = 200;
   * canvas.height = 200;
   *
   * const ctx = canvas2.getContext('2d')!
   * ctx.fillStyle = 'red'
   * ctx.fillRect(0, 0, 200, 200);
   *
   * const texture = RenderTexture.create({
   *   width: 200,
   *   height: 200,
   * })
   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);
   *
   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});
   *
   * The best way to copy a canvas is to create a texture from it. Then render with that.
   *
   * Parsing in a RenderTarget canvas context (with a 2d context)
   * @param sourceRenderSurfaceTexture - the render surface to copy from
   * @param destinationTexture - the texture to copy to
   * @param originSrc - the origin of the copy
   * @param originSrc.x - the x origin of the copy
   * @param originSrc.y - the y origin of the copy
   * @param size - the size of the copy
   * @param size.width - the width of the copy
   * @param size.height - the height of the copy
   * @param originDest - the destination origin (top left to paste from!)
   * @param originDest.x - the x origin of the paste
   * @param originDest.y - the y origin of the paste
   */
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    if (originSrc.x < 0) {
      size.width += originSrc.x;
      originDest.x -= originSrc.x;
      originSrc.x = 0;
    }
    if (originSrc.y < 0) {
      size.height += originSrc.y;
      originDest.y -= originSrc.y;
      originSrc.y = 0;
    }
    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
    size.width = Math.min(size.width, pixelWidth - originSrc.x);
    size.height = Math.min(size.height, pixelHeight - originSrc.y);
    return this.adaptor.copyToTexture(
      sourceRenderSurfaceTexture,
      destinationTexture,
      originSrc,
      size,
      originDest
    );
  }
  /**
   * ensures that we have a depth stencil buffer available to render to
   * This is used by the mask system to make sure we have a stencil buffer.
   */
  ensureDepthStencil() {
    if (!this.renderTarget.stencil) {
      this.renderTarget.stencil = true;
      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
    }
  }
  /** nukes the render target system */
  destroy() {
    this._renderer = null;
    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
      if (renderTarget !== key) {
        renderTarget.destroy();
      }
    });
    this._renderSurfaceToRenderTargetHash.clear();
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  _initRenderTarget(renderSurface) {
    let renderTarget = null;
    if (_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_7__.CanvasSource.test(renderSurface)) {
      renderSurface = (0,_texture_utils_getCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_8__.getCanvasTexture)(renderSurface).source;
    }
    if (renderSurface instanceof _RenderTarget_mjs__WEBPACK_IMPORTED_MODULE_9__.RenderTarget) {
      renderTarget = renderSurface;
    } else if (renderSurface instanceof _texture_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_10__.TextureSource) {
      renderTarget = new _RenderTarget_mjs__WEBPACK_IMPORTED_MODULE_9__.RenderTarget({
        colorTextures: [renderSurface]
      });
      if (_texture_sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_7__.CanvasSource.test(renderSurface.source.resource)) {
        renderTarget.isRoot = true;
      }
      renderSurface.once("destroy", () => {
        renderTarget.destroy();
        this._renderSurfaceToRenderTargetHash.delete(renderSurface);
        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
        if (gpuRenderTarget) {
          this._gpuRenderTargetHash[renderTarget.uid] = null;
          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
        }
      });
    }
    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
    return renderTarget;
  }
  getGpuRenderTarget(renderTarget) {
    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
  }
  resetState() {
    this.renderTarget = null;
    this.renderSurface = null;
  }
}


//# sourceMappingURL=RenderTargetSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isRenderingToScreen: () => (/* binding */ isRenderingToScreen)
/* harmony export */ });

function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
}


//# sourceMappingURL=isRenderingToScreen.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/viewportFromFrame.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/viewportFromFrame.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   viewportFromFrame: () => (/* binding */ viewportFromFrame)
/* harmony export */ });
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");


"use strict";
const fullFrame = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 1, 1);
function viewportFromFrame(viewport, source, frame) {
  frame || (frame = fullFrame);
  const pixelWidth = source.pixelWidth;
  const pixelHeight = source.pixelHeight;
  viewport.x = frame.x * pixelWidth | 0;
  viewport.y = frame.y * pixelHeight | 0;
  viewport.width = frame.width * pixelWidth | 0;
  viewport.height = frame.height * pixelHeight | 0;
  return viewport;
}


//# sourceMappingURL=viewportFromFrame.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Shader: () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../gpu/shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");
/* harmony import */ var _gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");








"use strict";
class Shader extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(options) {
    super();
    /** A unique identifier for the shader */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("shader");
    /**
     * A record of the uniform groups and resources used by the shader.
     * This is used by WebGL renderer to sync uniform data.
     * @internal
     * @ignore
     */
    this._uniformBindMap = /* @__PURE__ */ Object.create(null);
    this._ownedBindGroups = [];
    let {
      gpuProgram,
      glProgram,
      groups,
      resources,
      compatibleRenderers,
      groupMap
    } = options;
    this.gpuProgram = gpuProgram;
    this.glProgram = glProgram;
    if (compatibleRenderers === void 0) {
      compatibleRenderers = 0;
      if (gpuProgram)
        compatibleRenderers |= _types_mjs__WEBPACK_IMPORTED_MODULE_2__.RendererType.WEBGPU;
      if (glProgram)
        compatibleRenderers |= _types_mjs__WEBPACK_IMPORTED_MODULE_2__.RendererType.WEBGL;
    }
    this.compatibleRenderers = compatibleRenderers;
    const nameHash = {};
    if (!resources && !groups) {
      resources = {};
    }
    if (resources && groups) {
      throw new Error("[Shader] Cannot have both resources and groups");
    } else if (!gpuProgram && groups && !groupMap) {
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    } else if (!gpuProgram && groups && groupMap) {
      for (const i in groupMap) {
        for (const j in groupMap[i]) {
          const uniformName = groupMap[i][j];
          nameHash[uniformName] = {
            group: i,
            binding: j,
            name: uniformName
          };
        }
      }
    } else if (gpuProgram && groups && !groupMap) {
      const groupData = gpuProgram.structsAndGroups.groups;
      groupMap = {};
      groupData.forEach((data) => {
        groupMap[data.group] = groupMap[data.group] || {};
        groupMap[data.group][data.binding] = data.name;
        nameHash[data.name] = data;
      });
    } else if (resources) {
      groups = {};
      groupMap = {};
      if (gpuProgram) {
        const groupData = gpuProgram.structsAndGroups.groups;
        groupData.forEach((data) => {
          groupMap[data.group] = groupMap[data.group] || {};
          groupMap[data.group][data.binding] = data.name;
          nameHash[data.name] = data;
        });
      }
      let bindTick = 0;
      for (const i in resources) {
        if (nameHash[i])
          continue;
        if (!groups[99]) {
          groups[99] = new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.BindGroup();
          this._ownedBindGroups.push(groups[99]);
        }
        nameHash[i] = { group: 99, binding: bindTick, name: i };
        groupMap[99] = groupMap[99] || {};
        groupMap[99][bindTick] = i;
        bindTick++;
      }
      for (const i in resources) {
        const name = i;
        let value = resources[i];
        if (!value.source && !value._resourceType) {
          value = new _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_4__.UniformGroup(value);
        }
        const data = nameHash[name];
        if (data) {
          if (!groups[data.group]) {
            groups[data.group] = new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.BindGroup();
            this._ownedBindGroups.push(groups[data.group]);
          }
          groups[data.group].setResource(value, data.binding);
        }
      }
    }
    this.groups = groups;
    this._uniformBindMap = groupMap;
    this.resources = this._buildResourceAccessor(groups, nameHash);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(name, groupIndex, bindIndex) {
    var _a, _b;
    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
    if (!this.groups[groupIndex]) {
      this.groups[groupIndex] = new _gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.BindGroup();
      this._ownedBindGroups.push(this.groups[groupIndex]);
    }
  }
  _buildResourceAccessor(groups, nameHash) {
    const uniformsOut = {};
    for (const i in nameHash) {
      const data = nameHash[i];
      Object.defineProperty(uniformsOut, data.name, {
        get() {
          return groups[data.group].getResource(data.binding);
        },
        set(value) {
          groups[data.group].setResource(value, data.binding);
        }
      });
    }
    return uniformsOut;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(destroyPrograms = false) {
    this.emit("destroy", this);
    if (destroyPrograms) {
      this.gpuProgram?.destroy();
      this.glProgram?.destroy();
    }
    this.gpuProgram = null;
    this.glProgram = null;
    this.removeAllListeners();
    this._uniformBindMap = null;
    this._ownedBindGroups.forEach((bindGroup) => {
      bindGroup.destroy();
    });
    this._ownedBindGroups = null;
    this.resources = null;
    this.groups = null;
  }
  static from(options) {
    const { gpu, gl, ...rest } = options;
    let gpuProgram;
    let glProgram;
    if (gpu) {
      gpuProgram = _gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_5__.GpuProgram.from(gpu);
    }
    if (gl) {
      glProgram = _gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_6__.GlProgram.from(gl);
    }
    return new Shader({
      gpuProgram,
      glProgram,
      ...rest
    });
  }
}


//# sourceMappingURL=Shader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UboSystem: () => (/* binding */ UboSystem)
/* harmony export */ });
/* harmony import */ var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/browser/unsafeEvalSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs");
/* harmony import */ var _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");




"use strict";
class UboSystem {
  constructor(adaptor) {
    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */
    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
    this._adaptor = adaptor;
    this._systemCheck();
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  _systemCheck() {
    if (!(0,_utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_0__.unsafeEvalSupported)()) {
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  }
  ensureUniformGroup(uniformGroup) {
    const uniformData = this.getUniformGroupData(uniformGroup);
    uniformGroup.buffer || (uniformGroup.buffer = new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer({
      data: new Float32Array(uniformData.layout.size / 4),
      usage: _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.UNIFORM | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.COPY_DST
    }));
  }
  getUniformGroupData(uniformGroup) {
    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
  }
  _initUniformGroup(uniformGroup) {
    const uniformGroupSignature = uniformGroup._signature;
    let uniformData = this._syncFunctionHash[uniformGroupSignature];
    if (!uniformData) {
      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);
      const layout = this._adaptor.createUboElements(elements);
      const syncFunction = this._generateUboSync(layout.uboElements);
      uniformData = this._syncFunctionHash[uniformGroupSignature] = {
        layout,
        syncFunction
      };
    }
    return this._syncFunctionHash[uniformGroupSignature];
  }
  _generateUboSync(uboElements) {
    return this._adaptor.generateUboSync(uboElements);
  }
  syncUniformGroup(uniformGroup, data, offset) {
    const uniformGroupData = this.getUniformGroupData(uniformGroup);
    uniformGroup.buffer || (uniformGroup.buffer = new _buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer({
      data: new Float32Array(uniformGroupData.layout.size / 4),
      usage: _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.UNIFORM | _buffer_const_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferUsage.COPY_DST
    }));
    let dataInt32 = null;
    if (!data) {
      data = uniformGroup.buffer.data;
      dataInt32 = uniformGroup.buffer.dataInt32;
    }
    offset || (offset = 0);
    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
    return true;
  }
  updateUniformGroup(uniformGroup) {
    if (uniformGroup.isStatic && !uniformGroup._dirtyId)
      return false;
    uniformGroup._dirtyId = 0;
    const synced = this.syncUniformGroup(uniformGroup);
    uniformGroup.buffer.update();
    return synced;
  }
  destroy() {
    this._syncFunctionHash = null;
  }
}


//# sourceMappingURL=UboSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UniformGroup: () => (/* binding */ UniformGroup)
/* harmony export */ });
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/createIdFromString.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs");
/* harmony import */ var _utils_getDefaultUniformValue_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/getDefaultUniformValue.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs");





"use strict";
const _UniformGroup = class _UniformGroup {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(uniformStructures, options) {
    /** used internally to know if a uniform group was used in the last render pass */
    this._touched = 0;
    /** a unique id for this uniform group used through the renderer */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.uid)("uniform");
    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */
    this._resourceType = "uniformGroup";
    /** the resource id used internally by the renderer to build bind group keys */
    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.uid)("resource");
    /** used ito identify if this is a uniform group */
    this.isUniformGroup = true;
    /**
     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU
     * @internal
     * @ignore
     */
    this._dirtyId = 0;
    // implementing the interface - UniformGroup are not destroyed
    this.destroyed = false;
    options = { ..._UniformGroup.defaultOptions, ...options };
    this.uniformStructures = uniformStructures;
    const uniforms = {};
    for (const i in uniformStructures) {
      const uniformData = uniformStructures[i];
      uniformData.name = i;
      uniformData.size = uniformData.size ?? 1;
      if (!_types_mjs__WEBPACK_IMPORTED_MODULE_1__.UNIFORM_TYPES_MAP[uniformData.type]) {
        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${_types_mjs__WEBPACK_IMPORTED_MODULE_1__.UNIFORM_TYPES_VALUES.join(", ")}`);
      }
      uniformData.value ?? (uniformData.value = (0,_utils_getDefaultUniformValue_mjs__WEBPACK_IMPORTED_MODULE_2__.getDefaultUniformValue)(uniformData.type, uniformData.size));
      uniforms[i] = uniformData.value;
    }
    this.uniforms = uniforms;
    this._dirtyId = 1;
    this.ubo = options.ubo;
    this.isStatic = options.isStatic;
    this._signature = (0,_utils_createIdFromString_mjs__WEBPACK_IMPORTED_MODULE_3__.createIdFromString)(Object.keys(uniforms).map(
      (i) => `${i}-${uniformStructures[i].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
/** The default options used by the uniform group. */
_UniformGroup.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: false,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: false
};
let UniformGroup = _UniformGroup;


//# sourceMappingURL=UniformGroup.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShaderStage: () => (/* binding */ ShaderStage)
/* harmony export */ });

var ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
  ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
  ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
  ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
  return ShaderStage2;
})(ShaderStage || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UNIFORM_TYPES_MAP: () => (/* binding */ UNIFORM_TYPES_MAP),
/* harmony export */   UNIFORM_TYPES_VALUES: () => (/* binding */ UNIFORM_TYPES_VALUES)
/* harmony export */ });

const UNIFORM_TYPES_VALUES = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>",
  "vec2<i32>",
  "vec3<i32>",
  "vec4<i32>"
];
const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
  acc[type] = true;
  return acc;
}, {});


//# sourceMappingURL=types.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUboSyncFunction: () => (/* binding */ createUboSyncFunction)
/* harmony export */ });
/* harmony import */ var _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniformParsers.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs");


"use strict";
function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let prev = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j = 0; j < _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniformParsers.length; j++) {
      const uniformParser = _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniformParsers[j];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `name = "${name}";`,
          `offset += ${offset - prev};`,
          _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniformParsers[j][parserCode] || _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniformParsers[j].ubo
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        offset = uboElement.offset / 4;
        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
      } else {
        const template = singleSettersMap[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "dataInt32",
    "offset",
    fragmentSrc
  );
}


//# sourceMappingURL=createUboSyncFunction.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDefaultUniformValue: () => (/* binding */ getDefaultUniformValue)
/* harmony export */ });

function getDefaultUniformValue(type, size) {
  switch (type) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size);
    case "vec3<f32>":
      return new Float32Array(3 * size);
    case "vec4<f32>":
      return new Float32Array(4 * size);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}


//# sourceMappingURL=getDefaultUniformValue.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uboSyncFunctionsSTD40: () => (/* binding */ uboSyncFunctionsSTD40),
/* harmony export */   uboSyncFunctionsWGSL: () => (/* binding */ uboSyncFunctionsWGSL)
/* harmony export */ });

function loopMatrix(col, row) {
  const total = col * row;
  return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
}
const uboSyncFunctionsSTD40 = {
  f32: `
        data[offset] = v;`,
  i32: `
        dataInt32[offset] = v;`,
  "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
  "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
  "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
  "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
  "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
  "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
  "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
  "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
  "mat3x2<f32>": loopMatrix(3, 2),
  "mat4x2<f32>": loopMatrix(4, 2),
  "mat2x3<f32>": loopMatrix(2, 3),
  "mat4x3<f32>": loopMatrix(4, 3),
  "mat2x4<f32>": loopMatrix(2, 4),
  "mat3x4<f32>": loopMatrix(3, 4)
};
const uboSyncFunctionsWGSL = {
  ...uboSyncFunctionsSTD40,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
};


//# sourceMappingURL=uboSyncFunctions.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uniformParsers: () => (/* binding */ uniformParsers)
/* harmony export */ });

const uniformParsers = [
  // uploading pixi matrix object to mat3
  {
    type: "mat3x3<f32>",
    test: (data) => {
      const value = data.value;
      return value.a !== void 0;
    },
    ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
    uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
  },
  // uploading a pixi rectangle as a vec4
  {
    type: "vec4<f32>",
    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
  },
  // uploading a pixi point as a vec2
  {
    type: "vec2<f32>",
    test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
  },
  // uploading a pixi color as a vec4
  {
    type: "vec4<f32>",
    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
  },
  // uploading a pixi color as a vec3
  {
    type: "vec3<f32>",
    test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
  }
];


//# sourceMappingURL=uniformParsers.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HelloSystem: () => (/* binding */ HelloSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_sayHello_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/sayHello.mjs */ "./node_modules/pixi.js/lib/utils/sayHello.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");




"use strict";
class HelloSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  /**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */
  init(options) {
    if (options.hello) {
      let name = this._renderer.name;
      if (this._renderer.type === _types_mjs__WEBPACK_IMPORTED_MODULE_0__.RendererType.WEBGL) {
        name += ` ${this._renderer.context.webGLVersion}`;
      }
      (0,_utils_sayHello_mjs__WEBPACK_IMPORTED_MODULE_1__.sayHello)(name);
    }
  }
}
/** @ignore */
HelloSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.CanvasSystem
  ],
  name: "hello",
  priority: -2
};
/** The default options for the system. */
HelloSystem.defaultOptions = {
  /** {@link WebGLOptions.hello} */
  hello: false
};


//# sourceMappingURL=HelloSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   State: () => (/* binding */ State)
/* harmony export */ });

const blendModeIds = {
  normal: 0,
  add: 1,
  multiply: 2,
  screen: 3,
  overlay: 4,
  erase: 5,
  "normal-npm": 6,
  "add-npm": 7,
  "screen-npm": 8,
  min: 9,
  max: 10
};
const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _State = class _State {
  constructor() {
    this.data = 0;
    this.blendMode = "normal";
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND) !== value) {
      this.data ^= 1 << BLEND;
    }
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET) !== value) {
      this.data ^= 1 << OFFSET;
    }
  }
  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
  set cullMode(value) {
    if (value === "none") {
      this.culling = false;
      return;
    }
    this.culling = true;
    this.clockwiseFrontFace = value === "front";
  }
  get cullMode() {
    if (!this.culling) {
      return "none";
    }
    return this.clockwiseFrontFace ? "front" : "back";
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING) !== value) {
      this.data ^= 1 << CULLING;
    }
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING) !== value) {
      this.data ^= 1 << WINDING;
    }
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default 'normal'
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== "none";
    this._blendMode = value;
    this._blendModeId = blendModeIds[value] || 0;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  /**
   * A quickly getting an instance of a State that is configured for 2d rendering.
   * @returns a new State with values set for 2d rendering
   */
  static for2d() {
    const state = new _State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
};
_State.default2d = _State.for2d();
let State = _State;


//# sourceMappingURL=State.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BLEND_TO_NPM: () => (/* binding */ BLEND_TO_NPM),
/* harmony export */   STENCIL_MODES: () => (/* binding */ STENCIL_MODES)
/* harmony export */ });

const BLEND_TO_NPM = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
  STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
  return STENCIL_MODES2;
})(STENCIL_MODES || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAdjustedBlendModeBlend: () => (/* binding */ getAdjustedBlendModeBlend)
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs");


"use strict";
function getAdjustedBlendModeBlend(blendMode, textureSource) {
  if (textureSource.alphaMode === "no-premultiply-alpha") {
    return _const_mjs__WEBPACK_IMPORTED_MODULE_0__.BLEND_TO_NPM[blendMode] || blendMode;
  }
  return blendMode;
}


//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractRenderer: () => (/* binding */ AbstractRenderer)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _environment_autoDetectEnvironment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../environment/autoDetectEnvironment.mjs */ "./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs");
/* harmony import */ var _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../scene/container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../utils/browser/unsafeEvalSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _gl_const_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../gl/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs");
/* harmony import */ var _SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SystemRunner.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");










"use strict";
const defaultRunners = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "resetState",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
];
const _AbstractRenderer = class _AbstractRenderer extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(config) {
    super();
    this.runners = /* @__PURE__ */ Object.create(null);
    this.renderPipes = /* @__PURE__ */ Object.create(null);
    this._initOptions = {};
    this._systemsHash = /* @__PURE__ */ Object.create(null);
    this.type = config.type;
    this.name = config.name;
    this.config = config;
    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
    this._addRunners(...combinedRunners);
    this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(options = {}) {
    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
    await (0,_environment_autoDetectEnvironment_mjs__WEBPACK_IMPORTED_MODULE_1__.loadEnvironmentExtensions)(skip);
    this._addSystems(this.config.systems);
    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const systemName in this._systemsHash) {
      const system = this._systemsHash[systemName];
      const defaultSystemOptions = system.constructor.defaultOptions;
      options = { ...defaultSystemOptions, ...options };
    }
    options = { ..._AbstractRenderer.defaultOptions, ...options };
    this._roundPixels = options.roundPixels ? 1 : 0;
    for (let i = 0; i < this.runners.init.items.length; i++) {
      await this.runners.init.items[i].init(options);
    }
    this._initOptions = options;
  }
  render(args, deprecated) {
    let options = args;
    if (options instanceof _scene_container_Container_mjs__WEBPACK_IMPORTED_MODULE_2__.Container) {
      options = { container: options };
      if (deprecated) {
        (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_3__.v8_0_0, "passing a second argument is deprecated, please use render options instead");
        options.target = deprecated.renderTexture;
      }
    }
    options.target || (options.target = this.view.renderTarget);
    if (options.target === this.view.renderTarget) {
      this._lastObjectRendered = options.container;
      options.clearColor ?? (options.clearColor = this.background.colorRgba);
      options.clear ?? (options.clear = this.background.clearBeforeRender);
    }
    if (options.clearColor) {
      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
      options.clearColor = isRGBAArray ? options.clearColor : _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__.Color.shared.setValue(options.clearColor).toArray();
    }
    if (!options.transform) {
      options.container.updateLocalTransform();
      options.transform = options.container.localTransform;
    }
    options.container.enableRenderGroup();
    this.runners.prerender.emit(options);
    this.runners.renderStart.emit(options);
    this.runners.render.emit(options);
    this.runners.renderEnd.emit(options);
    this.runners.postrender.emit(options);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(desiredScreenWidth, desiredScreenHeight, resolution) {
    const previousResolution = this.view.resolution;
    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
    this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
    if (resolution !== void 0 && resolution !== previousResolution) {
      this.runners.resolutionChange.emit(resolution);
    }
  }
  clear(options = {}) {
    const renderer = this;
    options.target || (options.target = renderer.renderTarget.renderTarget);
    options.clearColor || (options.clearColor = this.background.colorRgba);
    options.clear ?? (options.clear = _gl_const_mjs__WEBPACK_IMPORTED_MODULE_5__.CLEAR.ALL);
    const { clear, clearColor, target } = options;
    _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__.Color.shared.setValue(clearColor ?? this.background.colorRgba);
    renderer.renderTarget.clear(target, clear, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__.Color.shared.toArray());
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(value) {
    this.view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @member {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    const renderer = this;
    return renderer.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new _SystemRunner_mjs__WEBPACK_IMPORTED_MODULE_6__.SystemRunner(runnerId);
    });
  }
  _addSystems(systems) {
    let i;
    for (i in systems) {
      const val = systems[i];
      this._addSystem(val.value, val.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  }
  _addPipes(pipes, pipeAdaptors) {
    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
      acc[adaptor.name] = adaptor.value;
      return acc;
    }, {});
    pipes.forEach((pipe) => {
      const PipeClass = pipe.value;
      const name = pipe.name;
      const Adaptor = adaptors[name];
      this.renderPipes[name] = new PipeClass(
        this,
        Adaptor ? new Adaptor() : null
      );
    });
  }
  destroy(options = false) {
    this.runners.destroy.items.reverse();
    this.runners.destroy.emit(options);
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = null;
    this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(options) {
    return this.textureGenerator.generateTexture(options);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!(0,_utils_browser_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_7__.unsafeEvalSupported)()) {
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  }
  /**
   * Resets the rendering state of the renderer.
   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
   * render will reset all internal caches and ensure it executes correctly.
   *
   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
   * ```js
   * // Reset Three.js state
   * threeRenderer.resetState();
   *
   * // Render a Three.js scene
   * threeRenderer.render(threeScene, threeCamera);
   *
   * // Reset PixiJS state since Three.js modified the WebGL context
   * pixiRenderer.resetState();
   *
   * // Now render Pixi content
   * pixiRenderer.render(pixiScene);
   * ```
   */
  resetState() {
    this.runners.resetState.emit();
  }
};
/** The default options for the renderer. */
_AbstractRenderer.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: false,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: false
};
let AbstractRenderer = _AbstractRenderer;


//# sourceMappingURL=AbstractRenderer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SharedRenderPipes: () => (/* binding */ SharedRenderPipes),
/* harmony export */   SharedSystems: () => (/* binding */ SharedSystems)
/* harmony export */ });
/* harmony import */ var _scene_container_CustomRenderPipe_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../../../scene/container/CustomRenderPipe.mjs */ "./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs");
/* harmony import */ var _scene_container_RenderGroupPipe_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../../scene/container/RenderGroupPipe.mjs */ "./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs");
/* harmony import */ var _scene_container_RenderGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../scene/container/RenderGroupSystem.mjs */ "./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs");
/* harmony import */ var _scene_sprite_SpritePipe_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../../scene/sprite/SpritePipe.mjs */ "./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs");
/* harmony import */ var _utils_global_globalHooks_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../utils/global/globalHooks.mjs */ "./node_modules/pixi.js/lib/utils/global/globalHooks.mjs");
/* harmony import */ var _batcher_shared_BatcherPipe_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../batcher/shared/BatcherPipe.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs");
/* harmony import */ var _mask_alpha_AlphaMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../mask/alpha/AlphaMaskPipe.mjs */ "./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs");
/* harmony import */ var _mask_color_ColorMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../mask/color/ColorMaskPipe.mjs */ "./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs");
/* harmony import */ var _mask_stencil_StencilMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../mask/stencil/StencilMaskPipe.mjs */ "./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs");
/* harmony import */ var _background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../background/BackgroundSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs");
/* harmony import */ var _blendModes_BlendModePipe_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../blendModes/BlendModePipe.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs");
/* harmony import */ var _extract_ExtractSystem_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../extract/ExtractSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs");
/* harmony import */ var _extract_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extract/GenerateTextureSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs");
/* harmony import */ var _renderTarget_GlobalUniformSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderTarget/GlobalUniformSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs");
/* harmony import */ var _SchedulerSystem_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../SchedulerSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs");
/* harmony import */ var _startup_HelloSystem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../startup/HelloSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs");
/* harmony import */ var _texture_RenderableGCSystem_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../texture/RenderableGCSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs");
/* harmony import */ var _texture_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../texture/TextureGCSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs");
/* harmony import */ var _view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/ViewSystem.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs");




















"use strict";
const SharedSystems = [
  _background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.BackgroundSystem,
  _renderTarget_GlobalUniformSystem_mjs__WEBPACK_IMPORTED_MODULE_1__.GlobalUniformSystem,
  _startup_HelloSystem_mjs__WEBPACK_IMPORTED_MODULE_2__.HelloSystem,
  _view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_3__.ViewSystem,
  _scene_container_RenderGroupSystem_mjs__WEBPACK_IMPORTED_MODULE_4__.RenderGroupSystem,
  _texture_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_5__.TextureGCSystem,
  _extract_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_6__.GenerateTextureSystem,
  _extract_ExtractSystem_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtractSystem,
  _utils_global_globalHooks_mjs__WEBPACK_IMPORTED_MODULE_8__.RendererInitHook,
  _texture_RenderableGCSystem_mjs__WEBPACK_IMPORTED_MODULE_9__.RenderableGCSystem,
  _SchedulerSystem_mjs__WEBPACK_IMPORTED_MODULE_10__.SchedulerSystem
];
const SharedRenderPipes = [
  _blendModes_BlendModePipe_mjs__WEBPACK_IMPORTED_MODULE_11__.BlendModePipe,
  _batcher_shared_BatcherPipe_mjs__WEBPACK_IMPORTED_MODULE_12__.BatcherPipe,
  _scene_sprite_SpritePipe_mjs__WEBPACK_IMPORTED_MODULE_13__.SpritePipe,
  _scene_container_RenderGroupPipe_mjs__WEBPACK_IMPORTED_MODULE_14__.RenderGroupPipe,
  _mask_alpha_AlphaMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_15__.AlphaMaskPipe,
  _mask_stencil_StencilMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_16__.StencilMaskPipe,
  _mask_color_ColorMaskPipe_mjs__WEBPACK_IMPORTED_MODULE_17__.ColorMaskPipe,
  _scene_container_CustomRenderPipe_mjs__WEBPACK_IMPORTED_MODULE_18__.CustomRenderPipe
];


//# sourceMappingURL=SharedSystems.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SystemRunner: () => (/* binding */ SystemRunner)
/* harmony export */ });

class SystemRunner {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(name) {
    this.items = [];
    this._name = name;
  }
  /* jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /* jsdoc/check-param-names */
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    const { name, items } = this;
    for (let i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(item) {
    if (item[this._name]) {
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.items.splice(index, 1);
    }
    return this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(item) {
    return this.items.indexOf(item) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    this.items.length = 0;
    return this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}


//# sourceMappingURL=SystemRunner.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasPool: () => (/* binding */ CanvasPool),
/* harmony export */   CanvasPoolClass: () => (/* binding */ CanvasPoolClass)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../maths/misc/pow2.mjs */ "./node_modules/pixi.js/lib/maths/misc/pow2.mjs");



"use strict";
class CanvasPoolClass {
  constructor(canvasOptions) {
    this._canvasPool = /* @__PURE__ */ Object.create(null);
    this.canvasOptions = canvasOptions || {};
    this.enableFullScreen = false;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(pixelWidth, pixelHeight) {
    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().createCanvas();
    canvas.width = pixelWidth;
    canvas.height = pixelHeight;
    const context = canvas.getContext("2d");
    return { canvas, context };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(minWidth);
    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(minHeight);
    const key = (minWidth << 17) + (minHeight << 1);
    if (!this._canvasPool[key]) {
      this._canvasPool[key] = [];
    }
    let canvasAndContext = this._canvasPool[key].pop();
    if (!canvasAndContext) {
      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
    }
    return canvasAndContext;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(canvasAndContext) {
    const canvas = canvasAndContext.canvas;
    const { width, height } = canvas;
    const key = (width << 17) + (height << 1);
    canvasAndContext.context.clearRect(0, 0, width, height);
    this._canvasPool[key].push(canvasAndContext);
  }
  clear() {
    this._canvasPool = {};
  }
}
const CanvasPool = new CanvasPoolClass();


//# sourceMappingURL=CanvasPool.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderTexture: () => (/* binding */ RenderTexture)
/* harmony export */ });
/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");



"use strict";
class RenderTexture extends _Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture {
  static create(options) {
    return new RenderTexture({
      source: new _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureSource(options)
    });
  }
  /**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */
  resize(width, height, resolution) {
    this.source.resize(width, height, resolution);
    return this;
  }
}


//# sourceMappingURL=RenderTexture.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderableGCSystem: () => (/* binding */ RenderableGCSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_data_clean_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/data/clean.mjs */ "./node_modules/pixi.js/lib/utils/data/clean.mjs");



"use strict";
let renderableGCTick = 0;
const _RenderableGCSystem = class _RenderableGCSystem {
  /**
   * Creates a new RenderableGCSystem instance.
   * @param renderer - The renderer this garbage collection system works for
   */
  constructor(renderer) {
    /** Array of renderables being tracked for garbage collection */
    this._managedRenderables = [];
    /** Array of hash objects being tracked for cleanup */
    this._managedHashes = [];
    /** Array of arrays being tracked for cleanup */
    this._managedArrays = [];
    this._renderer = renderer;
  }
  /**
   * Initializes the garbage collection system with the provided options.
   * @param options - Configuration options for the renderer
   */
  init(options) {
    options = { ..._RenderableGCSystem.defaultOptions, ...options };
    this.maxUnusedTime = options.renderableGCMaxUnusedTime;
    this._frequency = options.renderableGCFrequency;
    this.enabled = options.renderableGCActive;
  }
  /**
   * Gets whether the garbage collection system is currently enabled.
   * @returns True if GC is enabled, false otherwise
   */
  get enabled() {
    return !!this._handler;
  }
  /**
   * Enables or disables the garbage collection system.
   * When enabled, schedules periodic cleanup of resources.
   * When disabled, cancels all scheduled cleanups.
   */
  set enabled(value) {
    if (this.enabled === value)
      return;
    if (value) {
      this._handler = this._renderer.scheduler.repeat(
        () => this.run(),
        this._frequency,
        false
      );
      this._hashHandler = this._renderer.scheduler.repeat(
        () => {
          for (const hash of this._managedHashes) {
            hash.context[hash.hash] = (0,_utils_data_clean_mjs__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(hash.context[hash.hash]);
          }
        },
        this._frequency
      );
      this._arrayHandler = this._renderer.scheduler.repeat(
        () => {
          for (const array of this._managedArrays) {
            (0,_utils_data_clean_mjs__WEBPACK_IMPORTED_MODULE_0__.cleanArray)(array.context[array.hash]);
          }
        },
        this._frequency
      );
    } else {
      this._renderer.scheduler.cancel(this._handler);
      this._renderer.scheduler.cancel(this._hashHandler);
      this._renderer.scheduler.cancel(this._arrayHandler);
    }
  }
  /**
   * Adds a hash table to be managed by the garbage collector.
   * @param context - The object containing the hash table
   * @param hash - The property name of the hash table
   */
  addManagedHash(context, hash) {
    this._managedHashes.push({ context, hash });
  }
  /**
   * Adds an array to be managed by the garbage collector.
   * @param context - The object containing the array
   * @param hash - The property name of the array
   */
  addManagedArray(context, hash) {
    this._managedArrays.push({ context, hash });
  }
  /**
   * Updates the GC timestamp and tracking before rendering.
   * @param options - The render options
   * @param options.container - The container to render
   */
  prerender({
    container
  }) {
    this._now = performance.now();
    container.renderGroup.gcTick = renderableGCTick++;
    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
  }
  /**
   * Starts tracking a renderable for garbage collection.
   * @param renderable - The renderable to track
   */
  addRenderable(renderable) {
    if (!this.enabled)
      return;
    if (renderable._lastUsed === -1) {
      this._managedRenderables.push(renderable);
      renderable.once("destroyed", this._removeRenderable, this);
    }
    renderable._lastUsed = this._now;
  }
  /**
   * Performs garbage collection by cleaning up unused renderables.
   * Removes renderables that haven't been used for longer than maxUnusedTime.
   */
  run() {
    const now = this._now;
    const managedRenderables = this._managedRenderables;
    const renderPipes = this._renderer.renderPipes;
    let offset = 0;
    for (let i = 0; i < managedRenderables.length; i++) {
      const renderable = managedRenderables[i];
      if (renderable === null) {
        offset++;
        continue;
      }
      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;
      if ((renderGroup?.gcTick ?? 0) === currentTick) {
        renderable._lastUsed = now;
      }
      if (now - renderable._lastUsed > this.maxUnusedTime) {
        if (!renderable.destroyed) {
          const rp = renderPipes;
          if (renderGroup)
            renderGroup.structureDidChange = true;
          rp[renderable.renderPipeId].destroyRenderable(renderable);
        }
        renderable._lastUsed = -1;
        offset++;
        renderable.off("destroyed", this._removeRenderable, this);
      } else {
        managedRenderables[i - offset] = renderable;
      }
    }
    managedRenderables.length -= offset;
  }
  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
  destroy() {
    this.enabled = false;
    this._renderer = null;
    this._managedRenderables.length = 0;
    this._managedHashes.length = 0;
    this._managedArrays.length = 0;
  }
  /**
   * Removes a renderable from being tracked when it's destroyed.
   * @param renderable - The renderable to stop tracking
   */
  _removeRenderable(renderable) {
    const index = this._managedRenderables.indexOf(renderable);
    if (index >= 0) {
      renderable.off("destroyed", this._removeRenderable, this);
      this._managedRenderables[index] = null;
    }
  }
  /**
   * Updates the GC tick counter for a render group and its children.
   * @param renderGroup - The render group to update
   * @param gcTick - The new tick value
   */
  _updateInstructionGCTick(renderGroup, gcTick) {
    renderGroup.instructionSet.gcTick = gcTick;
    for (const child of renderGroup.renderGroupChildren) {
      this._updateInstructionGCTick(child, gcTick);
    }
  }
};
/**
 * Extension metadata for registering this system with the renderer.
 * @ignore
 */
_RenderableGCSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem
  ],
  name: "renderableGC",
  priority: 0
};
/**
 * Default configuration options for the garbage collection system.
 * These can be overridden when initializing the renderer.
 */
_RenderableGCSystem.defaultOptions = {
  /** Enable/disable the garbage collector */
  renderableGCActive: true,
  /** Time in ms before an unused resource is collected (default 1 minute) */
  renderableGCMaxUnusedTime: 6e4,
  /** How often to run garbage collection in ms (default 30 seconds) */
  renderableGCFrequency: 3e4
};
let RenderableGCSystem = _RenderableGCSystem;


//# sourceMappingURL=RenderableGCSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Texture: () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../maths/matrix/groupD8.mjs */ "./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _utils_misc_NOOP_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../utils/misc/NOOP.mjs */ "./node_modules/pixi.js/lib/utils/misc/NOOP.mjs");
/* harmony import */ var _sources_BufferImageSource_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sources/BufferImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs");
/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextureMatrix.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs");










"use strict";
class Texture extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {rendering.TextureOptions} options - Options for the texture
   */
  constructor({
    source,
    label,
    frame,
    orig,
    trim,
    defaultAnchor,
    defaultBorders,
    rotate,
    dynamic
  } = {}) {
    super();
    /** unique id for this texture */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("texture");
    /** A uvs object based on the given frame and the texture source */
    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     */
    this.frame = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
    /**
     * Does this Texture have any frame data assigned to it?
     *
     * This mode is enabled automatically if no frame was passed inside constructor.
     *
     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.
     *
     * Beware, after loading or resize of baseTexture event can fired two times!
     * If you want more control, subscribe on baseTexture itself.
     * @example
     * texture.on('update', () => {});
     */
    this.noFrame = false;
    /**
     * Set to true if you plan on modifying the uvs of this texture.
     * When this is the case, sprites and other objects using the texture will
     * make sure to listen for changes to the uvs and update their vertices accordingly.
     */
    this.dynamic = false;
    /** is it a texture? yes! used for type checking */
    this.isTexture = true;
    this.label = label;
    this.source = source?.source ?? new _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__.TextureSource();
    this.noFrame = !frame;
    if (frame) {
      this.frame.copyFrom(frame);
    } else {
      const { width, height } = this._source;
      this.frame.width = width;
      this.frame.height = height;
    }
    this.orig = orig || this.frame;
    this.trim = trim;
    this.rotate = rotate ?? 0;
    this.defaultAnchor = defaultAnchor;
    this.defaultBorders = defaultBorders;
    this.destroyed = false;
    this.dynamic = dynamic || false;
    this.updateUvs();
  }
  set source(value) {
    if (this._source) {
      this._source.off("resize", this.update, this);
    }
    this._source = value;
    value.on("resize", this.update, this);
    this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    if (!this._textureMatrix) {
      this._textureMatrix = new _TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_4__.TextureMatrix(this);
    }
    return this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs, frame } = this;
    const { width, height } = this._source;
    const nX = frame.x / width;
    const nY = frame.y / height;
    const nW = frame.width / width;
    const nH = frame.height / height;
    let rotate = this.rotate;
    if (rotate) {
      const w2 = nW / 2;
      const h2 = nH / 2;
      const cX = nX + w2;
      const cY = nY + h2;
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.add(rotate, _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.NW);
      uvs.x0 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uX(rotate);
      uvs.y0 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uY(rotate);
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.add(rotate, 2);
      uvs.x1 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uX(rotate);
      uvs.y1 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uY(rotate);
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.add(rotate, 2);
      uvs.x2 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uX(rotate);
      uvs.y2 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uY(rotate);
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.add(rotate, 2);
      uvs.x3 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uX(rotate);
      uvs.y3 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8.uY(rotate);
    } else {
      uvs.x0 = nX;
      uvs.y0 = nY;
      uvs.x1 = nX + nW;
      uvs.y1 = nY;
      uvs.x2 = nX + nW;
      uvs.y2 = nY + nH;
      uvs.x3 = nX;
      uvs.y3 = nY + nH;
    }
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(destroySource = false) {
    if (this._source) {
      if (destroySource) {
        this._source.destroy();
        this._source = null;
      }
    }
    this._textureMatrix = null;
    this.destroyed = true;
    this.emit("destroy", this);
    this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    if (this.noFrame) {
      this.frame.width = this._source.width;
      this.frame.height = this._source.height;
    }
    this.updateUvs();
    this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_6__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_6__.v8_0_0, "Texture.baseTexture is now Texture.source");
    return this._source;
  }
}
Texture.EMPTY = new Texture({
  label: "EMPTY",
  source: new _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__.TextureSource({
    label: "EMPTY"
  })
});
Texture.EMPTY.destroy = _utils_misc_NOOP_mjs__WEBPACK_IMPORTED_MODULE_7__.NOOP;
Texture.WHITE = new Texture({
  source: new _sources_BufferImageSource_mjs__WEBPACK_IMPORTED_MODULE_8__.BufferImageSource({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
Texture.WHITE.destroy = _utils_misc_NOOP_mjs__WEBPACK_IMPORTED_MODULE_7__.NOOP;


//# sourceMappingURL=Texture.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureGCSystem: () => (/* binding */ TextureGCSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const _TextureGCSystem = class _TextureGCSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this._renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
  }
  init(options) {
    options = { ..._TextureGCSystem.defaultOptions, ...options };
    this.checkCountMax = options.textureGCCheckCountMax;
    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
    this.active = options.textureGCActive;
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  postrender() {
    if (!this._renderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (!this.active)
      return;
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  run() {
    const managedTextures = this._renderer.texture.managedTextures;
    for (let i = 0; i < managedTextures.length; i++) {
      const texture = managedTextures[i];
      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
        texture._touched = -1;
        texture.unload();
      }
    }
  }
  destroy() {
    this._renderer = null;
  }
};
/** @ignore */
_TextureGCSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUSystem
  ],
  name: "textureGC"
};
/** default options for the TextureGCSystem */
_TextureGCSystem.defaultOptions = {
  /**
   * If set to true, this will enable the garbage collector on the GPU.
   * @default true
   */
  textureGCActive: true,
  /**
   * @deprecated since 8.3.0
   * @see {@link TextureGCSystem.textureGCMaxIdle}
   */
  textureGCAMaxIdle: null,
  /**
   * The maximum idle frames before a texture is destroyed by garbage collection.
   * @default 60 * 60
   */
  textureGCMaxIdle: 60 * 60,
  /**
   * Frames between two garbage collections.
   * @default 600
   */
  textureGCCheckCountMax: 600
};
let TextureGCSystem = _TextureGCSystem;


//# sourceMappingURL=TextureGCSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureMatrix: () => (/* binding */ TextureMatrix)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");


"use strict";
const tempMat = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
class TextureMatrix {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(texture, clampMargin) {
    this.mapCoord = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    if (typeof clampMargin === "undefined") {
      this.clampMargin = texture.width < 10 ? 0 : 0.5;
    } else {
      this.clampMargin = clampMargin;
    }
    this.isSimple = false;
    this.texture = texture;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this.texture === value)
      return;
    this._texture?.removeListener("update", this.update, this);
    this._texture = value;
    this._texture.addListener("update", this.update, this);
    this.update();
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i = 0; i < uvs.length; i += 2) {
      const x = uvs[i];
      const y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const tex = this._texture;
    this._updateID++;
    const uvs = tex.uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(
        orig.width / trim.width,
        0,
        0,
        orig.height / trim.height,
        -trim.x / trim.width,
        -trim.y / trim.height
      );
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.source;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase._resolution;
    const offset = this.clampOffset / texBase._resolution;
    frame[0] = (tex.frame.x + margin + offset) / texBase.width;
    frame[1] = (tex.frame.y + margin + offset) / texBase.height;
    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}


//# sourceMappingURL=TextureMatrix.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TexturePool: () => (/* binding */ TexturePool),
/* harmony export */   TexturePoolClass: () => (/* binding */ TexturePoolClass)
/* harmony export */ });
/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../maths/misc/pow2.mjs */ "./node_modules/pixi.js/lib/maths/misc/pow2.mjs");
/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");




"use strict";
let count = 0;
class TexturePoolClass {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
   */
  constructor(textureOptions) {
    this._poolKeyHash = /* @__PURE__ */ Object.create(null);
    this._texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   * @param antialias
   */
  createTexture(pixelWidth, pixelHeight, antialias) {
    const textureSource = new _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.TextureSource({
      ...this.textureOptions,
      width: pixelWidth,
      height: pixelHeight,
      resolution: 1,
      antialias,
      autoGarbageCollect: false
    });
    return new _Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture({
      source: textureSource,
      label: `texturePool_${count++}`
    });
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param frameWidth - The minimum width of the render texture.
   * @param frameHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param antialias
   * @returns The new render texture.
   */
  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
    po2Width = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_2__.nextPow2)(po2Width);
    po2Height = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_2__.nextPow2)(po2Height);
    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
    if (!this._texturePool[key]) {
      this._texturePool[key] = [];
    }
    let texture = this._texturePool[key].pop();
    if (!texture) {
      texture = this.createTexture(po2Width, po2Height, antialias);
    }
    texture.source._resolution = resolution;
    texture.source.width = po2Width / resolution;
    texture.source.height = po2Height / resolution;
    texture.source.pixelWidth = po2Width;
    texture.source.pixelHeight = po2Height;
    texture.frame.x = 0;
    texture.frame.y = 0;
    texture.frame.width = frameWidth;
    texture.frame.height = frameHeight;
    texture.updateUvs();
    this._poolKeyHash[texture.uid] = key;
    return texture;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   * @param texture - The texture to check what size it is.
   * @param antialias - Whether to use antialias.
   * @returns A texture that is a power of two
   */
  getSameSizeTexture(texture, antialias = false) {
    const source = texture.source;
    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);
  }
  /**
   * Place a render texture back into the pool.
   * @param renderTexture - The renderTexture to free
   */
  returnTexture(renderTexture) {
    const key = this._poolKeyHash[renderTexture.uid];
    this._texturePool[key].push(renderTexture);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i in this._texturePool) {
        const textures = this._texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this._texturePool = {};
  }
}
const TexturePool = new TexturePoolClass();


//# sourceMappingURL=TexturePool.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureStyle: () => (/* binding */ TextureStyle)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");




"use strict";
const idHash = /* @__PURE__ */ Object.create(null);
function createResourceIdFromString(value) {
  const id = idHash[value];
  if (id === void 0) {
    idHash[value] = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
  }
  return id;
}
const _TextureStyle = class _TextureStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param options - options for the style
   */
  constructor(options = {}) {
    super();
    this._resourceType = "textureSampler";
    this._touched = 0;
    /**
     * Specifies the maximum anisotropy value clamp used by the sampler.
     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range
     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will
     * be clamped to the maximum value that the platform supports.
     * @internal
     * @ignore
     */
    this._maxAnisotropy = 1;
    /**
     * Has the style been destroyed?
     * @readonly
     */
    this.destroyed = false;
    options = { ..._TextureStyle.defaultOptions, ...options };
    this.addressMode = options.addressMode;
    this.addressModeU = options.addressModeU ?? this.addressModeU;
    this.addressModeV = options.addressModeV ?? this.addressModeV;
    this.addressModeW = options.addressModeW ?? this.addressModeW;
    this.scaleMode = options.scaleMode;
    this.magFilter = options.magFilter ?? this.magFilter;
    this.minFilter = options.minFilter ?? this.minFilter;
    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
    this.lodMinClamp = options.lodMinClamp;
    this.lodMaxClamp = options.lodMaxClamp;
    this.compare = options.compare;
    this.maxAnisotropy = options.maxAnisotropy ?? 1;
  }
  set addressMode(value) {
    this.addressModeU = value;
    this.addressModeV = value;
    this.addressModeW = value;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(value) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
    this.addressMode = value;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(value) {
    this.magFilter = value;
    this.minFilter = value;
    this.mipmapFilter = value;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(value) {
    this._maxAnisotropy = Math.min(value, 16);
    if (this._maxAnisotropy > 1) {
      this.scaleMode = "linear";
    }
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this.emit("change", this);
    this._sharedResourceId = null;
  }
  _generateResourceId() {
    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    this._sharedResourceId = createResourceIdFromString(bigKey);
    return this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = true;
    this.emit("destroy", this);
    this.emit("change", this);
    this.removeAllListeners();
  }
};
/** default options for the style */
_TextureStyle.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let TextureStyle = _TextureStyle;


//# sourceMappingURL=TextureStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureUvs: () => (/* binding */ TextureUvs)
/* harmony export */ });
/* harmony import */ var _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/matrix/groupD8.mjs */ "./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs");


"use strict";
class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  /**
   * Sets the texture Uvs based on the given frame information.
   * @protected
   * @param frame - The frame of the texture
   * @param baseFrame - The base frame of the texture
   * @param rotate - Rotation of frame, see {@link groupD8}
   */
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw;
      const h2 = frame.height / 2 / th;
      const cX = frame.x / tw + w2;
      const cY = frame.y / th + h2;
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.NW);
      this.x0 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y0 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, 2);
      this.x1 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y1 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, 2);
      this.x2 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y2 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
      rotate = _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, 2);
      this.x3 = cX + w2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y3 = cY + h2 * _maths_matrix_groupD8_mjs__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[pixi.js/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}


//# sourceMappingURL=TextureUvs.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEPRECATED_SCALE_MODES: () => (/* binding */ DEPRECATED_SCALE_MODES),
/* harmony export */   DEPRECATED_WRAP_MODES: () => (/* binding */ DEPRECATED_WRAP_MODES),
/* harmony export */   MSAA_QUALITY: () => (/* binding */ MSAA_QUALITY),
/* harmony export */   SCALE_MODES: () => (/* binding */ SCALE_MODES),
/* harmony export */   WRAP_MODES: () => (/* binding */ WRAP_MODES)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");


"use strict";
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var DEPRECATED_WRAP_MODES = /* @__PURE__ */ ((DEPRECATED_WRAP_MODES2) => {
  DEPRECATED_WRAP_MODES2["CLAMP"] = "clamp-to-edge";
  DEPRECATED_WRAP_MODES2["REPEAT"] = "repeat";
  DEPRECATED_WRAP_MODES2["MIRRORED_REPEAT"] = "mirror-repeat";
  return DEPRECATED_WRAP_MODES2;
})(DEPRECATED_WRAP_MODES || {});
const WRAP_MODES = new Proxy(DEPRECATED_WRAP_MODES, {
  get(target, prop) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_WRAP_MODES[prop]}' instead`);
    return target[prop];
  }
});
var DEPRECATED_SCALE_MODES = /* @__PURE__ */ ((DEPRECATED_SCALE_MODES2) => {
  DEPRECATED_SCALE_MODES2["NEAREST"] = "nearest";
  DEPRECATED_SCALE_MODES2["LINEAR"] = "linear";
  return DEPRECATED_SCALE_MODES2;
})(DEPRECATED_SCALE_MODES || {});
const SCALE_MODES = new Proxy(DEPRECATED_SCALE_MODES, {
  get(target, prop) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_SCALE_MODES[prop]}' instead`);
    return target[prop];
  }
});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BufferImageSource: () => (/* binding */ BufferImageSource)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");



"use strict";
class BufferImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.TextureSource {
  constructor(options) {
    const buffer = options.resource || new Float32Array(options.width * options.height * 4);
    let format = options.format;
    if (!format) {
      if (buffer instanceof Float32Array) {
        format = "rgba32float";
      } else if (buffer instanceof Int32Array) {
        format = "rgba32uint";
      } else if (buffer instanceof Uint32Array) {
        format = "rgba32uint";
      } else if (buffer instanceof Int16Array) {
        format = "rgba16uint";
      } else if (buffer instanceof Uint16Array) {
        format = "rgba16uint";
      } else if (buffer instanceof Int8Array) {
        format = "bgra8unorm";
      } else {
        format = "bgra8unorm";
      }
    }
    super({
      ...options,
      resource: buffer,
      format
    });
    this.uploadMethodId = "buffer";
  }
  static test(resource) {
    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
  }
}
BufferImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.TextureSource;


//# sourceMappingURL=BufferImageSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasSource: () => (/* binding */ CanvasSource)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");




"use strict";
class CanvasSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.TextureSource {
  constructor(options) {
    if (!options.resource) {
      options.resource = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().createCanvas();
    }
    if (!options.width) {
      options.width = options.resource.width;
      if (!options.autoDensity) {
        options.width /= options.resolution;
      }
    }
    if (!options.height) {
      options.height = options.resource.height;
      if (!options.autoDensity) {
        options.height /= options.resolution;
      }
    }
    super(options);
    this.uploadMethodId = "image";
    this.autoDensity = options.autoDensity;
    this.resizeCanvas();
    this.transparent = !!options.transparent;
  }
  resizeCanvas() {
    if (this.autoDensity && "style" in this.resource) {
      this.resource.style.width = `${this.width}px`;
      this.resource.style.height = `${this.height}px`;
    }
    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
      this.resource.width = this.pixelWidth;
      this.resource.height = this.pixelHeight;
    }
  }
  resize(width = this.width, height = this.height, resolution = this._resolution) {
    const didResize = super.resize(width, height, resolution);
    if (didResize) {
      this.resizeCanvas();
    }
    return didResize;
  }
  static test(resource) {
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
CanvasSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.TextureSource;


//# sourceMappingURL=CanvasSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompressedSource: () => (/* binding */ CompressedSource)
/* harmony export */ });
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");


"use strict";
class CompressedSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.TextureSource {
  constructor(options) {
    super(options);
    this.uploadMethodId = "compressed";
    this.resource = options.resource;
    this.mipLevelCount = this.resource.length;
  }
}


//# sourceMappingURL=CompressedSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageSource: () => (/* binding */ ImageSource)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");





"use strict";
class ImageSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.TextureSource {
  constructor(options) {
    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {
      const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);
      const context = canvas.getContext("2d");
      context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);
      options.resource = canvas;
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
    }
    super(options);
    this.uploadMethodId = "image";
    this.autoGarbageCollect = true;
  }
  static test(resource) {
    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
  }
}
ImageSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.TextureSource;


//# sourceMappingURL=ImageSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextureSource: () => (/* binding */ TextureSource)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../maths/misc/pow2.mjs */ "./node_modules/pixi.js/lib/maths/misc/pow2.mjs");
/* harmony import */ var _scene_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../scene/container/utils/definedProps.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _TextureStyle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TextureStyle.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs");






"use strict";
const _TextureSource = class _TextureSource extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(options = {}) {
    super();
    this.options = options;
    /** unique id for this Texture source */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("textureSource");
    /**
     * The resource type used by this TextureSource. This is used by the bind groups to determine
     * how to handle this resource.
     * @ignore
     * @internal
     */
    this._resourceType = "textureSource";
    /**
     * i unique resource id, used by the bind group systems.
     * This can change if the texture is resized or its resource changes
     */
    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
    /**
     * this is how the backends know how to upload this texture to the GPU
     * It changes depending on the resource type. Classes that extend TextureSource
     * should override this property.
     * @ignore
     * @internal
     */
    this.uploadMethodId = "unknown";
    // dimensions
    this._resolution = 1;
    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */
    this.pixelWidth = 1;
    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */
    this.pixelHeight = 1;
    /**
     * the width of this texture source, accounting for resolution
     * eg pixelWidth 200, resolution 2, then width will be 100
     */
    this.width = 1;
    /**
     * the height of this texture source, accounting for resolution
     * eg pixelHeight 200, resolution 2, then height will be 100
     */
    this.height = 1;
    /**
     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.
     * To enable multisample for a texture, set antialias to true
     * @internal
     * @ignore
     */
    this.sampleCount = 1;
    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */
    this.mipLevelCount = 1;
    /**
     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps
     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but
     * can look better when scaled down.
     *
     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.
     * If you do, make sure to call `updateMipmaps` after you update the texture.
     */
    this.autoGenerateMipmaps = false;
    /** the format that the texture data has */
    this.format = "rgba8unorm";
    /** how many dimensions does this texture have? currently v8 only supports 2d */
    this.dimension = "2d";
    /**
     * Only really affects RenderTextures.
     * Should we use antialiasing for this texture. It will look better, but may impact performance as a
     * Blit operation will be required to resolve the texture.
     */
    this.antialias = false;
    /**
     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
     * @protected
     */
    this._touched = 0;
    /**
     * Used by the batcher to build texture batches. faster to have the variable here!
     * @protected
     */
    this._batchTick = -1;
    /**
     * A temporary batch location for the texture batching. Here for performance reasons only!
     * @protected
     */
    this._textureBindLocation = -1;
    options = { ..._TextureSource.defaultOptions, ...options };
    this.label = options.label ?? "";
    this.resource = options.resource;
    this.autoGarbageCollect = options.autoGarbageCollect;
    this._resolution = options.resolution;
    if (options.width) {
      this.pixelWidth = options.width * this._resolution;
    } else {
      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
    }
    if (options.height) {
      this.pixelHeight = options.height * this._resolution;
    } else {
      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
    }
    this.width = this.pixelWidth / this._resolution;
    this.height = this.pixelHeight / this._resolution;
    this.format = options.format;
    this.dimension = options.dimensions;
    this.mipLevelCount = options.mipLevelCount;
    this.autoGenerateMipmaps = options.autoGenerateMipmaps;
    this.sampleCount = options.sampleCount;
    this.antialias = options.antialias;
    this.alphaMode = options.alphaMode;
    this.style = new _TextureStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.TextureStyle((0,_scene_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_3__.definedProps)(options));
    this.destroyed = false;
    this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(value) {
    if (this.style === value)
      return;
    this._style?.off("change", this._onStyleChange, this);
    this._style = value;
    this._style?.on("change", this._onStyleChange, this);
    this._onStyleChange();
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(value) {
    this._style.addressMode = value;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(value) {
    this._style.addressMode = value;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(value) {
    this._style.magFilter = value;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(value) {
    this._style.minFilter = value;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(value) {
    this._style.mipmapFilter = value;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(value) {
    this._style.lodMinClamp = value;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(value) {
    this._style.lodMaxClamp = value;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const resolution = this._resolution;
      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
      if (didResize)
        return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = true;
    this.emit("destroy", this);
    this.emit("change", this);
    if (this._style) {
      this._style.destroy();
      this._style = null;
    }
    this.uploadMethodId = null;
    this.resource = null;
    this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
    this.emit("change", this);
    this.emit("unload", this);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource } = this;
    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource } = this;
    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(resolution) {
    if (this._resolution === resolution)
      return;
    this._resolution = resolution;
    this.width = this.pixelWidth / resolution;
    this.height = this.pixelHeight / resolution;
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(width, height, resolution) {
    resolution || (resolution = this._resolution);
    width || (width = this.width);
    height || (height = this.height);
    const newPixelWidth = Math.round(width * resolution);
    const newPixelHeight = Math.round(height * resolution);
    this.width = newPixelWidth / resolution;
    this.height = newPixelHeight / resolution;
    this._resolution = resolution;
    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
      return false;
    }
    this._refreshPOT();
    this.pixelWidth = newPixelWidth;
    this.pixelHeight = newPixelHeight;
    this.emit("resize", this);
    this._resourceId = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_1__.uid)("resource");
    this.emit("change", this);
    return true;
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
      this.emit("updateMipmaps", this);
    }
  }
  set wrapMode(value) {
    this._style.wrapMode = value;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(value) {
    this._style.scaleMode = value;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_4__.isPow2)(this.pixelWidth) && (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_4__.isPow2)(this.pixelHeight);
  }
  static test(_resource) {
    throw new Error("Unimplemented");
  }
};
/** The default options used when creating a new TextureSource. override these to add your own defaults */
_TextureSource.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  mipLevelCount: 1,
  autoGenerateMipmaps: false,
  sampleCount: 1,
  antialias: false,
  autoGarbageCollect: false
};
let TextureSource = _TextureSource;


//# sourceMappingURL=TextureSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VideoSource: () => (/* binding */ VideoSource)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../ticker/Ticker.mjs */ "./node_modules/pixi.js/lib/ticker/Ticker.mjs");
/* harmony import */ var _utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../utils/browser/detectVideoAlphaMode.mjs */ "./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs");
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");





"use strict";
const _VideoSource = class _VideoSource extends _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.TextureSource {
  constructor(options) {
    super(options);
    // Public
    /** Whether or not the video is ready to play. */
    this.isReady = false;
    /** The upload method for this texture. */
    this.uploadMethodId = "video";
    options = {
      ..._VideoSource.defaultOptions,
      ...options
    };
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
    this._videoFrameRequestCallbackHandle = null;
    this._load = null;
    this._resolve = null;
    this._reject = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
    this._onError = this._onError.bind(this);
    this._onPlayStart = this._onPlayStart.bind(this);
    this._onPlayStop = this._onPlayStop.bind(this);
    this._onSeeked = this._onSeeked.bind(this);
    if (options.autoLoad !== false) {
      void this.load();
    }
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (this.destroyed) {
      return;
    }
    if (this._updateFPS) {
      const elapsedMS = _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__.Ticker.shared.elapsedMS * this.resource.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
    }
    if (!this._updateFPS || this._msToNextUpdate <= 0) {
      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
    }
    if (this.isValid) {
      this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame();
    if (this.destroyed) {
      this._videoFrameRequestCallbackHandle = null;
    } else {
      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
        this._videoFrameRequestCallback
      );
    }
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load) {
      return this._load;
    }
    const source = this.resource;
    const options = this.options;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart);
    source.addEventListener("pause", this._onPlayStop);
    source.addEventListener("seeked", this._onSeeked);
    if (!this._isSourceReady()) {
      if (!options.preload) {
        source.addEventListener("canplay", this._onCanPlay);
      }
      source.addEventListener("canplaythrough", this._onCanPlayThrough);
      source.addEventListener("error", this._onError, true);
    } else {
      this._mediaReady();
    }
    this.alphaMode = await (0,_utils_browser_detectVideoAlphaMode_mjs__WEBPACK_IMPORTED_MODULE_2__.detectVideoAlphaMode)();
    this._load = new Promise((resolve, reject) => {
      if (this.isValid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        this._reject = reject;
        if (options.preloadTimeoutMs !== void 0) {
          this._preloadTimeout = setTimeout(() => {
            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
          });
        }
        source.load();
      }
    });
    return this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(event) {
    this.resource.removeEventListener("error", this._onError, true);
    this.emit("error", event);
    if (this._reject) {
      this._reject(event);
      this._reject = null;
      this._resolve = null;
    }
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const source = this.resource;
    return !source.paused && !source.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    const source = this.resource;
    return source.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    if (!this.isValid) {
      this._mediaReady();
    }
    this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    if (this._autoUpdate && !this._isSourcePlaying()) {
      this._msToNextUpdate = 0;
      this.updateFrame();
      this._msToNextUpdate = 0;
    }
  }
  _onCanPlay() {
    const source = this.resource;
    source.removeEventListener("canplay", this._onCanPlay);
    this._mediaReady();
  }
  _onCanPlayThrough() {
    const source = this.resource;
    source.removeEventListener("canplaythrough", this._onCanPlay);
    if (this._preloadTimeout) {
      clearTimeout(this._preloadTimeout);
      this._preloadTimeout = void 0;
    }
    this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const source = this.resource;
    if (this.isValid) {
      this.isReady = true;
      this.resize(source.videoWidth, source.videoHeight);
    }
    this._msToNextUpdate = 0;
    this.updateFrame();
    this._msToNextUpdate = 0;
    if (this._resolve) {
      this._resolve(this);
      this._resolve = null;
      this._reject = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      void this.resource.play();
    }
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const source = this.resource;
    if (source) {
      source.removeEventListener("play", this._onPlayStart);
      source.removeEventListener("pause", this._onPlayStop);
      source.removeEventListener("seeked", this._onSeeked);
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlayThrough);
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      this._configureAutoUpdate();
    }
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
      this._configureAutoUpdate();
    }
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    if (this._autoUpdate && this._isSourcePlaying()) {
      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
        if (this._isConnectedToTicker) {
          _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__.Ticker.shared.remove(this.updateFrame, this);
          this._isConnectedToTicker = false;
          this._msToNextUpdate = 0;
        }
        if (this._videoFrameRequestCallbackHandle === null) {
          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      } else {
        if (this._videoFrameRequestCallbackHandle !== null) {
          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
          this._videoFrameRequestCallbackHandle = null;
        }
        if (!this._isConnectedToTicker) {
          _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__.Ticker.shared.add(this.updateFrame, this);
          this._isConnectedToTicker = true;
          this._msToNextUpdate = 0;
        }
      }
    } else {
      if (this._videoFrameRequestCallbackHandle !== null) {
        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
        this._videoFrameRequestCallbackHandle = null;
      }
      if (this._isConnectedToTicker) {
        _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_1__.Ticker.shared.remove(this.updateFrame, this);
        this._isConnectedToTicker = false;
        this._msToNextUpdate = 0;
      }
    }
  }
  static test(resource) {
    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
  }
};
_VideoSource.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.TextureSource;
/** The default options for video sources. */
_VideoSource.defaultOptions = {
  ..._TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__.TextureSource.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: true,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: true,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: true,
  /** If true, the video will loop when it ends. */
  loop: false,
  /** If true, the video will be muted. */
  muted: true,
  /** If true, the video will play inline. */
  playsinline: true,
  /** If true, the video will be preloaded. */
  preload: false
};
/**
 * Map of video MIME types that can't be directly derived from file extensions.
 * @readonly
 */
_VideoSource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let VideoSource = _VideoSource;


//# sourceMappingURL=VideoSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateUID: () => (/* binding */ generateUID)
/* harmony export */ });

let uidCount = 0;
function generateUID() {
  return uidCount++;
}


//# sourceMappingURL=generateUID.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCanvasTexture: () => (/* binding */ getCanvasTexture),
/* harmony export */   hasCachedCanvasTexture: () => (/* binding */ hasCachedCanvasTexture)
/* harmony export */ });
/* harmony import */ var _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sources/CanvasSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs");
/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");



"use strict";
const canvasCache = /* @__PURE__ */ new Map();
function getCanvasTexture(canvas, options) {
  if (!canvasCache.has(canvas)) {
    const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture({
      source: new _sources_CanvasSource_mjs__WEBPACK_IMPORTED_MODULE_1__.CanvasSource({
        resource: canvas,
        ...options
      })
    });
    const onDestroy = () => {
      if (canvasCache.get(canvas) === texture) {
        canvasCache.delete(canvas);
      }
    };
    texture.once("destroy", onDestroy);
    texture.source.once("destroy", onDestroy);
    canvasCache.set(canvas, texture);
  }
  return canvasCache.get(canvas);
}
function hasCachedCanvasTexture(canvas) {
  return canvasCache.has(canvas);
}


//# sourceMappingURL=getCanvasTexture.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSupportedCompressedTextureFormats: () => (/* binding */ getSupportedCompressedTextureFormats)
/* harmony export */ });
/* harmony import */ var _utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../utils/browser/isWebGLSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs");
/* harmony import */ var _utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../utils/browser/isWebGPUSupported.mjs */ "./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs");
/* harmony import */ var _gl_texture_utils_getSupportedGlCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs");
/* harmony import */ var _gpu_texture_utils_getSupportedGPUCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs");





"use strict";
let supportedCompressedTextureFormats;
async function getSupportedCompressedTextureFormats() {
  if (supportedCompressedTextureFormats !== void 0)
    return supportedCompressedTextureFormats;
  supportedCompressedTextureFormats = await (async () => {
    const _isWebGPUSupported = await (0,_utils_browser_isWebGPUSupported_mjs__WEBPACK_IMPORTED_MODULE_0__.isWebGPUSupported)();
    const _isWebGLSupported = (0,_utils_browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_1__.isWebGLSupported)();
    if (_isWebGPUSupported && _isWebGLSupported) {
      const gpuTextureFormats = await (0,_gpu_texture_utils_getSupportedGPUCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_2__.getSupportedGPUCompressedTextureFormats)();
      const glTextureFormats = (0,_gl_texture_utils_getSupportedGlCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__.getSupportedGlCompressedTextureFormats)();
      return gpuTextureFormats.filter((format) => glTextureFormats.includes(format));
    } else if (_isWebGPUSupported) {
      return await (0,_gpu_texture_utils_getSupportedGPUCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_2__.getSupportedGPUCompressedTextureFormats)();
    } else if (_isWebGLSupported) {
      return (0,_gl_texture_utils_getSupportedGlCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_3__.getSupportedGlCompressedTextureFormats)();
    }
    return [];
  })();
  return supportedCompressedTextureFormats;
}


//# sourceMappingURL=getSupportedCompressedTextureFormats.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSupportedTextureFormats: () => (/* binding */ getSupportedTextureFormats),
/* harmony export */   nonCompressedFormats: () => (/* binding */ nonCompressedFormats)
/* harmony export */ });
/* harmony import */ var _getSupportedCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getSupportedCompressedTextureFormats.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs");


"use strict";
const nonCompressedFormats = [
  // 8-bit formats
  "r8unorm",
  "r8snorm",
  "r8uint",
  "r8sint",
  // 16-bit formats
  "r16uint",
  "r16sint",
  "r16float",
  "rg8unorm",
  "rg8snorm",
  "rg8uint",
  "rg8sint",
  // 32-bit formats
  "r32uint",
  "r32sint",
  "r32float",
  "rg16uint",
  "rg16sint",
  "rg16float",
  "rgba8unorm",
  "rgba8unorm-srgb",
  "rgba8snorm",
  "rgba8uint",
  "rgba8sint",
  "bgra8unorm",
  "bgra8unorm-srgb",
  // Packed 32-bit formats
  "rgb9e5ufloat",
  "rgb10a2unorm",
  "rg11b10ufloat",
  // 64-bit formats
  "rg32uint",
  "rg32sint",
  "rg32float",
  "rgba16uint",
  "rgba16sint",
  "rgba16float",
  // 128-bit formats
  "rgba32uint",
  "rgba32sint",
  "rgba32float",
  // Depth/stencil formats
  "stencil8",
  "depth16unorm",
  "depth24plus",
  "depth24plus-stencil8",
  "depth32float",
  // "depth32float-stencil8" feature
  "depth32float-stencil8"
];
let supportedTextureFormats;
async function getSupportedTextureFormats() {
  if (supportedTextureFormats !== void 0)
    return supportedTextureFormats;
  const compressedTextureFormats = await (0,_getSupportedCompressedTextureFormats_mjs__WEBPACK_IMPORTED_MODULE_0__.getSupportedCompressedTextureFormats)();
  supportedTextureFormats = [
    ...nonCompressedFormats,
    ...compressedTextureFormats
  ];
  return supportedTextureFormats;
}


//# sourceMappingURL=getSupportedTextureFormats.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autoDetectSource: () => (/* binding */ autoDetectSource),
/* harmony export */   resourceToTexture: () => (/* binding */ resourceToTexture),
/* harmony export */   textureFrom: () => (/* binding */ textureFrom)
/* harmony export */ });
/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../assets/cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sources/TextureSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs");
/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");





"use strict";
const sources = [];
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions.handleByList(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.TextureSource, sources);
function autoDetectSource(options = {}) {
  return textureSourceFrom(options);
}
function textureSourceFrom(options = {}) {
  const hasResource = options && options.resource;
  const res = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  for (let i = 0; i < sources.length; i++) {
    const Source = sources[i];
    if (Source.test(res)) {
      return new Source(opts);
    }
  }
  throw new Error(`Could not find a source type for resource: ${opts.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const hasResource = options && options.resource;
  const resource = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  if (!skipCache && _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.has(resource)) {
    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.get(resource);
  }
  const texture = new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.Texture({ source: textureSourceFrom(opts) });
  texture.on("destroy", () => {
    if (_assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.has(resource)) {
      _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.remove(resource);
    }
  });
  if (!skipCache) {
    _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.set(resource, texture);
  }
  return texture;
}
function textureFrom(id, skipCache = false) {
  if (typeof id === "string") {
    return _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_1__.Cache.get(id);
  } else if (id instanceof _sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__.TextureSource) {
    return new _Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.Texture({ source: id });
  }
  return resourceToTexture(id, skipCache);
}
_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.Texture.from = textureFrom;
_sources_TextureSource_mjs__WEBPACK_IMPORTED_MODULE_3__.TextureSource.from = textureSourceFrom;


//# sourceMappingURL=textureFrom.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createIdFromString: () => (/* binding */ createIdFromString)
/* harmony export */ });

const idCounts = /* @__PURE__ */ Object.create(null);
const idHash = /* @__PURE__ */ Object.create(null);
function createIdFromString(value, groupId) {
  let id = idHash[value];
  if (id === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash[value] = id = idCounts[groupId]++;
  }
  return id;
}


//# sourceMappingURL=createIdFromString.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseFunctionBody: () => (/* binding */ parseFunctionBody)
/* harmony export */ });

function parseFunctionBody(fn) {
  const fnStr = fn.toString();
  const bodyStart = fnStr.indexOf("{");
  const bodyEnd = fnStr.lastIndexOf("}");
  if (bodyStart === -1 || bodyEnd === -1) {
    throw new Error("getFunctionBody: No body found in function definition");
  }
  return fnStr.slice(bodyStart + 1, bodyEnd).trim();
}


//# sourceMappingURL=parseFunctionBody.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ViewSystem: () => (/* binding */ ViewSystem)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _renderTarget_RenderTarget_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderTarget/RenderTarget.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs");
/* harmony import */ var _texture_utils_getCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../texture/utils/getCanvasTexture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs");







"use strict";
const _ViewSystem = class _ViewSystem {
  /**
   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.
   * @member {boolean}
   */
  get autoDensity() {
    return this.texture.source.autoDensity;
  }
  set autoDensity(value) {
    this.texture.source.autoDensity = value;
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.texture.source._resolution;
  }
  set resolution(value) {
    this.texture.source.resize(
      this.texture.source.width,
      this.texture.source.height,
      value
    );
  }
  /**
   * initiates the view system
   * @param options - the options for the view
   */
  init(options) {
    options = {
      ..._ViewSystem.defaultOptions,
      ...options
    };
    if (options.view) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
      options.canvas = options.view;
    }
    this.screen = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(0, 0, options.width, options.height);
    this.canvas = options.canvas || _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_2__.DOMAdapter.get().createCanvas();
    this.antialias = !!options.antialias;
    this.texture = (0,_texture_utils_getCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.getCanvasTexture)(this.canvas, options);
    this.renderTarget = new _renderTarget_RenderTarget_mjs__WEBPACK_IMPORTED_MODULE_4__.RenderTarget({
      colorTextures: [this.texture],
      depth: !!options.depth,
      isRoot: true
    });
    this.texture.source.transparent = options.backgroundAlpha < 1;
    this.resolution = options.resolution;
  }
  /**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   * @param resolution
   */
  resize(desiredScreenWidth, desiredScreenHeight, resolution) {
    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
    this.screen.width = this.texture.frame.width;
    this.screen.height = this.texture.frame.height;
  }
  /**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {options | false} options - The options for destroying the view, or "false".
   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
   */
  destroy(options = false) {
    const removeView = typeof options === "boolean" ? options : !!options?.removeView;
    if (removeView && this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
  }
};
/** @ignore */
_ViewSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_5__.ExtensionType.CanvasSystem
  ],
  name: "view",
  priority: 0
};
/** The default options for the view system. */
_ViewSystem.defaultOptions = {
  /**
   * {@link WebGLOptions.width}
   * @default 800
   */
  width: 800,
  /**
   * {@link WebGLOptions.height}
   * @default 600
   */
  height: 600,
  /**
   * {@link WebGLOptions.autoDensity}
   * @default false
   */
  autoDensity: false,
  /**
   * {@link WebGLOptions.antialias}
   * @default false
   */
  antialias: false
};
let ViewSystem = _ViewSystem;


//# sourceMappingURL=ViewSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/rendering/renderers/types.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RendererType: () => (/* binding */ RendererType)
/* harmony export */ });

var RendererType = /* @__PURE__ */ ((RendererType2) => {
  RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
  RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
  RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
  return RendererType2;
})(RendererType || {});


//# sourceMappingURL=types.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/Container.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/Container.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Container: () => (/* binding */ Container),
/* harmony export */   UPDATE_BLEND: () => (/* binding */ UPDATE_BLEND),
/* harmony export */   UPDATE_COLOR: () => (/* binding */ UPDATE_COLOR),
/* harmony export */   UPDATE_TRANSFORM: () => (/* binding */ UPDATE_TRANSFORM),
/* harmony export */   UPDATE_VISIBLE: () => (/* binding */ UPDATE_VISIBLE)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _culling_cullingMixin_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../culling/cullingMixin.mjs */ "./node_modules/pixi.js/lib/culling/cullingMixin.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_misc_const_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../maths/misc/const.mjs */ "./node_modules/pixi.js/lib/maths/misc/const.mjs");
/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../maths/point/ObservablePoint.mjs */ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _container_mixins_cacheAsTextureMixin_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./container-mixins/cacheAsTextureMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs");
/* harmony import */ var _container_mixins_childrenHelperMixin_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./container-mixins/childrenHelperMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs");
/* harmony import */ var _container_mixins_collectRenderablesMixin_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./container-mixins/collectRenderablesMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs");
/* harmony import */ var _container_mixins_effectsMixin_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./container-mixins/effectsMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs");
/* harmony import */ var _container_mixins_findMixin_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./container-mixins/findMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs");
/* harmony import */ var _container_mixins_getFastGlobalBoundsMixin_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./container-mixins/getFastGlobalBoundsMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs");
/* harmony import */ var _container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./container-mixins/getGlobalMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs");
/* harmony import */ var _container_mixins_measureMixin_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./container-mixins/measureMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs");
/* harmony import */ var _container_mixins_onRenderMixin_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./container-mixins/onRenderMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs");
/* harmony import */ var _container_mixins_sortMixin_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./container-mixins/sortMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs");
/* harmony import */ var _container_mixins_toLocalGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./container-mixins/toLocalGlobalMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs");
/* harmony import */ var _RenderGroup_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./RenderGroup.mjs */ "./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs");
/* harmony import */ var _utils_assignWithIgnore_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/assignWithIgnore.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs");
























"use strict";
const defaultSkew = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(null);
const defaultPivot = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(null);
const defaultScale = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(null, 1, 1);
const UPDATE_COLOR = 1;
const UPDATE_BLEND = 2;
const UPDATE_VISIBLE = 4;
const UPDATE_TRANSFORM = 8;
class Container extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(options = {}) {
    super();
    /** unique id for this container */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_2__.uid)("renderable");
    /** @private */
    this._updateFlags = 15;
    // the render group this container owns
    /** @private */
    this.renderGroup = null;
    // the render group this container belongs to
    /** @private */
    this.parentRenderGroup = null;
    // the index of the container in the render group
    /** @private */
    this.parentRenderGroupIndex = 0;
    // set to true if the container has changed. It is reset once the changes have been applied
    // by the transform system
    // its here to stop ensure that when things change, only one update gets registers with the transform system
    /** @private */
    this.didChange = false;
    // same as above, but for the renderable
    /** @private */
    this.didViewUpdate = false;
    // how deep is the container relative to its render group..
    // unless the element is the root render group - it will be relative to its parent
    /** @private */
    this.relativeRenderGroupDepth = 0;
    /**
     * The array of children of this container.
     * @readonly
     */
    this.children = [];
    /** The display object container that contains this display object. */
    this.parent = null;
    // used internally for changing up the render order.. mainly for masks and filters
    // TODO setting this should cause a rebuild??
    /** @private */
    this.includeInBuild = true;
    /** @private */
    this.measurable = true;
    /** @private */
    this.isSimple = true;
    // / /////////////Transform related props//////////////
    // used by the transform system to check if a container needs to be updated that frame
    // if the tick matches the current transform system tick, it is not updated again
    /**
     * @internal
     * @ignore
     */
    this.updateTick = -1;
    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     * @readonly
     */
    this.localTransform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__.Matrix();
    /**
     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent
     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).
     * If this container is is self a render group matrix will be relative to its parent render group
     * @readonly
     */
    this.relativeGroupTransform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__.Matrix();
    /**
     * The group transform is a transform relative to the render group it belongs too.
     * If this container is render group then this will be an identity matrix. other wise it
     * will be the same as the relativeGroupTransform.
     * Use this value when actually rendering things to the screen
     * @readonly
     */
    this.groupTransform = this.relativeGroupTransform;
    /** If the object has been destroyed via destroy(). If true, it should not be used. */
    this.destroyed = false;
    // transform data..
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * @internal
     * @ignore
     */
    this._position = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    /**
     * The scale factor of the object.
     * @internal
     * @ignore
     */
    this._scale = defaultScale;
    /**
     * The pivot point of the container that it rotates around.
     * @internal
     * @ignore
     */
    this._pivot = defaultPivot;
    /**
     * The skew amount, on the x and y axis.
     * @internal
     * @ignore
     */
    this._skew = defaultSkew;
    /**
     * The X-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     * @internal
     * @ignore
     */
    this._cx = 1;
    /**
     * The Y-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     * @internal
     * @ignore
     */
    this._sx = 0;
    /**
     * The X-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     * @internal
     * @ignore
     */
    this._cy = 0;
    /**
     * The Y-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     * @internal
     * @ignore
     */
    this._sy = 1;
    /**
     * The rotation amount.
     * @internal
     * @ignore
     */
    this._rotation = 0;
    // / COLOR related props //////////////
    // color stored as ABGR
    this.localColor = 16777215;
    this.localAlpha = 1;
    this.groupAlpha = 1;
    // A
    this.groupColor = 16777215;
    // BGR
    this.groupColorAlpha = 4294967295;
    // ABGR
    // / BLEND related props //////////////
    /**
     * @internal
     * @ignore
     */
    this.localBlendMode = "inherit";
    /**
     * @internal
     * @ignore
     */
    this.groupBlendMode = "normal";
    // / VISIBILITY related props //////////////
    // visibility
    // 0b11
    // first bit is visible, second bit is renderable
    /**
     * This property holds three bits: culled, visible, renderable
     * the third bit represents culling (0 = culled, 1 = not culled) 0b100
     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010
     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001
     * @internal
     * @ignore
     */
    this.localDisplayStatus = 7;
    // 0b11 | 0b10 | 0b01 | 0b00
    /**
     * @internal
     * @ignore
     */
    this.globalDisplayStatus = 7;
    /**
     * A value that increments each time the containe is modified
     * eg children added, removed etc
     * @ignore
     */
    this._didContainerChangeTick = 0;
    /**
     * A value that increments each time the container view is modified
     * eg texture swap, geometry change etc
     * @ignore
     */
    this._didViewChangeTick = 0;
    /**
     * property that tracks if the container transform has changed
     * @ignore
     */
    this._didLocalTransformChangeId = -1;
    this.effects = [];
    (0,_utils_assignWithIgnore_mjs__WEBPACK_IMPORTED_MODULE_4__.assignWithIgnore)(this, options, {
      children: true,
      parent: true,
      effects: true
    });
    options.children?.forEach((child) => this.addChild(child));
    options.parent?.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   * @deprecated since 8.8.0
   */
  static mixin(source) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_5__.deprecation)("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.extensions.mixin(Container, source);
  }
  // = 'default';
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(value) {
    this._didViewChangeTick = value >> 12 & 4095;
    this._didContainerChangeTick = value & 4095;
  }
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   *
   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
   * @param {...Container} children - The Container(s) to add to the container
   * @returns {Container} - The first child that was added.
   */
  addChild(...children) {
    if (!this.allowChildren) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_5__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_5__.v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
    }
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
      return children[0];
    }
    const child = children[0];
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (child.parent === this) {
      this.children.splice(this.children.indexOf(child), 1);
      this.children.push(child);
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
      return child;
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    this.children.push(child);
    if (this.sortableChildren)
      this.sortDirty = true;
    child.parent = this;
    child.didChange = true;
    child._updateFlags = 15;
    if (renderGroup) {
      renderGroup.addChild(child);
    }
    this.emit("childAdded", child, this, this.children.length - 1);
    child.emit("added", this);
    this._didViewChangeTick++;
    if (child._zIndex !== 0) {
      child.depthOfChildModified();
    }
    return child;
  }
  /**
   * Removes one or more children from the container.
   * @param {...Container} children - The Container(s) to remove
   * @returns {Container} The first child that was removed.
   */
  removeChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
      return children[0];
    }
    const child = children[0];
    const index = this.children.indexOf(child);
    if (index > -1) {
      this._didViewChangeTick++;
      this.children.splice(index, 1);
      if (this.renderGroup) {
        this.renderGroup.removeChild(child);
      } else if (this.parentRenderGroup) {
        this.parentRenderGroup.removeChild(child);
      }
      if (child.parentRenderLayer) {
        child.parentRenderLayer.detach(child);
      }
      child.parent = null;
      this.emit("childRemoved", child, this, index);
      child.emit("removed", this);
    }
    return child;
  }
  /** @ignore */
  _onUpdate(point) {
    if (point) {
      if (point === this._skew) {
        this._updateSkew();
      }
    }
    this._didContainerChangeTick++;
    if (this.didChange)
      return;
    this.didChange = true;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.onChildUpdate(this);
    }
  }
  set isRenderGroup(value) {
    if (!!this.renderGroup === value)
      return;
    if (value) {
      this.enableRenderGroup();
    } else {
      this.disableRenderGroup();
    }
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   */
  enableRenderGroup() {
    if (this.renderGroup)
      return;
    const parentRenderGroup = this.parentRenderGroup;
    parentRenderGroup?.removeChild(this);
    this.renderGroup = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_7__.BigPool.get(_RenderGroup_mjs__WEBPACK_IMPORTED_MODULE_8__.RenderGroup, this);
    this.groupTransform = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__.Matrix.IDENTITY;
    parentRenderGroup?.addChild(this);
    this._updateIsSimple();
  }
  /** This will disable the render group for this container. */
  disableRenderGroup() {
    if (!this.renderGroup)
      return;
    const parentRenderGroup = this.parentRenderGroup;
    parentRenderGroup?.removeChild(this);
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_7__.BigPool.return(this.renderGroup);
    this.renderGroup = null;
    this.groupTransform = this.relativeGroupTransform;
    parentRenderGroup?.addChild(this);
    this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   * @readonly
   */
  get worldTransform() {
    this._worldTransform || (this._worldTransform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_3__.Matrix());
    if (this.renderGroup) {
      this._worldTransform.copyFrom(this.renderGroup.worldTransform);
    } else if (this.parentRenderGroup) {
      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
    }
    return this._worldTransform;
  }
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   * An alias to position.x
   */
  get x() {
    return this._position.x;
  }
  set x(value) {
    this._position.x = value;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   * An alias to position.y
   */
  get y() {
    return this._position.y;
  }
  set y(value) {
    this._position.y = value;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position.copyFrom(value);
  }
  /**
   * The rotation of the object in radians.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this._onUpdate(this._skew);
    }
  }
  /**
   * The angle of the object in degrees.
   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
   */
  get angle() {
    return this.rotation * _maths_misc_const_mjs__WEBPACK_IMPORTED_MODULE_9__.RAD_TO_DEG;
  }
  set angle(value) {
    this.rotation = value * _maths_misc_const_mjs__WEBPACK_IMPORTED_MODULE_9__.DEG_TO_RAD;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
   * is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @since 4.0.0
   */
  get pivot() {
    if (this._pivot === defaultPivot) {
      this._pivot = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    }
    return this._pivot;
  }
  set pivot(value) {
    if (this._pivot === defaultPivot) {
      this._pivot = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    }
    typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
  }
  /**
   * The skew factor for the object in radians.
   * @since 4.0.0
   */
  get skew() {
    if (this._skew === defaultSkew) {
      this._skew = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    }
    return this._skew;
  }
  set skew(value) {
    if (this._skew === defaultSkew) {
      this._skew = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    }
    this._skew.copyFrom(value);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @since 4.0.0
   */
  get scale() {
    if (this._scale === defaultScale) {
      this._scale = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 1, 1);
    }
    return this._scale;
  }
  set scale(value) {
    if (this._scale === defaultScale) {
      this._scale = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    }
    typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(value) {
    const localWidth = this.getLocalBounds().width;
    this._setWidth(value, localWidth);
  }
  /**
   * The height of the Container, setting this will actually modify the scale to achieve the value set.
   * @memberof scene.Container#
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(value) {
    const localHeight = this.getLocalBounds().height;
    this._setHeight(value, localHeight);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the container.
   * @memberof scene.Container#
   */
  getSize(out) {
    if (!out) {
      out = {};
    }
    const bounds = this.getLocalBounds();
    out.width = Math.abs(this.scale.x * bounds.width);
    out.height = Math.abs(this.scale.y * bounds.height);
    return out;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   * @memberof scene.Container#
   */
  setSize(value, height) {
    const size = this.getLocalBounds();
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    } else {
      height ?? (height = value);
    }
    value !== void 0 && this._setWidth(value, size.width);
    height !== void 0 && this._setHeight(height, size.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const rotation = this._rotation;
    const skew = this._skew;
    this._cx = Math.cos(rotation + skew._y);
    this._sx = Math.sin(rotation + skew._y);
    this._cy = -Math.sin(rotation - skew._x);
    this._sy = Math.cos(rotation - skew._x);
  }
  /**
   * Updates the transform properties of the container (accepts partial values).
   * @param {object} opts - The options for updating the transform.
   * @param {number} opts.x - The x position of the container.
   * @param {number} opts.y - The y position of the container.
   * @param {number} opts.scaleX - The scale factor on the x-axis.
   * @param {number} opts.scaleY - The scale factor on the y-axis.
   * @param {number} opts.rotation - The rotation of the container, in radians.
   * @param {number} opts.skewX - The skew factor on the x-axis.
   * @param {number} opts.skewY - The skew factor on the y-axis.
   * @param {number} opts.pivotX - The x coordinate of the pivot point.
   * @param {number} opts.pivotY - The y coordinate of the pivot point.
   */
  updateTransform(opts) {
    this.position.set(
      typeof opts.x === "number" ? opts.x : this.position.x,
      typeof opts.y === "number" ? opts.y : this.position.y
    );
    this.scale.set(
      typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
      typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
    );
    this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
    this.skew.set(
      typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
      typeof opts.skewY === "number" ? opts.skewY : this.skew.y
    );
    this.pivot.set(
      typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
      typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
    );
    return this;
  }
  /**
   * Updates the local transform using the given matrix.
   * @param matrix - The matrix to use for updating the transform.
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const localTransformChangeId = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === localTransformChangeId)
      return;
    this._didLocalTransformChangeId = localTransformChangeId;
    const lt = this.localTransform;
    const scale = this._scale;
    const pivot = this._pivot;
    const position = this._position;
    const sx = scale._x;
    const sy = scale._y;
    const px = pivot._x;
    const py = pivot._y;
    lt.a = this._cx * sx;
    lt.b = this._sx * sx;
    lt.c = this._cy * sy;
    lt.d = this._sy * sy;
    lt.tx = position._x - (px * lt.a + py * lt.c);
    lt.ty = position._y - (px * lt.b + py * lt.d);
  }
  // / ///// color related stuff
  set alpha(value) {
    if (value === this.localAlpha)
      return;
    this.localAlpha = value;
    this._updateFlags |= UPDATE_COLOR;
    this._onUpdate();
  }
  /** The opacity of the object. */
  get alpha() {
    return this.localAlpha;
  }
  set tint(value) {
    const tempColor = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_10__.Color.shared.setValue(value ?? 16777215);
    const bgr = tempColor.toBgrNumber();
    if (bgr === this.localColor)
      return;
    this.localColor = bgr;
    this._updateFlags |= UPDATE_COLOR;
    this._onUpdate();
  }
  /**
   * The tint applied to the sprite. This is a hex value.
   *
   * A value of 0xFFFFFF will remove any tint effect.
   * @default 0xFFFFFF
   */
  get tint() {
    return (0,_container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_11__.bgr2rgb)(this.localColor);
  }
  // / //////////////// blend related stuff
  set blendMode(value) {
    if (this.localBlendMode === value)
      return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_BLEND;
    this.localBlendMode = value;
    this._onUpdate();
  }
  /**
   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
   * @default 'normal'
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(value) {
    const valueNumber = value ? 2 : 0;
    if ((this.localDisplayStatus & 2) === valueNumber)
      return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 2;
    this._onUpdate();
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(value) {
    const valueNumber = value ? 0 : 4;
    if ((this.localDisplayStatus & 4) === valueNumber)
      return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 4;
    this._onUpdate();
  }
  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(value) {
    const valueNumber = value ? 1 : 0;
    if ((this.localDisplayStatus & 1) === valueNumber)
      return;
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 1;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._onUpdate();
  }
  /** Whether or not the object should be rendered. */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
   *  method called as well. 'options' will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
   * is set to true it should destroy the texture of the child sprite
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true it should destroy the texture source of the child sprite
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true it should destroy the context of the child graphics
   */
  destroy(options = false) {
    if (this.destroyed)
      return;
    this.destroyed = true;
    let oldChildren;
    if (this.children.length) {
      oldChildren = this.removeChildren(0, this.children.length);
    }
    this.removeFromParent();
    this.parent = null;
    this._maskEffect = null;
    this._filterEffect = null;
    this.effects = null;
    this._position = null;
    this._scale = null;
    this._pivot = null;
    this._skew = null;
    this.emit("destroyed", this);
    this.removeAllListeners();
    const destroyChildren = typeof options === "boolean" ? options : options?.children;
    if (destroyChildren && oldChildren) {
      for (let i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
    this.renderGroup?.destroy();
    this.renderGroup = null;
  }
}
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.extensions.mixin(
  Container,
  _container_mixins_childrenHelperMixin_mjs__WEBPACK_IMPORTED_MODULE_12__.childrenHelperMixin,
  _container_mixins_getFastGlobalBoundsMixin_mjs__WEBPACK_IMPORTED_MODULE_13__.getFastGlobalBoundsMixin,
  _container_mixins_toLocalGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_14__.toLocalGlobalMixin,
  _container_mixins_onRenderMixin_mjs__WEBPACK_IMPORTED_MODULE_15__.onRenderMixin,
  _container_mixins_measureMixin_mjs__WEBPACK_IMPORTED_MODULE_16__.measureMixin,
  _container_mixins_effectsMixin_mjs__WEBPACK_IMPORTED_MODULE_17__.effectsMixin,
  _container_mixins_findMixin_mjs__WEBPACK_IMPORTED_MODULE_18__.findMixin,
  _container_mixins_sortMixin_mjs__WEBPACK_IMPORTED_MODULE_19__.sortMixin,
  _culling_cullingMixin_mjs__WEBPACK_IMPORTED_MODULE_20__.cullingMixin,
  _container_mixins_cacheAsTextureMixin_mjs__WEBPACK_IMPORTED_MODULE_21__.cacheAsTextureMixin,
  _container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_11__.getGlobalMixin,
  _container_mixins_collectRenderablesMixin_mjs__WEBPACK_IMPORTED_MODULE_22__.collectRenderablesMixin
);


//# sourceMappingURL=Container.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CustomRenderPipe: () => (/* binding */ CustomRenderPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
class CustomRenderPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  updateRenderable() {
  }
  destroyRenderable() {
  }
  validateRenderable() {
    return false;
  }
  addRenderable(container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add(container);
  }
  execute(container) {
    if (!container.isRenderable)
      return;
    container.render(this._renderer);
  }
  destroy() {
    this._renderer = null;
  }
}
CustomRenderPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasPipes
  ],
  name: "customRender"
};


//# sourceMappingURL=CustomRenderPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderContainer.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderContainer.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderContainer: () => (/* binding */ RenderContainer)
/* harmony export */ });
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");


"use strict";
class RenderContainer extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  /**
   * @param options - The options for the container.
   */
  constructor(options) {
    if (typeof options === "function") {
      options = { render: options };
    }
    const { render, ...rest } = options;
    super({
      label: "RenderContainer",
      ...rest
    });
    this.renderPipeId = "customRender";
    this.batched = false;
    if (render)
      this.render = render;
    this.containsPoint = options.containsPoint ?? (() => false);
    this.addBounds = options.addBounds ?? (() => false);
  }
  /** @private */
  updateBounds() {
    this._bounds.clear();
    this.addBounds(this._bounds);
  }
  /**
   * An overridable function that can be used to render the object using the current renderer.
   * @param _renderer - The current renderer
   */
  render(_renderer) {
  }
}


//# sourceMappingURL=RenderContainer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderGroup: () => (/* binding */ RenderGroup)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_shared_instructions_InstructionSet_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/instructions/InstructionSet.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");




"use strict";
class RenderGroup {
  constructor() {
    this.renderPipeId = "renderGroup";
    this.root = null;
    this.canBundle = false;
    this.renderGroupParent = null;
    this.renderGroupChildren = [];
    this.worldTransform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.worldColorAlpha = 4294967295;
    this.worldColor = 16777215;
    this.worldAlpha = 1;
    // these updates are transform changes..
    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
    this.updateTick = 0;
    this.gcTick = 0;
    // these update are renderable changes..
    this.childrenRenderablesToUpdate = { list: [], index: 0 };
    // other
    this.structureDidChange = true;
    this.instructionSet = new _rendering_renderers_shared_instructions_InstructionSet_mjs__WEBPACK_IMPORTED_MODULE_1__.InstructionSet();
    this._onRenderContainers = [];
    /**
     * Indicates if the cached texture needs to be updated.
     * @default true
     */
    this.textureNeedsUpdate = true;
    /**
     * Indicates if the container should be cached as a texture.
     * @default false
     */
    this.isCachedAsTexture = false;
    this._matrixDirty = 7;
  }
  init(root) {
    this.root = root;
    if (root._onRender)
      this.addOnRender(root);
    root.didChange = true;
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      child._updateFlags = 15;
      this.addChild(child);
    }
  }
  enableCacheAsTexture(options = {}) {
    this.textureOptions = options;
    this.isCachedAsTexture = true;
    this.textureNeedsUpdate = true;
  }
  disableCacheAsTexture() {
    this.isCachedAsTexture = false;
    if (this.texture) {
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_2__.TexturePool.returnTexture(this.texture);
      this.texture = null;
    }
  }
  updateCacheTexture() {
    this.textureNeedsUpdate = true;
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const i in this.childrenToUpdate) {
      const childrenAtDepth = this.childrenToUpdate[i];
      childrenAtDepth.list.fill(null);
      childrenAtDepth.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0;
    this.childrenRenderablesToUpdate.list.fill(null);
    this.root = null;
    this.updateTick = 0;
    this.structureDidChange = true;
    this._onRenderContainers.length = 0;
    this.renderGroupParent = null;
    this.disableCacheAsTexture();
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(renderGroupChild) {
    if (renderGroupChild.renderGroupParent) {
      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
    }
    renderGroupChild.renderGroupParent = this;
    this.renderGroupChildren.push(renderGroupChild);
  }
  _removeRenderGroupChild(renderGroupChild) {
    const index = this.renderGroupChildren.indexOf(renderGroupChild);
    if (index > -1) {
      this.renderGroupChildren.splice(index, 1);
    }
    renderGroupChild.renderGroupParent = null;
  }
  addChild(child) {
    this.structureDidChange = true;
    child.parentRenderGroup = this;
    child.updateTick = -1;
    if (child.parent === this.root) {
      child.relativeRenderGroupDepth = 1;
    } else {
      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
    }
    child.didChange = true;
    this.onChildUpdate(child);
    if (child.renderGroup) {
      this.addRenderGroupChild(child.renderGroup);
      return;
    }
    if (child._onRender)
      this.addOnRender(child);
    const children = child.children;
    for (let i = 0; i < children.length; i++) {
      this.addChild(children[i]);
    }
  }
  removeChild(child) {
    this.structureDidChange = true;
    if (child._onRender) {
      if (!child.renderGroup) {
        this.removeOnRender(child);
      }
    }
    child.parentRenderGroup = null;
    if (child.renderGroup) {
      this._removeRenderGroupChild(child.renderGroup);
      return;
    }
    const children = child.children;
    for (let i = 0; i < children.length; i++) {
      this.removeChild(children[i]);
    }
  }
  removeChildren(children) {
    for (let i = 0; i < children.length; i++) {
      this.removeChild(children[i]);
    }
  }
  onChildUpdate(child) {
    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
    if (!childrenToUpdate) {
      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      };
    }
    childrenToUpdate.list[childrenToUpdate.index++] = child;
  }
  updateRenderable(renderable) {
    if (renderable.globalDisplayStatus < 7)
      return;
    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
    renderable.didViewUpdate = false;
  }
  onChildViewUpdate(child) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(container) {
    this._onRenderContainers.push(container);
  }
  removeOnRender(container) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
  }
  runOnRender(renderer) {
    for (let i = 0; i < this._onRenderContainers.length; i++) {
      this._onRenderContainers[i]._onRender(renderer);
    }
  }
  destroy() {
    this.disableCacheAsTexture();
    this.renderGroupParent = null;
    this.root = null;
    this.childrenRenderablesToUpdate = null;
    this.childrenToUpdate = null;
    this.renderGroupChildren = null;
    this._onRenderContainers = null;
    this.instructionSet = null;
  }
  getChildren(out = []) {
    const children = this.root.children;
    for (let i = 0; i < children.length; i++) {
      this._getChildren(children[i], out);
    }
    return out;
  }
  _getChildren(container, out = []) {
    out.push(container);
    if (container.renderGroup)
      return out;
    const children = container.children;
    for (let i = 0; i < children.length; i++) {
      this._getChildren(children[i], out);
    }
    return out;
  }
  invalidateMatrices() {
    this._matrixDirty = 7;
  }
  /**
   * Returns the inverse of the world transform matrix.
   * @returns {Matrix} The inverse of the world transform matrix.
   */
  get inverseWorldTransform() {
    if ((this._matrixDirty & 1) === 0)
      return this._inverseWorldTransform;
    this._matrixDirty &= ~1;
    this._inverseWorldTransform || (this._inverseWorldTransform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix());
    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
  }
  /**
   * Returns the inverse of the texture offset transform matrix.
   * @returns {Matrix} The inverse of the texture offset transform matrix.
   */
  get textureOffsetInverseTransform() {
    if ((this._matrixDirty & 2) === 0)
      return this._textureOffsetInverseTransform;
    this._matrixDirty &= ~2;
    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix());
    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
      -this._textureBounds.x,
      -this._textureBounds.y
    );
  }
  /**
   * Returns the inverse of the parent texture transform matrix.
   * This is used to properly transform coordinates when rendering into cached textures.
   * @returns {Matrix} The inverse of the parent texture transform matrix.
   */
  get inverseParentTextureTransform() {
    if ((this._matrixDirty & 4) === 0)
      return this._inverseParentTextureTransform;
    this._matrixDirty &= ~4;
    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
    if (parentCacheAsTexture) {
      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix());
      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(
        -parentCacheAsTexture._textureBounds.x,
        -parentCacheAsTexture._textureBounds.y
      );
    }
    return this.worldTransform;
  }
  /**
   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
   * or null if no parent is cached as texture.
   */
  get cacheToLocalTransform() {
    if (!this._parentCacheAsTextureRenderGroup)
      return null;
    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
  }
}


//# sourceMappingURL=RenderGroup.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderGroupPipe: () => (/* binding */ RenderGroupPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sprite/BatchableSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");
/* harmony import */ var _utils_executeInstructions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/executeInstructions.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs");






"use strict";
const tempMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
class RenderGroupPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  addRenderGroup(renderGroup, instructionSet) {
    if (renderGroup.isCachedAsTexture) {
      this._addRenderableCacheAsTexture(renderGroup, instructionSet);
    } else {
      this._addRenderableDirect(renderGroup, instructionSet);
    }
  }
  execute(renderGroup) {
    if (!renderGroup.isRenderable)
      return;
    if (renderGroup.isCachedAsTexture) {
      this._executeCacheAsTexture(renderGroup);
    } else {
      this._executeDirect(renderGroup);
    }
  }
  destroy() {
    this._renderer = null;
  }
  _addRenderableDirect(renderGroup, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    if (renderGroup._batchableRenderGroup) {
      _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.BigPool.return(renderGroup._batchableRenderGroup);
      renderGroup._batchableRenderGroup = null;
    }
    instructionSet.add(renderGroup);
  }
  _addRenderableCacheAsTexture(renderGroup, instructionSet) {
    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.BigPool.get(_sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_2__.BatchableSprite));
    batchableRenderGroup.renderable = renderGroup.root;
    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
    batchableRenderGroup.texture = renderGroup.texture;
    batchableRenderGroup.bounds = renderGroup._textureBounds;
    instructionSet.add(renderGroup);
    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
  }
  _executeCacheAsTexture(renderGroup) {
    if (renderGroup.textureNeedsUpdate) {
      renderGroup.textureNeedsUpdate = false;
      const worldTransformMatrix = tempMatrix.identity().translate(
        -renderGroup._textureBounds.x,
        -renderGroup._textureBounds.y
      );
      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
      this._renderer.globalUniforms.push({
        worldTransformMatrix,
        worldColor: 4294967295
      });
      (0,_utils_executeInstructions_mjs__WEBPACK_IMPORTED_MODULE_3__.executeInstructions)(renderGroup, this._renderer.renderPipes);
      this._renderer.renderTarget.finishRenderPass();
      this._renderer.renderTarget.pop();
      this._renderer.globalUniforms.pop();
    }
    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
  }
  _executeDirect(renderGroup) {
    this._renderer.globalUniforms.push({
      worldTransformMatrix: renderGroup.inverseParentTextureTransform,
      worldColor: renderGroup.worldColorAlpha
    });
    (0,_utils_executeInstructions_mjs__WEBPACK_IMPORTED_MODULE_3__.executeInstructions)(renderGroup, this._renderer.renderPipes);
    this._renderer.globalUniforms.pop();
  }
}
RenderGroupPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.CanvasPipes
  ],
  name: "renderGroup"
};


//# sourceMappingURL=RenderGroupPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderGroupSystem: () => (/* binding */ RenderGroupSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _utils_clearList_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/clearList.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs");
/* harmony import */ var _utils_executeInstructions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/executeInstructions.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs");
/* harmony import */ var _utils_updateRenderGroupTransforms_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/updateRenderGroupTransforms.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs");
/* harmony import */ var _utils_validateRenderables_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/validateRenderables.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs");









"use strict";
const tempMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
class RenderGroupSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  render({ container, transform }) {
    const parent = container.parent;
    const renderGroupParent = container.renderGroup.renderGroupParent;
    container.parent = null;
    container.renderGroup.renderGroupParent = null;
    const renderer = this._renderer;
    let originalLocalTransform = tempMatrix;
    if (transform) {
      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);
      container.renderGroup.localTransform.copyFrom(transform);
    }
    const renderPipes = renderer.renderPipes;
    this._updateCachedRenderGroups(container.renderGroup, null);
    this._updateRenderGroups(container.renderGroup);
    renderer.globalUniforms.start({
      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
      worldColor: container.renderGroup.worldColorAlpha
    });
    (0,_utils_executeInstructions_mjs__WEBPACK_IMPORTED_MODULE_1__.executeInstructions)(container.renderGroup, renderPipes);
    if (renderPipes.uniformBatch) {
      renderPipes.uniformBatch.renderEnd();
    }
    if (transform) {
      container.renderGroup.localTransform.copyFrom(originalLocalTransform);
    }
    container.parent = parent;
    container.renderGroup.renderGroupParent = renderGroupParent;
  }
  destroy() {
    this._renderer = null;
  }
  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
    if (renderGroup.isCachedAsTexture) {
      if (!renderGroup.updateCacheTexture)
        return;
      closestCacheAsTexture = renderGroup;
    }
    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {
      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);
    }
    renderGroup.invalidateMatrices();
    if (renderGroup.isCachedAsTexture) {
      if (renderGroup.textureNeedsUpdate) {
        const bounds = renderGroup.root.getLocalBounds();
        bounds.ceil();
        const lastTexture = renderGroup.texture;
        if (renderGroup.texture) {
          _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_2__.TexturePool.returnTexture(renderGroup.texture);
        }
        const renderer = this._renderer;
        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;
        renderGroup.texture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_2__.TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          antialias
        );
        renderGroup._textureBounds || (renderGroup._textureBounds = new _bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_3__.Bounds());
        renderGroup._textureBounds.copyFrom(bounds);
        if (lastTexture !== renderGroup.texture) {
          if (renderGroup.renderGroupParent) {
            renderGroup.renderGroupParent.structureDidChange = true;
          }
        }
      }
    } else if (renderGroup.texture) {
      _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_2__.TexturePool.returnTexture(renderGroup.texture);
      renderGroup.texture = null;
    }
  }
  _updateRenderGroups(renderGroup) {
    const renderer = this._renderer;
    const renderPipes = renderer.renderPipes;
    renderGroup.runOnRender(renderer);
    renderGroup.instructionSet.renderPipes = renderPipes;
    if (!renderGroup.structureDidChange) {
      (0,_utils_validateRenderables_mjs__WEBPACK_IMPORTED_MODULE_4__.validateRenderables)(renderGroup, renderPipes);
    } else {
      (0,_utils_clearList_mjs__WEBPACK_IMPORTED_MODULE_5__.clearList)(renderGroup.childrenRenderablesToUpdate.list, 0);
    }
    (0,_utils_updateRenderGroupTransforms_mjs__WEBPACK_IMPORTED_MODULE_6__.updateRenderGroupTransforms)(renderGroup);
    if (renderGroup.structureDidChange) {
      renderGroup.structureDidChange = false;
      this._buildInstructions(renderGroup, renderer);
    } else {
      this._updateRenderables(renderGroup);
    }
    renderGroup.childrenRenderablesToUpdate.index = 0;
    renderer.renderPipes.batch.upload(renderGroup.instructionSet);
    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)
      return;
    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {
      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);
    }
  }
  _updateRenderables(renderGroup) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    for (let i = 0; i < index; i++) {
      const container = list[i];
      if (container.didViewUpdate) {
        renderGroup.updateRenderable(container);
      }
    }
    (0,_utils_clearList_mjs__WEBPACK_IMPORTED_MODULE_5__.clearList)(list, index);
  }
  _buildInstructions(renderGroup, rendererOrPipes) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    const renderPipes = renderer.renderPipes;
    renderPipes.batch.buildStart(instructionSet);
    renderPipes.blendMode.buildStart();
    renderPipes.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    root.collectRenderablesWithEffects(instructionSet, renderer, null);
    renderPipes.batch.buildEnd(instructionSet);
    renderPipes.blendMode.buildEnd(instructionSet);
  }
}
/** @ignore */
RenderGroupSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.CanvasSystem
  ],
  name: "renderGroup"
};


//# sourceMappingURL=RenderGroupSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bounds: () => (/* binding */ Bounds)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");



"use strict";
const defaultMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
class Bounds {
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    /** @default Infinity */
    this.minX = Infinity;
    /** @default Infinity */
    this.minY = Infinity;
    /** @default -Infinity */
    this.maxX = -Infinity;
    /** @default -Infinity */
    this.maxY = -Infinity;
    this.matrix = defaultMatrix;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Checks if bounds are empty.
   * @returns - True if empty.
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /** The bounding rectangle of the bounds. */
  get rectangle() {
    if (!this._rectangle) {
      this._rectangle = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    }
    const rectangle = this._rectangle;
    if (this.minX > this.maxX || this.minY > this.maxY) {
      rectangle.x = 0;
      rectangle.y = 0;
      rectangle.width = 0;
      rectangle.height = 0;
    } else {
      rectangle.copyFromBounds(this);
    }
    return rectangle;
  }
  /** Clears the bounds and resets. */
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.matrix = defaultMatrix;
    return this;
  }
  /**
   * Sets the bounds.
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   */
  set(x0, y0, x1, y1) {
    this.minX = x0;
    this.minY = y0;
    this.maxX = x1;
    this.maxY = y1;
  }
  /**
   * Adds sprite frame
   * @param x0 - left X of frame
   * @param y0 - top Y of frame
   * @param x1 - right X of frame
   * @param y1 - bottom Y of frame
   * @param matrix
   */
  addFrame(x0, y0, x1, y1, matrix) {
    matrix || (matrix = this.matrix);
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = a * x0 + c * y0 + tx;
    let y = b * x0 + d * y0 + ty;
    if (x < minX)
      minX = x;
    if (y < minY)
      minY = y;
    if (x > maxX)
      maxX = x;
    if (y > maxY)
      maxY = y;
    x = a * x1 + c * y0 + tx;
    y = b * x1 + d * y0 + ty;
    if (x < minX)
      minX = x;
    if (y < minY)
      minY = y;
    if (x > maxX)
      maxX = x;
    if (y > maxY)
      maxY = y;
    x = a * x0 + c * y1 + tx;
    y = b * x0 + d * y1 + ty;
    if (x < minX)
      minX = x;
    if (y < minY)
      minY = y;
    if (x > maxX)
      maxX = x;
    if (y > maxY)
      maxY = y;
    x = a * x1 + c * y1 + tx;
    y = b * x1 + d * y1 + ty;
    if (x < minX)
      minX = x;
    if (y < minY)
      minY = y;
    if (x > maxX)
      maxX = x;
    if (y > maxY)
      maxY = y;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Adds a rectangle to the bounds.
   * @param rect - The rectangle to be added.
   * @param matrix - The matrix to apply to the bounds.
   */
  addRect(rect, matrix) {
    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
  }
  /**
   * Adds other {@link Bounds}.
   * @param bounds - The Bounds to be added
   * @param matrix
   */
  addBounds(bounds, matrix) {
    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
  }
  /**
   * Adds other Bounds, masked with Bounds.
   * @param mask - The Bounds to be added.
   */
  addBoundsMask(mask) {
    this.minX = this.minX > mask.minX ? this.minX : mask.minX;
    this.minY = this.minY > mask.minY ? this.minY : mask.minY;
    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
  }
  /**
   * Adds other Bounds, multiplied with matrix.
   * @param matrix - The matrix to apply to the bounds.
   */
  applyMatrix(matrix) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    const { a, b, c, d, tx, ty } = matrix;
    let x = a * minX + c * minY + tx;
    let y = b * minX + d * minY + ty;
    this.minX = x;
    this.minY = y;
    this.maxX = x;
    this.maxY = y;
    x = a * maxX + c * minY + tx;
    y = b * maxX + d * minY + ty;
    this.minX = x < this.minX ? x : this.minX;
    this.minY = y < this.minY ? y : this.minY;
    this.maxX = x > this.maxX ? x : this.maxX;
    this.maxY = y > this.maxY ? y : this.maxY;
    x = a * minX + c * maxY + tx;
    y = b * minX + d * maxY + ty;
    this.minX = x < this.minX ? x : this.minX;
    this.minY = y < this.minY ? y : this.minY;
    this.maxX = x > this.maxX ? x : this.maxX;
    this.maxY = y > this.maxY ? y : this.maxY;
    x = a * maxX + c * maxY + tx;
    y = b * maxX + d * maxY + ty;
    this.minX = x < this.minX ? x : this.minX;
    this.minY = y < this.minY ? y : this.minY;
    this.maxX = x > this.maxX ? x : this.maxX;
    this.maxY = y > this.maxY ? y : this.maxY;
  }
  /**
   * Resizes the bounds object to include the given rectangle.
   * @param rect - The rectangle to be included.
   */
  fit(rect) {
    if (this.minX < rect.left)
      this.minX = rect.left;
    if (this.maxX > rect.right)
      this.maxX = rect.right;
    if (this.minY < rect.top)
      this.minY = rect.top;
    if (this.maxY > rect.bottom)
      this.maxY = rect.bottom;
    return this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * @param left - The left value of the bounds.
   * @param right - The right value of the bounds.
   * @param top - The top value of the bounds.
   * @param bottom - The bottom value of the bounds.
   */
  fitBounds(left, right, top, bottom) {
    if (this.minX < left)
      this.minX = left;
    if (this.maxX > right)
      this.maxX = right;
    if (this.minY < top)
      this.minY = top;
    if (this.maxY > bottom)
      this.maxY = bottom;
    return this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   */
  pad(paddingX, paddingY = paddingX) {
    this.minX -= paddingX;
    this.maxX += paddingX;
    this.minY -= paddingY;
    this.maxY += paddingY;
    return this;
  }
  /** Ceils the bounds. */
  ceil() {
    this.minX = Math.floor(this.minX);
    this.minY = Math.floor(this.minY);
    this.maxX = Math.ceil(this.maxX);
    this.maxY = Math.ceil(this.maxY);
    return this;
  }
  /** Clones the bounds. */
  clone() {
    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values
   * @param x - The X value to scale by.
   * @param y - The Y value to scale by.
   */
  scale(x, y = x) {
    this.minX *= x;
    this.minY *= y;
    this.maxX *= x;
    this.maxY *= y;
    return this;
  }
  /** the x value of the bounds. */
  get x() {
    return this.minX;
  }
  set x(value) {
    const width = this.maxX - this.minX;
    this.minX = value;
    this.maxX = value + width;
  }
  /** the y value of the bounds. */
  get y() {
    return this.minY;
  }
  set y(value) {
    const height = this.maxY - this.minY;
    this.minY = value;
    this.maxY = value + height;
  }
  /** the width value of the bounds. */
  get width() {
    return this.maxX - this.minX;
  }
  set width(value) {
    this.maxX = this.minX + value;
  }
  /** the height value of the bounds. */
  get height() {
    return this.maxY - this.minY;
  }
  set height(value) {
    this.maxY = this.minY + value;
  }
  /** the left value of the bounds. */
  get left() {
    return this.minX;
  }
  /** the right value of the bounds. */
  get right() {
    return this.maxX;
  }
  /** the top value of the bounds. */
  get top() {
    return this.minY;
  }
  /** the bottom value of the bounds. */
  get bottom() {
    return this.maxY;
  }
  /** Is the bounds positive. */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  get isValid() {
    return this.minX + this.minY !== Infinity;
  }
  /**
   * Adds screen vertices from array
   * @param vertexData - calculated vertices
   * @param beginOffset - begin offset
   * @param endOffset - end offset, excluded
   * @param matrix
   */
  addVertexData(vertexData, beginOffset, endOffset, matrix) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    matrix || (matrix = this.matrix);
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const localX = vertexData[i];
      const localY = vertexData[i + 1];
      const x = a * localX + c * localY + tx;
      const y = b * localX + d * localY + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Checks if the point is contained within the bounds.
   * @param x - x coordinate
   * @param y - y coordinate
   */
  containsPoint(x, y) {
    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {
      return true;
    }
    return false;
  }
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
  /**
   * Copies the bounds from another bounds object.
   * @param bounds - The bounds to copy from.
   * @returns - This bounds object.
   */
  copyFrom(bounds) {
    this.minX = bounds.minX;
    this.minY = bounds.minY;
    this.maxX = bounds.maxX;
    this.maxY = bounds.maxY;
    return this;
  }
}


//# sourceMappingURL=Bounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFastGlobalBounds: () => (/* binding */ getFastGlobalBounds)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");


"use strict";
function getFastGlobalBounds(target, bounds) {
  (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)("8.7.0", "Use container.getFastGlobalBounds() instead");
  return target.getFastGlobalBounds(true, bounds);
}


//# sourceMappingURL=getFastGlobalBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _getGlobalBounds: () => (/* binding */ _getGlobalBounds),
/* harmony export */   getGlobalBounds: () => (/* binding */ getGlobalBounds),
/* harmony export */   updateTransformBackwards: () => (/* binding */ updateTransformBackwards)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrixAndBoundsPool.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");



"use strict";
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  let pooledMatrix;
  if (target.parent) {
    if (!skipUpdateTransform) {
      pooledMatrix = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.matrixPool.get().identity();
      parentTransform = updateTransformBackwards(target, pooledMatrix);
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (pooledMatrix) {
    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.matrixPool.return(pooledMatrix);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    target.updateLocalTransform();
    worldTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.matrixPool.get();
    worldTransform.appendFrom(target.localTransform, parentTransform);
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, worldTransform);
  } else {
    if (target.bounds) {
      bounds.matrix = worldTransform;
      bounds.addBounds(target.bounds);
    }
    for (let i = 0; i < target.children.length; i++) {
      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);
    }
  }
  if (preserveBounds) {
    for (let i = 0; i < target.effects.length; i++) {
      target.effects[i].addBounds?.(bounds);
    }
    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.Matrix.IDENTITY);
    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.boundsPool.return(bounds);
  }
  if (!skipUpdateTransform) {
    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_0__.matrixPool.return(worldTransform);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    parent.updateLocalTransform();
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}


//# sourceMappingURL=getGlobalBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLocalBounds: () => (/* binding */ getLocalBounds),
/* harmony export */   getParent: () => (/* binding */ getParent)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/matrixAndBoundsPool.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");




"use strict";
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix.IDENTITY);
  _getLocalBounds(target, bounds, relativeMatrix, target, true);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
  let relativeTransform;
  if (!isRoot) {
    if (!target.visible || !target.measurable)
      return;
    target.updateLocalTransform();
    const localTransform = target.localTransform;
    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.get();
    relativeTransform.appendFrom(localTransform, parentTransform);
  } else {
    relativeTransform = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.get();
    relativeTransform = parentTransform.copyTo(relativeTransform);
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, relativeTransform);
  } else {
    if (target.renderPipeId) {
      bounds.matrix = relativeTransform;
      bounds.addBounds(target.bounds);
    }
    const children = target.children;
    for (let i = 0; i < children.length; i++) {
      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);
    }
  }
  if (preserveBounds) {
    for (let i = 0; i < target.effects.length; i++) {
      target.effects[i].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.addBounds(bounds, _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix.IDENTITY);
    _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.boundsPool.return(bounds);
  }
  _utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.return(relativeTransform);
}
function getParent(target, root, matrix) {
  const parent = target.parent;
  if (!parent) {
    (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("Item is not inside the root container");
    return;
  }
  if (parent !== root) {
    getParent(parent, root, matrix);
    parent.updateLocalTransform();
    matrix.append(parent.localTransform);
  }
}


//# sourceMappingURL=getLocalBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobalRenderableBounds: () => (/* binding */ getGlobalRenderableBounds)
/* harmony export */ });

function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const tempMatrix = bounds.matrix;
  for (let i = 0; i < renderables.length; i++) {
    const renderable = renderables[i];
    if (renderable.globalDisplayStatus < 7) {
      continue;
    }
    bounds.matrix = renderable.worldTransform;
    bounds.addBounds(renderable.bounds);
  }
  bounds.matrix = tempMatrix;
  return bounds;
}


//# sourceMappingURL=getRenderableBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   boundsPool: () => (/* binding */ boundsPool),
/* harmony export */   matrixPool: () => (/* binding */ matrixPool)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/pool/Pool.mjs */ "./node_modules/pixi.js/lib/utils/pool/Pool.mjs");
/* harmony import */ var _Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");




"use strict";
const matrixPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__.Pool(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.Matrix);
const boundsPool = new _utils_pool_Pool_mjs__WEBPACK_IMPORTED_MODULE_0__.Pool(_Bounds_mjs__WEBPACK_IMPORTED_MODULE_2__.Bounds);


//# sourceMappingURL=matrixAndBoundsPool.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cacheAsTextureMixin: () => (/* binding */ cacheAsTextureMixin)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");


"use strict";
const cacheAsTextureMixin = {
  /**
   * Is this container cached as a texture?
   * @readonly
   * @type {boolean}
   * @memberof scene.Container#
   */
  get isCachedAsTexture() {
    return !!this.renderGroup?.isCachedAsTexture;
  },
  cacheAsTexture(val) {
    if (typeof val === "boolean" && val === false) {
      this.disableRenderGroup();
    } else {
      this.enableRenderGroup();
      this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
    }
  },
  /**
   * Updates the cached texture. Will flag that this container's cached texture needs to be redrawn.
   * This will happen on the next render.
   * @memberof scene.Container#
   */
  updateCacheTexture() {
    this.renderGroup?.updateCacheTexture();
  },
  /**
   * Allows backwards compatibility with pixi.js below version v8. Use `cacheAsTexture` instead.
   * @deprecated
   */
  get cacheAsBitmap() {
    return this.isCachedAsTexture;
  },
  /**
   * @deprecated
   */
  set cacheAsBitmap(val) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
    this.cacheAsTexture(val);
  }
};


//# sourceMappingURL=cacheAsTextureMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childrenHelperMixin: () => (/* binding */ childrenHelperMixin)
/* harmony export */ });
/* harmony import */ var _utils_data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/data/removeItems.mjs */ "./node_modules/pixi.js/lib/utils/data/removeItems.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");



"use strict";
const childrenHelperMixin = {
  allowChildren: true,
  /**
   * Removes all children from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed children
   * @memberof scene.Container#
   */
  removeChildren(beginIndex = 0, endIndex) {
    const end = endIndex ?? this.children.length;
    const range = end - beginIndex;
    const removed = [];
    if (range > 0 && range <= end) {
      for (let i = end - 1; i >= beginIndex; i--) {
        const child = this.children[i];
        if (!child)
          continue;
        removed.push(child);
        child.parent = null;
      }
      (0,_utils_data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_0__.removeItems)(this.children, beginIndex, end);
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.removeChildren(removed);
      }
      for (let i = 0; i < removed.length; ++i) {
        const child = removed[i];
        child.parentRenderLayer?.detach(child);
        this.emit("childRemoved", child, this, i);
        removed[i].emit("removed", this);
      }
      if (removed.length > 0) {
        this._didViewChangeTick++;
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return removed;
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  /**
   * Removes a child from the specified index position.
   * @param index - The index to get the child from
   * @returns The child that was removed.
   * @memberof scene.Container#
   */
  removeChildAt(index) {
    const child = this.getChildAt(index);
    return this.removeChild(child);
  },
  /**
   * Returns the child at the specified index
   * @param index - The index to get the child at
   * @returns - The child at the given index, if any.
   * @memberof scene.Container#
   */
  getChildAt(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  },
  /**
   * Changes the position of an existing child in the container
   * @param child - The child Container instance for which you want to change the index number
   * @param index - The resulting index number for the child container
   * @memberof scene.Container#
   */
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    this.getChildIndex(child);
    this.addChildAt(child, index);
  },
  /**
   * Returns the index position of a child Container instance
   * @param child - The Container instance to identify
   * @returns - The index position of the child container to identify
   * @memberof scene.Container#
   */
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied Container must be a child of the caller");
    }
    return index;
  },
  /**
   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the child is already in this container, it will be moved to the specified index.
   * @param {Container} child - The child to add.
   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
   * @returns {Container} The child that was added.
   * @memberof scene.Container#
   */
  addChildAt(child, index) {
    if (!this.allowChildren) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    }
    const { children } = this;
    if (index < 0 || index > children.length) {
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
    }
    if (child.parent) {
      const currentIndex = child.parent.children.indexOf(child);
      if (child.parent === this && currentIndex === index) {
        return child;
      }
      if (currentIndex !== -1) {
        child.parent.children.splice(currentIndex, 1);
      }
    }
    if (index === children.length) {
      children.push(child);
    } else {
      children.splice(index, 0, child);
    }
    child.parent = this;
    child.didChange = true;
    child._updateFlags = 15;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.addChild(child);
    }
    if (this.sortableChildren)
      this.sortDirty = true;
    this.emit("childAdded", child, this, index);
    child.emit("added", this);
    return child;
  },
  /**
   * Swaps the position of 2 Containers within this container.
   * @param child - First container to swap
   * @param child2 - Second container to swap
   * @memberof scene.Container#
   */
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.structureDidChange = true;
    }
    this._didContainerChangeTick++;
  },
  /**
   * Remove the Container from its parent Container. If the Container has no parent, do nothing.
   * @memberof scene.Container#
   */
  removeFromParent() {
    this.parent?.removeChild(this);
  },
  /**
   * Reparent the child to this container, keeping the same worldTransform.
   * @param child - The child to reparent
   * @returns The first child that was reparented.
   * @memberof scene.Container#
   */
  reparentChild(...child) {
    if (child.length === 1) {
      return this.reparentChildAt(child[0], this.children.length);
    }
    child.forEach((c) => this.reparentChildAt(c, this.children.length));
    return child[0];
  },
  /**
   * Reparent the child to this container at the specified index, keeping the same worldTransform.
   * @param child - The child to reparent
   * @param index - The index to reparent the child to
   * @memberof scene.Container#
   */
  reparentChildAt(child, index) {
    if (child.parent === this) {
      this.setChildIndex(child, index);
      return child;
    }
    const childMat = child.worldTransform.clone();
    child.removeFromParent();
    this.addChildAt(child, index);
    const newMatrix = this.worldTransform.clone();
    newMatrix.invert();
    childMat.prepend(newMatrix);
    child.setFromMatrix(childMat);
    return child;
  }
};


//# sourceMappingURL=childrenHelperMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   collectRenderablesMixin: () => (/* binding */ collectRenderablesMixin)
/* harmony export */ });

const collectRenderablesMixin = {
  /**
   * Main method to collect renderables from the container and its children.
   * It checks the container's properties to decide whether to use a simple or advanced collection method.
   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
   * @param {Renderer} renderer - The renderer responsible for rendering the scene.
   * @param {IRenderLayer} currentLayer - The current render layer being processed.
   * @memberof scene.Container#
   */
  collectRenderables(instructionSet, renderer, currentLayer) {
    if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)
      return;
    if (this.sortableChildren) {
      this.sortChildren();
    }
    if (this.isSimple) {
      this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
    } else if (this.renderGroup) {
      renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
    } else {
      this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
    }
  },
  /**
   * Simple method for collecting renderables from the container's children.
   * This method is efficient and used when the container is marked as simple.
   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
   * @param {Renderer} renderer - The renderer responsible for rendering the scene.
   * @param {IRenderLayer} currentLayer - The current render layer being processed.
   * @memberof scene.Container#
   */
  collectRenderablesSimple(instructionSet, renderer, currentLayer) {
    const children = this.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      children[i].collectRenderables(instructionSet, renderer, currentLayer);
    }
  },
  /**
   * Advanced method for collecting renderables, which handles additional effects.
   * This method is used when the container has complex processing needs.
   * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
   * @param {Renderer} renderer - The renderer responsible for rendering the scene.
   * @param {IRenderLayer} currentLayer - The current render layer being processed.
   * @memberof scene.Container#
   */
  collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
    const { renderPipes } = renderer;
    for (let i = 0; i < this.effects.length; i++) {
      const effect = this.effects[i];
      const pipe = renderPipes[effect.pipe];
      pipe.push(effect, this, instructionSet);
    }
    this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
    for (let i = this.effects.length - 1; i >= 0; i--) {
      const effect = this.effects[i];
      const pipe = renderPipes[effect.pipe];
      pipe.pop(effect, this, instructionSet);
    }
  }
};


//# sourceMappingURL=collectRenderablesMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   effectsMixin: () => (/* binding */ effectsMixin)
/* harmony export */ });
/* harmony import */ var _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../filters/FilterEffect.mjs */ "./node_modules/pixi.js/lib/filters/FilterEffect.mjs");
/* harmony import */ var _rendering_mask_MaskEffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/mask/MaskEffectManager.mjs */ "./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs");



"use strict";
const effectsMixin = {
  _maskEffect: null,
  _maskOptions: {
    inverse: false
  },
  _filterEffect: null,
  /**
   * @todo Needs docs.
   * @memberof scene.Container#
   * @type {Array<Effect>}
   */
  effects: [],
  _markStructureAsChanged() {
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.structureDidChange = true;
    }
  },
  /**
   * @todo Needs docs.
   * @param effect - The effect to add.
   * @memberof scene.Container#
   * @ignore
   */
  addEffect(effect) {
    const index = this.effects.indexOf(effect);
    if (index !== -1)
      return;
    this.effects.push(effect);
    this.effects.sort((a, b) => a.priority - b.priority);
    this._markStructureAsChanged();
    this._updateIsSimple();
  },
  /**
   * @todo Needs docs.
   * @param effect - The effect to remove.
   * @memberof scene.Container#
   * @ignore
   */
  removeEffect(effect) {
    const index = this.effects.indexOf(effect);
    if (index === -1)
      return;
    this.effects.splice(index, 1);
    this._markStructureAsChanged();
    this._updateIsSimple();
  },
  set mask(value) {
    const effect = this._maskEffect;
    if (effect?.mask === value)
      return;
    if (effect) {
      this.removeEffect(effect);
      _rendering_mask_MaskEffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__.MaskEffectManager.returnMaskEffect(effect);
      this._maskEffect = null;
    }
    if (value === null || value === void 0)
      return;
    this._maskEffect = _rendering_mask_MaskEffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__.MaskEffectManager.getMaskEffect(value);
    this.addEffect(this._maskEffect);
  },
  /**
   * Used to set mask and control mask options.
   * @param options
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.setMask({
   *     mask: graphics,
   *     inverse: true,
   * });
   * @memberof scene.Container#
   */
  setMask(options) {
    this._maskOptions = {
      ...this._maskOptions,
      ...options
    };
    if (options.mask) {
      this.mask = options.mask;
    }
    this._markStructureAsChanged();
  },
  /**
   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
   * To remove a mask, set this property to `null`.
   *
   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
   * @example
   * import { Graphics, Sprite } from 'pixi.js';
   *
   * const graphics = new Graphics();
   * graphics.beginFill(0xFF3300);
   * graphics.drawRect(50, 250, 100, 100);
   * graphics.endFill();
   *
   * const sprite = new Sprite(texture);
   * sprite.mask = graphics;
   * @memberof scene.Container#
   */
  get mask() {
    return this._maskEffect?.mask;
  },
  set filters(value) {
    if (!Array.isArray(value) && value)
      value = [value];
    const effect = this._filterEffect || (this._filterEffect = new _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_1__.FilterEffect());
    value = value;
    const hasFilters = value?.length > 0;
    const hadFilters = effect.filters?.length > 0;
    const didChange = hasFilters !== hadFilters;
    value = Array.isArray(value) ? value.slice(0) : value;
    effect.filters = Object.freeze(value);
    if (didChange) {
      if (hasFilters) {
        this.addEffect(effect);
      } else {
        this.removeEffect(effect);
        effect.filters = value ?? null;
      }
    }
  },
  /**
   * Sets the filters for the displayObject.
   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
   * To remove filters simply set this property to `'null'`.
   * @memberof scene.Container#
   */
  get filters() {
    return this._filterEffect?.filters;
  },
  set filterArea(value) {
    this._filterEffect || (this._filterEffect = new _filters_FilterEffect_mjs__WEBPACK_IMPORTED_MODULE_1__.FilterEffect());
    this._filterEffect.filterArea = value;
  },
  /**
   * The area the filter is applied to. This is used as more of an optimization
   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
   *
   * Also works as an interaction mask.
   * @memberof scene.Container#
   */
  get filterArea() {
    return this._filterEffect?.filterArea;
  }
};


//# sourceMappingURL=effectsMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findMixin: () => (/* binding */ findMixin)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");


"use strict";
const findMixin = {
  /**
   * The instance label of the object.
   * @memberof scene.Container#
   * @member {string} label
   */
  label: null,
  /**
   * The instance name of the object.
   * @deprecated since 8.0.0
   * @see scene.Container#label
   * @member {string} name
   * @memberof scene.Container#
   */
  get name() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.v8_0_0, "Container.name property has been removed, use Container.label instead");
    return this.label;
  },
  set name(value) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.v8_0_0, "Container.name property has been removed, use Container.label instead");
    this.label = value;
  },
  /**
   * @method getChildByName
   * @deprecated since 8.0.0
   * @param {string} name - Instance name.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified name.
   * @see scene.Container#getChildByLabel
   * @memberof scene.Container#
   */
  getChildByName(name, deep = false) {
    return this.getChildByLabel(name, deep);
  },
  /**
   * Returns the first child in the container with the specified label.
   *
   * Recursive searches are done in a pre-order traversal.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @returns {Container} The child with the specified label.
   */
  getChildByLabel(label, deep = false) {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.label === label || label instanceof RegExp && label.test(child.label))
        return child;
    }
    if (deep) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const found = child.getChildByLabel(label, true);
        if (found) {
          return found;
        }
      }
    }
    return null;
  },
  /**
   * Returns all children in the container with the specified label.
   * @memberof scene.Container#
   * @param {string|RegExp} label - Instance label.
   * @param {boolean}[deep=false] - Whether to search recursively
   * @param {Container[]} [out=[]] - The array to store matching children in.
   * @returns {Container[]} An array of children with the specified label.
   */
  getChildrenByLabel(label, deep = false, out = []) {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.label === label || label instanceof RegExp && label.test(child.label)) {
        out.push(child);
      }
    }
    if (deep) {
      for (let i = 0; i < children.length; i++) {
        children[i].getChildrenByLabel(label, true, out);
      }
    }
    return out;
  }
};


//# sourceMappingURL=findMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFastGlobalBoundsMixin: () => (/* binding */ getFastGlobalBoundsMixin)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bounds/utils/matrixAndBoundsPool.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");




"use strict";
const tempMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
const getFastGlobalBoundsMixin = {
  /**
   * Computes the global bounds for the container, considering its children and optionally
   * factoring in render layers. It starts by clearing the provided bounds object, then
   * recursively calculates the bounds, and finally applies the world transformation.
   * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.
   * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.
   * @returns {Bounds} The computed bounds.
   * @memberof scene.Container#
   */
  getFastGlobalBounds(factorRenderLayers, bounds) {
    bounds || (bounds = new _bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds());
    bounds.clear();
    this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    bounds.applyMatrix(renderGroup.worldTransform);
    return bounds;
  },
  /**
   * Recursively calculates the global bounds for the container and its children.
   * It considers visibility, measurability, and effects, and applies transformations
   * as necessary to compute the bounds accurately.
   * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.
   * @param {Bounds} bounds - The bounds object to update with the calculated values.
   * @param {IRenderLayer} currentLayer - The current render layer being processed.
   * @memberof scene.Container#
   */
  _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
    let localBounds = bounds;
    if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)
      return;
    if (this.localDisplayStatus !== 7 || !this.measurable) {
      return;
    }
    const manageEffects = !!this.effects.length;
    if (this.renderGroup || manageEffects) {
      localBounds = _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_2__.boundsPool.get().clear();
    }
    if (this.boundsArea) {
      bounds.addRect(this.boundsArea, this.worldTransform);
    } else {
      if (this.renderPipeId) {
        const viewBounds = this.bounds;
        localBounds.addFrame(
          viewBounds.minX,
          viewBounds.minY,
          viewBounds.maxX,
          viewBounds.maxY,
          this.groupTransform
        );
      }
      const children = this.children;
      for (let i = 0; i < children.length; i++) {
        children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
      }
    }
    if (manageEffects) {
      let advanced = false;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      for (let i = 0; i < this.effects.length; i++) {
        if (this.effects[i].addBounds) {
          if (!advanced) {
            advanced = true;
            localBounds.applyMatrix(renderGroup.worldTransform);
          }
          this.effects[i].addBounds(localBounds, true);
        }
      }
      if (advanced) {
        localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());
        bounds.addBounds(localBounds, this.relativeGroupTransform);
      }
      bounds.addBounds(localBounds);
      _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_2__.boundsPool.return(localBounds);
    } else if (this.renderGroup) {
      bounds.addBounds(localBounds, this.relativeGroupTransform);
      _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_2__.boundsPool.return(localBounds);
    }
  }
};


//# sourceMappingURL=getFastGlobalBoundsMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bgr2rgb: () => (/* binding */ bgr2rgb),
/* harmony export */   getGlobalMixin: () => (/* binding */ getGlobalMixin)
/* harmony export */ });
/* harmony import */ var _bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bounds/getGlobalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs");
/* harmony import */ var _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bounds/utils/matrixAndBoundsPool.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");
/* harmony import */ var _utils_multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/multiplyColors.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs");




"use strict";
function bgr2rgb(color) {
  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
}
const getGlobalMixin = {
  /**
   * Returns the global (compound) alpha of the container within the scene.
   * @param skipUpdate - Performance optimization flag:
   *   - If false (default): Recalculates the entire alpha chain through parents for accuracy
   *   - If true: Uses cached worldAlpha from the last render pass for better performance
   * @returns The resulting alpha value (between 0 and 1)
   * @example
   * // Accurate but slower - recalculates entire alpha chain
   * const preciseAlpha = container.getGlobalAlpha();
   *
   * // Faster but may be outdated - uses cached alpha
   * const cachedAlpha = container.getGlobalAlpha(true);
   */
  getGlobalAlpha(skipUpdate) {
    if (skipUpdate) {
      if (this.renderGroup) {
        return this.renderGroup.worldAlpha;
      }
      if (this.parentRenderGroup) {
        return this.parentRenderGroup.worldAlpha * this.alpha;
      }
      return this.alpha;
    }
    let alpha = this.alpha;
    let current = this.parent;
    while (current) {
      alpha *= current.alpha;
      current = current.parent;
    }
    return alpha;
  },
  /**
   * Returns the global transform matrix of the container within the scene.
   * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.
   * @param skipUpdate - Performance optimization flag:
   *   - If false (default): Recalculates the entire transform chain for accuracy
   *   - If true: Uses cached worldTransform from the last render pass for better performance
   * @returns The resulting transformation matrix (either the input matrix or a new one)
   * @example
   * // Accurate but slower - recalculates entire transform chain
   * const preciseTransform = container.getGlobalTransform();
   *
   * // Faster but may be outdated - uses cached transform
   * const cachedTransform = container.getGlobalTransform(undefined, true);
   *
   * // Reuse existing matrix
   * const existingMatrix = new Matrix();
   * container.getGlobalTransform(existingMatrix);
   */
  getGlobalTransform(matrix, skipUpdate) {
    if (skipUpdate) {
      return matrix.copyFrom(this.worldTransform);
    }
    this.updateLocalTransform();
    const parentTransform = (0,_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_0__.updateTransformBackwards)(this, _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.get().identity());
    matrix.appendFrom(this.localTransform, parentTransform);
    _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.return(parentTransform);
    return matrix;
  },
  /**
   * Returns the global (compound) tint color of the container within the scene.
   * @param skipUpdate - Performance optimization flag:
   *   - If false (default): Recalculates the entire tint chain through parents for accuracy
   *   - If true: Uses cached worldColor from the last render pass for better performance
   * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)
   * @example
   * // Accurate but slower - recalculates entire tint chain
   * const preciseTint = container.getGlobalTint();
   *
   * // Faster but may be outdated - uses cached tint
   * const cachedTint = container.getGlobalTint(true);
   */
  getGlobalTint(skipUpdate) {
    if (skipUpdate) {
      if (this.renderGroup) {
        return bgr2rgb(this.renderGroup.worldColor);
      }
      if (this.parentRenderGroup) {
        return bgr2rgb(
          (0,_utils_multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_2__.multiplyColors)(this.localColor, this.parentRenderGroup.worldColor)
        );
      }
      return this.tint;
    }
    let color = this.localColor;
    let parent = this.parent;
    while (parent) {
      color = (0,_utils_multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_2__.multiplyColors)(color, parent.localColor);
      parent = parent.parent;
    }
    return bgr2rgb(color);
  }
};


//# sourceMappingURL=getGlobalMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   measureMixin: () => (/* binding */ measureMixin)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../bounds/getGlobalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs");
/* harmony import */ var _bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bounds/getLocalBounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs");
/* harmony import */ var _utils_checkChildrenDidChange_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/checkChildrenDidChange.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs");






"use strict";
const tempMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
const measureMixin = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(value, localWidth) {
    const sign = Math.sign(this.scale.x) || 1;
    if (localWidth !== 0) {
      this.scale.x = value / localWidth * sign;
    } else {
      this.scale.x = sign;
    }
  },
  _setHeight(value, localHeight) {
    const sign = Math.sign(this.scale.y) || 1;
    if (localHeight !== 0) {
      this.scale.y = value / localHeight * sign;
    } else {
      this.scale.y = sign;
    }
  },
  /**
   * Retrieves the local bounds of the container as a Bounds object.
   * @returns - The bounding area.
   * @memberof scene.Container#
   */
  getLocalBounds() {
    if (!this._localBoundsCacheData) {
      this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new _bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds()
      };
    }
    const localBoundsCacheData = this._localBoundsCacheData;
    localBoundsCacheData.index = 1;
    localBoundsCacheData.didChange = false;
    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
      localBoundsCacheData.didChange = true;
      localBoundsCacheData.data[0] = this._didViewChangeTick;
    }
    (0,_utils_checkChildrenDidChange_mjs__WEBPACK_IMPORTED_MODULE_2__.checkChildrenDidChange)(this, localBoundsCacheData);
    if (localBoundsCacheData.didChange) {
      (0,_bounds_getLocalBounds_mjs__WEBPACK_IMPORTED_MODULE_3__.getLocalBounds)(this, localBoundsCacheData.localBounds, tempMatrix);
    }
    return localBoundsCacheData.localBounds;
  },
  /**
   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
   *  being updated. This means the calculation returned MAY be out of date BUT will give you a
   *  nice performance boost.
   * @param bounds - Optional bounds to store the result of the bounds calculation.
   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
   * @memberof scene.Container#
   */
  getBounds(skipUpdate, bounds) {
    return (0,_bounds_getGlobalBounds_mjs__WEBPACK_IMPORTED_MODULE_4__.getGlobalBounds)(this, skipUpdate, bounds || new _bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds());
  }
};


//# sourceMappingURL=measureMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onRenderMixin: () => (/* binding */ onRenderMixin)
/* harmony export */ });

const onRenderMixin = {
  _onRender: null,
  set onRender(func) {
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (!func) {
      if (this._onRender) {
        renderGroup?.removeOnRender(this);
      }
      this._onRender = null;
      return;
    }
    if (!this._onRender) {
      renderGroup?.addOnRender(this);
    }
    this._onRender = func;
  },
  /**
   * This callback is used when the container is rendered. This is where you should add your custom
   * logic that is needed to be run every frame.
   *
   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
   * and "updateTransform" is no longer called every frame
   * @example
   * const container = new Container();
   * container.onRender = () => {
   *    container.rotation += 0.01;
   * };
   * @memberof scene.Container#
   */
  get onRender() {
    return this._onRender;
  }
};


//# sourceMappingURL=onRenderMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sortMixin: () => (/* binding */ sortMixin)
/* harmony export */ });

const sortMixin = {
  _zIndex: 0,
  /**
   * Should children be sorted by zIndex at the next render call.
   *
   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortDirty: false,
  /**
   * If set to true, the container will sort its children by `zIndex` value
   * when the next render is called, or manually if `sortChildren()` is called.
   *
   * This actually changes the order of elements in the array, so should be treated
   * as a basic solution that is not performant compared to other solutions,
   * such as {@link https://github.com/pixijs/layers PixiJS Layers}
   *
   * Also be aware of that this may not work nicely with the `addChildAt()` function,
   * as the `zIndex` sorting may cause the child to automatically sorted to another position.
   * @type {boolean}
   * @memberof scene.Container#
   */
  sortableChildren: false,
  /**
   * The zIndex of the container.
   *
   * Setting this value, will automatically set the parent to be sortable. Children will be automatically
   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
   * and thus rendered on top of other display objects within the same container.
   * @see scene.Container#sortableChildren
   * @memberof scene.Container#
   */
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(value) {
    if (this._zIndex === value)
      return;
    this._zIndex = value;
    this.depthOfChildModified();
  },
  depthOfChildModified() {
    if (this.parent) {
      this.parent.sortableChildren = true;
      this.parent.sortDirty = true;
    }
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
  },
  /**
   * Sorts children by zIndex.
   * @memberof scene.Container#
   */
  sortChildren() {
    if (!this.sortDirty)
      return;
    this.sortDirty = false;
    this.children.sort(sortChildren);
  }
};
function sortChildren(a, b) {
  return a._zIndex - b._zIndex;
}


//# sourceMappingURL=sortMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toLocalGlobalMixin: () => (/* binding */ toLocalGlobalMixin)
/* harmony export */ });
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bounds/utils/matrixAndBoundsPool.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs");



"use strict";
const toLocalGlobalMixin = {
  /**
   * Returns the global position of the container.
   * @param point - The optional point to write the global value to.
   * @param skipUpdate - Should we skip the update transform.
   * @returns - The updated point.
   * @memberof scene.Container#
   */
  getGlobalPosition(point = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(), skipUpdate = false) {
    if (this.parent) {
      this.parent.toGlobal(this._position, point, skipUpdate);
    } else {
      point.x = this._position.x;
      point.y = this._position.y;
    }
    return point;
  },
  /**
   * Calculates the global position of the container.
   * @param position - The world origin to calculate from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform.
   * @returns - A point object representing the position of this object.
   * @memberof scene.Container#
   */
  toGlobal(position, point, skipUpdate = false) {
    const globalMatrix = this.getGlobalTransform(_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.get(), skipUpdate);
    point = globalMatrix.apply(position, point);
    _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.return(globalMatrix);
    return point;
  },
  /**
   * Calculates the local position of the container relative to another point.
   * @param position - The world origin to calculate from.
   * @param from - The Container to calculate the global position from.
   * @param point - A Point object in which to store the value, optional
   *  (otherwise will create a new Point).
   * @param skipUpdate - Should we skip the update transform
   * @returns - A point object representing the position of this object
   * @memberof scene.Container#
   */
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    const globalMatrix = this.getGlobalTransform(_bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.get(), skipUpdate);
    point = globalMatrix.applyInverse(position, point);
    _bounds_utils_matrixAndBoundsPool_mjs__WEBPACK_IMPORTED_MODULE_1__.matrixPool.return(globalMatrix);
    return point;
  }
};


//# sourceMappingURL=toLocalGlobalMixin.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assignWithIgnore: () => (/* binding */ assignWithIgnore)
/* harmony export */ });

function assignWithIgnore(target, options, ignore = {}) {
  for (const key in options) {
    if (!ignore[key] && options[key] !== void 0) {
      target[key] = options[key];
    }
  }
}


//# sourceMappingURL=assignWithIgnore.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkChildrenDidChange: () => (/* binding */ checkChildrenDidChange)
/* harmony export */ });

function checkChildrenDidChange(container, previousData) {
  const children = container.children;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    const uid = child.uid;
    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
    const index = previousData.index;
    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {
      previousData.data[previousData.index] = uid;
      previousData.data[previousData.index + 1] = didChange;
      previousData.didChange = true;
    }
    previousData.index = index + 2;
    if (child.children.length) {
      checkChildrenDidChange(child, previousData);
    }
  }
  return previousData.didChange;
}


//# sourceMappingURL=checkChildrenDidChange.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearList: () => (/* binding */ clearList)
/* harmony export */ });

function clearList(list, index) {
  index || (index = 0);
  for (let j = index; j < list.length; j++) {
    if (list[j]) {
      list[j] = null;
    } else {
      break;
    }
  }
}


//# sourceMappingURL=clearList.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   collectAllRenderables: () => (/* binding */ collectAllRenderables)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");


"use strict";
function collectAllRenderables(container, instructionSet, rendererOrPipes) {
  (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)("8.7.0", "Please use container.collectRenderables instead.");
  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
  return container.collectRenderables(instructionSet, renderer, null);
}


//# sourceMappingURL=collectAllRenderables.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definedProps: () => (/* binding */ definedProps)
/* harmony export */ });

function definedProps(obj) {
  const result = {};
  for (const key in obj) {
    if (obj[key] !== void 0) {
      result[key] = obj[key];
    }
  }
  return result;
}


//# sourceMappingURL=definedProps.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   executeInstructions: () => (/* binding */ executeInstructions)
/* harmony export */ });

function executeInstructions(renderGroup, renderer) {
  const instructionSet = renderGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i = 0; i < instructionSet.instructionSize; i++) {
    const instruction = instructions[i];
    renderer[instruction.renderPipeId].execute(instruction);
  }
}


//# sourceMappingURL=executeInstructions.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mixHexColors: () => (/* binding */ mixHexColors)
/* harmony export */ });

function mixHexColors(color1, color2, ratio) {
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r = r1 + (r2 - r1) * ratio;
  const g = g1 + (g2 - g1) * ratio;
  const b = b1 + (b2 - b1) * ratio;
  return (r << 16) + (g << 8) + b;
}


//# sourceMappingURL=mixHexColors.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   multiplyColors: () => (/* binding */ multiplyColors)
/* harmony export */ });
/* harmony import */ var _multiplyHexColors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./multiplyHexColors.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs");


"use strict";
const WHITE_BGR = 16777215;
function multiplyColors(localBGRColor, parentBGRColor) {
  if (localBGRColor === WHITE_BGR) {
    return parentBGRColor;
  }
  if (parentBGRColor === WHITE_BGR) {
    return localBGRColor;
  }
  return (0,_multiplyHexColors_mjs__WEBPACK_IMPORTED_MODULE_0__.multiplyHexColors)(localBGRColor, parentBGRColor);
}


//# sourceMappingURL=multiplyColors.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   multiplyHexColors: () => (/* binding */ multiplyHexColors)
/* harmony export */ });

function multiplyHexColors(color1, color2) {
  if (color1 === 16777215 || !color2)
    return color2;
  if (color2 === 16777215 || !color1)
    return color1;
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r = r1 * r2 / 255 | 0;
  const g = g1 * g2 / 255 | 0;
  const b = b1 * b2 / 255 | 0;
  return (r << 16) + (g << 8) + b;
}


//# sourceMappingURL=multiplyHexColors.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateLocalTransform: () => (/* binding */ updateLocalTransform)
/* harmony export */ });

function updateLocalTransform(lt, container) {
  const scale = container._scale;
  const pivot = container._pivot;
  const position = container._position;
  const sx = scale._x;
  const sy = scale._y;
  const px = pivot._x;
  const py = pivot._y;
  lt.a = container._cx * sx;
  lt.b = container._sx * sx;
  lt.c = container._cy * sy;
  lt.d = container._sy * sy;
  lt.tx = position._x - (px * lt.a + py * lt.c);
  lt.ty = position._y - (px * lt.b + py * lt.d);
}


//# sourceMappingURL=updateLocalTransform.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateRenderGroupTransform: () => (/* binding */ updateRenderGroupTransform),
/* harmony export */   updateRenderGroupTransforms: () => (/* binding */ updateRenderGroupTransforms),
/* harmony export */   updateTransformAndChildren: () => (/* binding */ updateTransformAndChildren)
/* harmony export */ });
/* harmony import */ var _Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");
/* harmony import */ var _clearList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clearList.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs");
/* harmony import */ var _multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multiplyColors.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs");




"use strict";
const tempContainer = new _Container_mjs__WEBPACK_IMPORTED_MODULE_0__.Container();
const UPDATE_BLEND_COLOR_VISIBLE = _Container_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_VISIBLE | _Container_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_COLOR | _Container_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_BLEND;
function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
  updateRenderGroupTransform(renderGroup);
  const childrenToUpdate = renderGroup.childrenToUpdate;
  const updateTick = renderGroup.updateTick++;
  for (const j in childrenToUpdate) {
    const renderGroupDepth = Number(j);
    const childrenAtDepth = childrenToUpdate[j];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i = 0; i < index; i++) {
      const child = list[i];
      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
        updateTransformAndChildren(child, updateTick, 0);
      }
    }
    (0,_clearList_mjs__WEBPACK_IMPORTED_MODULE_1__.clearList)(list, index);
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {
      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);
    }
  }
}
function updateRenderGroupTransform(renderGroup) {
  const root = renderGroup.root;
  let worldAlpha;
  if (renderGroup.renderGroupParent) {
    const renderGroupParent = renderGroup.renderGroupParent;
    renderGroup.worldTransform.appendFrom(
      root.relativeGroupTransform,
      renderGroupParent.worldTransform
    );
    renderGroup.worldColor = (0,_multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_2__.multiplyColors)(
      root.groupColor,
      renderGroupParent.worldColor
    );
    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
  } else {
    renderGroup.worldTransform.copyFrom(root.localTransform);
    renderGroup.worldColor = root.localColor;
    worldAlpha = root.localAlpha;
  }
  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
  renderGroup.worldAlpha = worldAlpha;
  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  container.updateLocalTransform();
  const parent = container.parent;
  if (parent && !parent.renderGroup) {
    updateFlags |= container._updateFlags;
    container.relativeGroupTransform.appendFrom(
      localTransform,
      parent.relativeGroupTransform
    );
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.relativeGroupTransform.copyFrom(localTransform);
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.renderGroup) {
    const children = container.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      updateTransformAndChildren(children[i], updateTick, updateFlags);
    }
    const renderGroup = container.parentRenderGroup;
    const renderable = container;
    if (renderable.renderPipeId && !renderGroup.structureDidChange) {
      renderGroup.updateRenderable(renderable);
    }
  }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
  if (updateFlags & _Container_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_COLOR) {
    container.groupColor = (0,_multiplyColors_mjs__WEBPACK_IMPORTED_MODULE_2__.multiplyColors)(
      container.localColor,
      parent.groupColor
    );
    let groupAlpha = container.localAlpha * parent.groupAlpha;
    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
    container.groupAlpha = groupAlpha;
    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
  }
  if (updateFlags & _Container_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_BLEND) {
    container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
  }
  if (updateFlags & _Container_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_VISIBLE) {
    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
  }
  container._updateFlags = 0;
}


//# sourceMappingURL=updateRenderGroupTransforms.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateWorldTransform: () => (/* binding */ updateWorldTransform)
/* harmony export */ });

function updateWorldTransform(local, parent, world) {
  const lta = local.a;
  const ltb = local.b;
  const ltc = local.c;
  const ltd = local.d;
  const lttx = local.tx;
  const ltty = local.ty;
  const pta = parent.a;
  const ptb = parent.b;
  const ptc = parent.c;
  const ptd = parent.d;
  world.a = lta * pta + ltb * ptc;
  world.b = lta * ptb + ltb * ptd;
  world.c = ltc * pta + ltd * ptc;
  world.d = ltc * ptb + ltd * ptd;
  world.tx = lttx * pta + ltty * ptc + parent.tx;
  world.ty = lttx * ptb + ltty * ptd + parent.ty;
}


//# sourceMappingURL=updateWorldTransform.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validateRenderables: () => (/* binding */ validateRenderables)
/* harmony export */ });

function validateRenderables(renderGroup, renderPipes) {
  const { list, index } = renderGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i = 0; i < index; i++) {
    const container = list[i];
    const renderable = container;
    const pipe = renderPipes[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  renderGroup.structureDidChange = rebuildRequired;
  return rebuildRequired;
}


//# sourceMappingURL=validateRenderables.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlGraphicsAdaptor: () => (/* binding */ GlGraphicsAdaptor)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/batcher/gl/utils/maxRecommendedTextures.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs");
/* harmony import */ var _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/colorBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");












"use strict";
class GlGraphicsAdaptor {
  init() {
    const uniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.UniformGroup({
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uTransformMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.Matrix(), type: "mat3x3<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    const maxTextures = (0,_rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_2__.getMaxTexturesPerBatch)();
    const glProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_3__.compileHighShaderGlProgram)({
      name: "graphics",
      bits: [
        _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_4__.colorBitGl,
        (0,_rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_5__.generateTextureBatchBitGl)(maxTextures),
        _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_6__.localUniformBitGl,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_7__.roundPixelsBitGl
      ]
    });
    this.shader = new _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_8__.Shader({
      glProgram,
      resources: {
        localUniforms: uniforms,
        batchSamplers: (0,_rendering_renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_9__.getBatchSamplersUniformGroup)(maxTextures)
      }
    });
  }
  execute(graphicsPipe, renderable) {
    const context = renderable.context;
    const shader = context.customShader || this.shader;
    const renderer = graphicsPipe.renderer;
    const contextSystem = renderer.graphicsContext;
    const {
      batcher,
      instructions
    } = contextSystem.getContextRenderData(context);
    shader.groups[0] = renderer.globalUniforms.bindGroup;
    renderer.state.set(graphicsPipe.state);
    renderer.shader.bind(shader);
    renderer.geometry.bind(batcher.geometry, shader.glProgram);
    const batches = instructions.instructions;
    for (let i = 0; i < instructions.instructionSize; i++) {
      const batch = batches[i];
      if (batch.size) {
        for (let j = 0; j < batch.textures.count; j++) {
          renderer.texture.bind(batch.textures.textures[j], j);
        }
        renderer.geometry.draw(batch.topology, batch.size, batch.start);
      }
    }
  }
  destroy() {
    this.shader.destroy(true);
    this.shader = null;
  }
}
/** @ignore */
GlGraphicsAdaptor.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__.ExtensionType.WebGLPipesAdaptor
  ],
  name: "graphics"
};


//# sourceMappingURL=GlGraphicsAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuGraphicsAdaptor: () => (/* binding */ GpuGraphicsAdaptor)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/batcher/gl/utils/maxRecommendedTextures.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs");
/* harmony import */ var _rendering_batcher_gpu_getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs");
/* harmony import */ var _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/colorBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");












"use strict";
class GpuGraphicsAdaptor {
  init() {
    const localUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.UniformGroup({
      uTransformMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.Matrix(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    const gpuProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.compileHighShaderGpuProgram)({
      name: "graphics",
      bits: [
        _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_3__.colorBit,
        (0,_rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_4__.generateTextureBatchBit)((0,_rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_5__.getMaxTexturesPerBatch)()),
        _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_6__.localUniformBitGroup2,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_7__.roundPixelsBit
      ]
    });
    this.shader = new _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_8__.Shader({
      gpuProgram,
      resources: {
        // added on the fly!
        localUniforms
      }
    });
  }
  execute(graphicsPipe, renderable) {
    const context = renderable.context;
    const shader = context.customShader || this.shader;
    const renderer = graphicsPipe.renderer;
    const contextSystem = renderer.graphicsContext;
    const {
      batcher,
      instructions
    } = contextSystem.getContextRenderData(context);
    const encoder = renderer.encoder;
    encoder.setGeometry(batcher.geometry, shader.gpuProgram);
    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
    const batches = instructions.instructions;
    let topology = null;
    for (let i = 0; i < instructions.instructionSize; i++) {
      const batch = batches[i];
      if (batch.topology !== topology) {
        topology = batch.topology;
        encoder.setPipelineFromGeometryProgramAndState(
          batcher.geometry,
          shader.gpuProgram,
          graphicsPipe.state,
          batch.topology
        );
      }
      shader.groups[1] = batch.bindGroup;
      if (!batch.gpuBindGroup) {
        const textureBatch = batch.textures;
        batch.bindGroup = (0,_rendering_batcher_gpu_getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_9__.getTextureBatchBindGroup)(textureBatch.textures, textureBatch.count);
        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
          batch.bindGroup,
          shader.gpuProgram,
          1
        );
      }
      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
    }
  }
  destroy() {
    this.shader.destroy(true);
    this.shader = null;
  }
}
/** @ignore */
GpuGraphicsAdaptor.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__.ExtensionType.WebGPUPipesAdaptor
  ],
  name: "graphics"
};


//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   color32BitToUniform: () => (/* binding */ color32BitToUniform),
/* harmony export */   colorToUniform: () => (/* binding */ colorToUniform)
/* harmony export */ });

function colorToUniform(rgb, alpha, out, offset) {
  out[offset++] = (rgb >> 16 & 255) / 255;
  out[offset++] = (rgb >> 8 & 255) / 255;
  out[offset++] = (rgb & 255) / 255;
  out[offset++] = alpha;
}
function color32BitToUniform(abgr, out, offset) {
  const alpha = (abgr >> 24 & 255) / 255;
  out[offset++] = (abgr & 255) / 255 * alpha;
  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;
  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;
  out[offset++] = alpha;
}


//# sourceMappingURL=colorToUniform.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BatchableGraphics: () => (/* binding */ BatchableGraphics)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _container_utils_multiplyHexColors_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../container/utils/multiplyHexColors.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs");



"use strict";
const identityMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
class BatchableGraphics {
  constructor() {
    this.packAsQuad = false;
    this.batcherName = "default";
    this.topology = "triangle-list";
    this.applyTransform = true;
    this.roundPixels = 0;
    this._batcher = null;
    this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    if (this.applyTransform) {
      return this.renderable.groupBlendMode;
    }
    return "normal";
  }
  get color() {
    const rgb = this.baseColor;
    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
    const renderable = this.renderable;
    if (renderable) {
      return (0,_container_utils_multiplyHexColors_mjs__WEBPACK_IMPORTED_MODULE_1__.multiplyHexColors)(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
    }
    return bgr + (this.alpha * 255 << 24);
  }
  get transform() {
    return this.renderable?.groupTransform || identityMatrix;
  }
  copyTo(gpuBuffer) {
    gpuBuffer.indexOffset = this.indexOffset;
    gpuBuffer.indexSize = this.indexSize;
    gpuBuffer.attributeOffset = this.attributeOffset;
    gpuBuffer.attributeSize = this.attributeSize;
    gpuBuffer.baseColor = this.baseColor;
    gpuBuffer.alpha = this.alpha;
    gpuBuffer.texture = this.texture;
    gpuBuffer.geometryData = this.geometryData;
    gpuBuffer.topology = this.topology;
  }
  reset() {
    this.applyTransform = true;
    this.renderable = null;
    this.topology = "triangle-list";
  }
}


//# sourceMappingURL=BatchableGraphics.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graphics: () => (/* binding */ Graphics)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");
/* harmony import */ var _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphicsContext.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs");




"use strict";
class Graphics extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  /**
   * @param options - Options for the Graphics.
   */
  constructor(options) {
    if (options instanceof _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext) {
      options = { context: options };
    }
    const { context, roundPixels, ...rest } = options || {};
    super({
      label: "Graphics",
      ...rest
    });
    this.renderPipeId = "graphics";
    if (!context) {
      this._context = this._ownedContext = new _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext();
    } else {
      this._context = context;
    }
    this._context.on("update", this.onViewUpdate, this);
    this.allowChildren = false;
    this.roundPixels = roundPixels ?? false;
  }
  set context(context) {
    if (context === this._context)
      return;
    this._context.off("update", this.onViewUpdate, this);
    this._context = context;
    this._context.on("update", this.onViewUpdate, this);
    this.onViewUpdate();
  }
  get context() {
    return this._context;
  }
  /**
   * The local bounds of the graphic.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._context.bounds;
  }
  /**
   * Graphics objects do not need to update their bounds as the context handles this.
   * @private
   */
  updateBounds() {
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(point) {
    return this._context.containsPoint(point);
  }
  /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
   * @param {boolean} [options.context=false] - Should destroy the context
   */
  destroy(options) {
    if (this._ownedContext && !options) {
      this._ownedContext.destroy(options);
    } else if (options === true || options?.context === true) {
      this._context.destroy(options);
    }
    this._ownedContext = null;
    this._context = null;
    super.destroy(options);
  }
  _callContextMethod(method, args) {
    this.context[method](...args);
    return this;
  }
  // --------------------------------------- GraphicsContext methods ---------------------------------------
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
   * pattern object, or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(...args) {
    return this._callContextMethod("setFillStyle", args);
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   * or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(...args) {
    return this._callContextMethod("setStrokeStyle", args);
  }
  fill(...args) {
    return this._callContextMethod("fill", args);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
   * complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(...args) {
    return this._callContextMethod("stroke", args);
  }
  texture(...args) {
    return this._callContextMethod("texture", args);
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._callContextMethod("beginPath", []);
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   */
  cut() {
    return this._callContextMethod("cut", []);
  }
  arc(...args) {
    return this._callContextMethod("arc", args);
  }
  arcTo(...args) {
    return this._callContextMethod("arcTo", args);
  }
  arcToSvg(...args) {
    return this._callContextMethod("arcToSvg", args);
  }
  bezierCurveTo(...args) {
    return this._callContextMethod("bezierCurveTo", args);
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this._callContextMethod("closePath", []);
  }
  ellipse(...args) {
    return this._callContextMethod("ellipse", args);
  }
  circle(...args) {
    return this._callContextMethod("circle", args);
  }
  path(...args) {
    return this._callContextMethod("path", args);
  }
  lineTo(...args) {
    return this._callContextMethod("lineTo", args);
  }
  moveTo(...args) {
    return this._callContextMethod("moveTo", args);
  }
  quadraticCurveTo(...args) {
    return this._callContextMethod("quadraticCurveTo", args);
  }
  rect(...args) {
    return this._callContextMethod("rect", args);
  }
  roundRect(...args) {
    return this._callContextMethod("roundRect", args);
  }
  poly(...args) {
    return this._callContextMethod("poly", args);
  }
  regularPoly(...args) {
    return this._callContextMethod("regularPoly", args);
  }
  roundPoly(...args) {
    return this._callContextMethod("roundPoly", args);
  }
  roundShape(...args) {
    return this._callContextMethod("roundShape", args);
  }
  filletRect(...args) {
    return this._callContextMethod("filletRect", args);
  }
  chamferRect(...args) {
    return this._callContextMethod("chamferRect", args);
  }
  star(...args) {
    return this._callContextMethod("star", args);
  }
  svg(...args) {
    return this._callContextMethod("svg", args);
  }
  restore(...args) {
    return this._callContextMethod("restore", args);
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._callContextMethod("save", []);
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this.context.getTransform();
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._callContextMethod("resetTransform", []);
  }
  rotateTransform(...args) {
    return this._callContextMethod("rotate", args);
  }
  scaleTransform(...args) {
    return this._callContextMethod("scale", args);
  }
  setTransform(...args) {
    return this._callContextMethod("setTransform", args);
  }
  transform(...args) {
    return this._callContextMethod("transform", args);
  }
  translateTransform(...args) {
    return this._callContextMethod("translate", args);
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._callContextMethod("clear", []);
  }
  /**
   * The fill style to use.
   * @type {ConvertedFillStyle}
   */
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(value) {
    this._context.fillStyle = value;
  }
  /**
   * The stroke style to use.
   * @type {ConvertedStrokeStyle}
   */
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(value) {
    this._context.strokeStyle = value;
  }
  /**
   * Creates a new Graphics object.
   * Note that only the context of the object is cloned, not its transform (position,scale,etc)
   * @param deep - Whether to create a deep clone of the graphics object. If false, the context
   * will be shared between the two objects (default false). If true, the context will be
   * cloned (recommended if you need to modify the context in any way).
   * @returns - A clone of the graphics object
   */
  clone(deep = false) {
    if (deep) {
      return new Graphics(this._context.clone());
    }
    this._ownedContext = null;
    const clone = new Graphics(this._context);
    return clone;
  }
  // -------- v7 deprecations ---------
  /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */
  lineStyle(width, color, alpha) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
    const strokeStyle = {};
    width && (strokeStyle.width = width);
    color && (strokeStyle.color = color);
    alpha && (strokeStyle.alpha = alpha);
    this.context.strokeStyle = strokeStyle;
    return this;
  }
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  beginFill(color, alpha) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    const fillStyle = {};
    if (color !== void 0)
      fillStyle.color = color;
    if (alpha !== void 0)
      fillStyle.alpha = alpha;
    this.context.fillStyle = fillStyle;
    return this;
  }
  /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  endFill() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    this.context.fill();
    const strokeStyle = this.context.strokeStyle;
    if (strokeStyle.width !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== _GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultStrokeStyle.alpha) {
      this.context.stroke();
    }
    return this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */
  drawCircle(...args) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
    return this._callContextMethod("circle", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */
  drawEllipse(...args) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
    return this._callContextMethod("ellipse", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */
  drawPolygon(...args) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
    return this._callContextMethod("poly", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */
  drawRect(...args) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
    return this._callContextMethod("rect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */
  drawRoundedRect(...args) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
    return this._callContextMethod("roundRect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */
  drawStar(...args) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
    return this._callContextMethod("star", args);
  }
}


//# sourceMappingURL=Graphics.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphicsContext: () => (/* binding */ GraphicsContext)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path/GraphicsPath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs");
/* harmony import */ var _svg_SVGParser_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./svg/SVGParser.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs");
/* harmony import */ var _utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/convertFillInputToFillStyle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs");












"use strict";
const tmpPoint = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
const tempMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix();
const _GraphicsContext = class _GraphicsContext extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super(...arguments);
    /** unique id for this graphics context */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_3__.uid)("graphicsContext");
    this.dirty = true;
    this.batchMode = "auto";
    this.instructions = [];
    this._activePath = new _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_4__.GraphicsPath();
    this._transform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix();
    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };
    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };
    this._stateStack = [];
    this._tick = 0;
    this._bounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_5__.Bounds();
    this._boundsDirty = true;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const clone = new _GraphicsContext();
    clone.batchMode = this.batchMode;
    clone.instructions = this.instructions.slice();
    clone._activePath = this._activePath.clone();
    clone._transform = this._transform.clone();
    clone._fillStyle = { ...this._fillStyle };
    clone._strokeStyle = { ...this._strokeStyle };
    clone._stateStack = this._stateStack.slice();
    clone._bounds = this._bounds.clone();
    clone._boundsDirty = true;
    return clone;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(value) {
    this._fillStyle = (0,_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_6__.toFillStyle)(value, _GraphicsContext.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(value) {
    this._strokeStyle = (0,_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_6__.toStrokeStyle)(value, _GraphicsContext.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(style) {
    this._fillStyle = (0,_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_6__.toFillStyle)(style, _GraphicsContext.defaultFillStyle);
    return this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(style) {
    this._strokeStyle = (0,_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_6__.toFillStyle)(style, _GraphicsContext.defaultStrokeStyle);
    return this;
  }
  texture(texture, tint, dx, dy, dw, dh) {
    this.instructions.push({
      action: "texture",
      data: {
        image: texture,
        dx: dx || 0,
        dy: dy || 0,
        dw: dw || texture.frame.width,
        dh: dh || texture.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: tint ? _color_Color_mjs__WEBPACK_IMPORTED_MODULE_7__.Color.shared.setValue(tint).toNumber() : 16777215
      }
    });
    this.onUpdate();
    return this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    this._activePath = new _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_4__.GraphicsPath();
    return this;
  }
  fill(style, alpha) {
    let path;
    const lastInstruction = this.instructions[this.instructions.length - 1];
    if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
      path = lastInstruction.data.path;
    } else {
      path = this._activePath.clone();
    }
    if (!path)
      return this;
    if (style != null) {
      if (alpha !== void 0 && typeof style === "number") {
        (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_8__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_8__.v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
        style = { color: style, alpha };
      }
      this._fillStyle = (0,_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_6__.toFillStyle)(style, _GraphicsContext.defaultFillStyle);
    }
    this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path }
    });
    this.onUpdate();
    this._initNextPathLocation();
    this._tick = 0;
    return this;
  }
  _initNextPathLocation() {
    const { x, y } = this._activePath.getLastPoint(_maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point.shared);
    this._activePath.clear();
    this._activePath.moveTo(x, y);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(style) {
    let path;
    const lastInstruction = this.instructions[this.instructions.length - 1];
    if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
      path = lastInstruction.data.path;
    } else {
      path = this._activePath.clone();
    }
    if (!path)
      return this;
    if (style != null) {
      this._strokeStyle = (0,_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_6__.toStrokeStyle)(style, _GraphicsContext.defaultStrokeStyle);
    }
    this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path }
    });
    this.onUpdate();
    this._initNextPathLocation();
    this._tick = 0;
    return this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let i = 0; i < 2; i++) {
      const lastInstruction = this.instructions[this.instructions.length - 1 - i];
      const holePath = this._activePath.clone();
      if (lastInstruction) {
        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
          if (lastInstruction.data.hole) {
            lastInstruction.data.hole.addPath(holePath);
          } else {
            lastInstruction.data.hole = holePath;
            break;
          }
        }
      }
    }
    this._initNextPathLocation();
    return this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    this._tick++;
    const t = this._transform;
    this._activePath.arc(
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty,
      radius,
      startAngle,
      endAngle,
      counterclockwise
    );
    return this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._tick++;
    const t = this._transform;
    this._activePath.arcTo(
      t.a * x1 + t.c * y1 + t.tx,
      t.b * x1 + t.d * y1 + t.ty,
      t.a * x2 + t.c * y2 + t.tx,
      t.b * x2 + t.d * y2 + t.ty,
      radius
    );
    return this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
    this._tick++;
    const t = this._transform;
    this._activePath.arcToSvg(
      rx,
      ry,
      xAxisRotation,
      // should we rotate this with transform??
      largeArcFlag,
      sweepFlag,
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty
    );
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
    this._tick++;
    const t = this._transform;
    this._activePath.bezierCurveTo(
      t.a * cp1x + t.c * cp1y + t.tx,
      t.b * cp1x + t.d * cp1y + t.ty,
      t.a * cp2x + t.c * cp2y + t.tx,
      t.b * cp2x + t.d * cp2y + t.ty,
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty,
      smoothness
    );
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this._tick++;
    this._activePath?.closePath();
    return this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(x, y, radiusX, radiusY) {
    this._tick++;
    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x, y, radius) {
    this._tick++;
    this._activePath.circle(x, y, radius, this._transform.clone());
    return this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(path) {
    this._tick++;
    this._activePath.addPath(path, this._transform.clone());
    return this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(x, y) {
    this._tick++;
    const t = this._transform;
    this._activePath.lineTo(
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty
    );
    return this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(x, y) {
    this._tick++;
    const t = this._transform;
    const instructions = this._activePath.instructions;
    const transformedX = t.a * x + t.c * y + t.tx;
    const transformedY = t.b * x + t.d * y + t.ty;
    if (instructions.length === 1 && instructions[0].action === "moveTo") {
      instructions[0].data[0] = transformedX;
      instructions[0].data[1] = transformedY;
      return this;
    }
    this._activePath.moveTo(
      transformedX,
      transformedY
    );
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(cpx, cpy, x, y, smoothness) {
    this._tick++;
    const t = this._transform;
    this._activePath.quadraticCurveTo(
      t.a * cpx + t.c * cpy + t.tx,
      t.b * cpx + t.d * cpy + t.ty,
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty,
      smoothness
    );
    return this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x, y, w, h) {
    this._tick++;
    this._activePath.rect(x, y, w, h, this._transform.clone());
    return this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(x, y, w, h, radius) {
    this._tick++;
    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());
    return this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(points, close) {
    this._tick++;
    this._activePath.poly(points, close, this._transform.clone());
    return this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(x, y, radius, sides, rotation = 0, transform) {
    this._tick++;
    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);
    return this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(x, y, radius, sides, corner, rotation) {
    this._tick++;
    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);
    return this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(points, radius, useQuadratic, smoothness) {
    this._tick++;
    this._activePath.roundShape(points, radius, useQuadratic, smoothness);
    return this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(x, y, width, height, fillet) {
    this._tick++;
    this._activePath.filletRect(x, y, width, height, fillet);
    return this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(x, y, width, height, chamfer, transform) {
    this._tick++;
    this._activePath.chamferRect(x, y, width, height, chamfer, transform);
    return this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(x, y, points, radius, innerRadius = 0, rotation = 0) {
    this._tick++;
    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());
    return this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(svg) {
    this._tick++;
    (0,_svg_SVGParser_mjs__WEBPACK_IMPORTED_MODULE_9__.SVGParser)(svg, this);
    return this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const state = this._stateStack.pop();
    if (state) {
      this._transform = state.transform;
      this._fillStyle = state.fillStyle;
      this._strokeStyle = state.strokeStyle;
    }
    return this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    });
    return this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    this._transform.identity();
    return this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(angle) {
    this._transform.rotate(angle);
    return this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(x, y = x) {
    this._transform.scale(x, y);
    return this;
  }
  setTransform(a, b, c, d, dx, dy) {
    if (a instanceof _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix) {
      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);
      return this;
    }
    this._transform.set(a, b, c, d, dx, dy);
    return this;
  }
  transform(a, b, c, d, dx, dy) {
    if (a instanceof _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix) {
      this._transform.append(a);
      return this;
    }
    tempMatrix.set(a, b, c, d, dx, dy);
    this._transform.append(tempMatrix);
    return this;
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(x, y = x) {
    this._transform.translate(x, y);
    return this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    this._activePath.clear();
    this.instructions.length = 0;
    this.resetTransform();
    this.onUpdate();
    return this;
  }
  onUpdate() {
    if (this.dirty)
      return;
    this.emit("update", this, 16);
    this.dirty = true;
    this._boundsDirty = true;
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    const bounds = this._bounds;
    bounds.clear();
    for (let i = 0; i < this.instructions.length; i++) {
      const instruction = this.instructions[i];
      const action = instruction.action;
      if (action === "fill") {
        const data = instruction.data;
        bounds.addBounds(data.path.bounds);
      } else if (action === "texture") {
        const data = instruction.data;
        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
      }
      if (action === "stroke") {
        const data = instruction.data;
        const alignment = data.style.alignment;
        const outerPadding = data.style.width * (1 - alignment);
        const _bounds = data.path.bounds;
        bounds.addFrame(
          _bounds.minX - outerPadding,
          _bounds.minY - outerPadding,
          _bounds.maxX + outerPadding,
          _bounds.maxY + outerPadding
        );
      }
    }
    return bounds;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(point) {
    if (!this.bounds.containsPoint(point.x, point.y))
      return false;
    const instructions = this.instructions;
    let hasHit = false;
    for (let k = 0; k < instructions.length; k++) {
      const instruction = instructions[k];
      const data = instruction.data;
      const path = data.path;
      if (!instruction.action || !path)
        continue;
      const style = data.style;
      const shapes = path.shapePath.shapePrimitives;
      for (let i = 0; i < shapes.length; i++) {
        const shape = shapes[i].shape;
        if (!style || !shape)
          continue;
        const transform = shapes[i].transform;
        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
        if (instruction.action === "fill") {
          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
        } else {
          const strokeStyle = style;
          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
        }
        const holes = data.hole;
        if (holes) {
          const holeShapes = holes.shapePath?.shapePrimitives;
          if (holeShapes) {
            for (let j = 0; j < holeShapes.length; j++) {
              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {
                hasHit = false;
              }
            }
          }
        }
        if (hasHit) {
          return true;
        }
      }
    }
    return hasHit;
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
   */
  destroy(options = false) {
    this._stateStack.length = 0;
    this._transform = null;
    this.emit("destroy", this);
    this.removeAllListeners();
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      if (this._fillStyle.texture) {
        this._fillStyle.texture.destroy(destroyTextureSource);
      }
      if (this._strokeStyle.texture) {
        this._strokeStyle.texture.destroy(destroyTextureSource);
      }
    }
    this._fillStyle = null;
    this._strokeStyle = null;
    this.instructions = null;
    this._activePath = null;
    this._bounds = null;
    this._stateStack = null;
    this.customShader = null;
    this._transform = null;
  }
};
/** The default fill style to use when none is provided. */
_GraphicsContext.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_10__.Texture.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local"
};
/** The default stroke style to use when none is provided. */
_GraphicsContext.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_10__.Texture.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local",
  /** If the stroke is a pixel line. */
  pixelLine: false
};
let GraphicsContext = _GraphicsContext;


//# sourceMappingURL=GraphicsContext.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuGraphicsContext: () => (/* binding */ GpuGraphicsContext),
/* harmony export */   GraphicsContextRenderData: () => (/* binding */ GraphicsContextRenderData),
/* harmony export */   GraphicsContextSystem: () => (/* binding */ GraphicsContextSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_batcher_gpu_getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs");
/* harmony import */ var _rendering_batcher_shared_DefaultBatcher_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/batcher/shared/DefaultBatcher.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs");
/* harmony import */ var _rendering_renderers_shared_instructions_InstructionSet_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/shared/instructions/InstructionSet.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _utils_buildContextBatches_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/buildContextBatches.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs");








"use strict";
class GpuGraphicsContext {
  constructor() {
    this.batches = [];
    this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}
class GraphicsContextRenderData {
  constructor() {
    this.batcher = new _rendering_batcher_shared_DefaultBatcher_mjs__WEBPACK_IMPORTED_MODULE_0__.DefaultBatcher();
    this.instructions = new _rendering_renderers_shared_instructions_InstructionSet_mjs__WEBPACK_IMPORTED_MODULE_1__.InstructionSet();
  }
  init() {
    this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
    return this.batcher.geometry;
  }
}
const _GraphicsContextSystem = class _GraphicsContextSystem {
  constructor(renderer) {
    // the root context batches, used to either make a batch or geometry
    // all graphics use this as a base
    this._gpuContextHash = {};
    // used for non-batchable graphics
    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
    renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
    renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(options) {
    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;
  }
  getContextRenderData(context) {
    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);
  }
  // Context management functions
  updateGpuContext(context) {
    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);
    if (context.dirty) {
      if (gpuContext) {
        this._cleanGraphicsContextData(context);
      } else {
        gpuContext = this._initContext(context);
      }
      (0,_utils_buildContextBatches_mjs__WEBPACK_IMPORTED_MODULE_3__.buildContextBatches)(context, gpuContext);
      const batchMode = context.batchMode;
      if (context.customShader || batchMode === "no-batch") {
        gpuContext.isBatchable = false;
      } else if (batchMode === "auto") {
        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
      }
      context.dirty = false;
    }
    return gpuContext;
  }
  getGpuContext(context) {
    return this._gpuContextHash[context.uid] || this._initContext(context);
  }
  _initContextRenderData(context) {
    const graphicsData = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_4__.BigPool.get(GraphicsContextRenderData);
    const { batches, geometryData } = this._gpuContextHash[context.uid];
    const vertexSize = geometryData.vertices.length;
    const indexSize = geometryData.indices.length;
    for (let i = 0; i < batches.length; i++) {
      batches[i].applyTransform = false;
    }
    const batcher = graphicsData.batcher;
    batcher.ensureAttributeBuffer(vertexSize);
    batcher.ensureIndexBuffer(indexSize);
    batcher.begin();
    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      batcher.add(batch);
    }
    batcher.finish(graphicsData.instructions);
    const geometry = batcher.geometry;
    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
    const drawBatches = batcher.batches;
    for (let i = 0; i < drawBatches.length; i++) {
      const batch = drawBatches[i];
      batch.bindGroup = (0,_rendering_batcher_gpu_getTextureBatchBindGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.getTextureBatchBindGroup)(batch.textures.textures, batch.textures.count);
    }
    this._graphicsDataContextHash[context.uid] = graphicsData;
    return graphicsData;
  }
  _initContext(context) {
    const gpuContext = new GpuGraphicsContext();
    gpuContext.context = context;
    this._gpuContextHash[context.uid] = gpuContext;
    context.on("destroy", this.onGraphicsContextDestroy, this);
    return this._gpuContextHash[context.uid];
  }
  onGraphicsContextDestroy(context) {
    this._cleanGraphicsContextData(context);
    context.off("destroy", this.onGraphicsContextDestroy, this);
    this._gpuContextHash[context.uid] = null;
  }
  _cleanGraphicsContextData(context) {
    const gpuContext = this._gpuContextHash[context.uid];
    if (!gpuContext.isBatchable) {
      if (this._graphicsDataContextHash[context.uid]) {
        _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_4__.BigPool.return(this.getContextRenderData(context));
        this._graphicsDataContextHash[context.uid] = null;
      }
    }
    if (gpuContext.batches) {
      gpuContext.batches.forEach((batch) => {
        _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_4__.BigPool.return(batch);
      });
    }
  }
  destroy() {
    for (const i in this._gpuContextHash) {
      if (this._gpuContextHash[i]) {
        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);
      }
    }
  }
};
/** @ignore */
_GraphicsContextSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.CanvasSystem
  ],
  name: "graphicsContext"
};
/** The default options for the GraphicsContextSystem. */
_GraphicsContextSystem.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let GraphicsContextSystem = _GraphicsContextSystem;


//# sourceMappingURL=GraphicsContextSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphicsPipe: () => (/* binding */ GraphicsPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gpu/colorToUniform.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs");
/* harmony import */ var _BatchableGraphics_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BatchableGraphics.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs");






"use strict";
class GraphicsPipe {
  constructor(renderer, adaptor) {
    this.state = _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
    // batchable graphics list, used to render batches
    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this.renderer = renderer;
    this._adaptor = adaptor;
    this._adaptor.init();
    this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash");
  }
  validateRenderable(graphics) {
    const context = graphics.context;
    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);
    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
      return true;
    }
    return false;
  }
  addRenderable(graphics, instructionSet) {
    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
    if (graphics.didViewUpdate) {
      this._rebuild(graphics);
    }
    if (gpuContext.isBatchable) {
      this._addToBatcher(graphics, instructionSet);
    } else {
      this.renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(graphics);
    }
  }
  updateRenderable(graphics) {
    const batches = this._graphicsBatchesHash[graphics.uid];
    if (batches) {
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        batch._batcher.updateElement(batch);
      }
    }
  }
  destroyRenderable(graphics) {
    if (this._graphicsBatchesHash[graphics.uid]) {
      this._removeBatchForRenderable(graphics.uid);
    }
    graphics.off("destroyed", this._destroyRenderableBound);
  }
  execute(graphics) {
    if (!graphics.isRenderable)
      return;
    const renderer = this.renderer;
    const context = graphics.context;
    const contextSystem = renderer.graphicsContext;
    if (!contextSystem.getGpuContext(context).batches.length) {
      return;
    }
    const shader = context.customShader || this._adaptor.shader;
    this.state.blendMode = graphics.groupBlendMode;
    const localUniforms = shader.resources.localUniforms.uniforms;
    localUniforms.uTransformMatrix = graphics.groupTransform;
    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
    (0,_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_1__.color32BitToUniform)(
      graphics.groupColorAlpha,
      localUniforms.uColor,
      0
    );
    this._adaptor.execute(this, graphics);
  }
  _rebuild(graphics) {
    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
    if (wasBatched) {
      this._removeBatchForRenderable(graphics.uid);
    }
    if (gpuContext.isBatchable) {
      this._initBatchesForRenderable(graphics);
    }
    graphics.batched = gpuContext.isBatchable;
  }
  _addToBatcher(graphics, instructionSet) {
    const batchPipe = this.renderer.renderPipes.batch;
    const batches = this._getBatchesForRenderable(graphics);
    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      batchPipe.addToBatch(batch, instructionSet);
    }
  }
  _getBatchesForRenderable(graphics) {
    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
  }
  _initBatchesForRenderable(graphics) {
    const context = graphics.context;
    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);
    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
    const batches = gpuContext.batches.map((batch) => {
      const batchClone = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.BigPool.get(_BatchableGraphics_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchableGraphics);
      batch.copyTo(batchClone);
      batchClone.renderable = graphics;
      batchClone.roundPixels = roundPixels;
      return batchClone;
    });
    if (this._graphicsBatchesHash[graphics.uid] === void 0) {
      graphics.on("destroyed", this._destroyRenderableBound);
    }
    this._graphicsBatchesHash[graphics.uid] = batches;
    return batches;
  }
  _removeBatchForRenderable(graphicsUid) {
    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {
      _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.BigPool.return(batch);
    });
    this._graphicsBatchesHash[graphicsUid] = null;
  }
  destroy() {
    this.renderer = null;
    this._adaptor.destroy();
    this._adaptor = null;
    this.state = null;
    for (const i in this._graphicsBatchesHash) {
      this._removeBatchForRenderable(i);
    }
    this._graphicsBatchesHash = null;
  }
}
/** @ignore */
GraphicsPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.CanvasPipes
  ],
  name: "graphics"
};


//# sourceMappingURL=GraphicsPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildAdaptiveBezier: () => (/* binding */ buildAdaptiveBezier)
/* harmony export */ });
/* harmony import */ var _GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GraphicsContextSystem.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs");


"use strict";
const RECURSION_LIMIT = 8;
const FLT_EPSILON = 11920929e-14;
const PATH_DISTANCE_EPSILON = 1;
const curveAngleToleranceEpsilon = 0.01;
const mAngleTolerance = 0;
const mCuspLimit = 0;
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? _GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x2);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d2 > FLT_EPSILON) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}


//# sourceMappingURL=buildAdaptiveBezier.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildAdaptiveQuadratic: () => (/* binding */ buildAdaptiveQuadratic)
/* harmony export */ });
/* harmony import */ var _GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GraphicsContextSystem.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs");


"use strict";
const RECURSION_LIMIT = 8;
const FLT_EPSILON = 11920929e-14;
const PATH_DISTANCE_EPSILON = 1;
const curveAngleToleranceEpsilon = 0.01;
const mAngleTolerance = 0;
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? _GraphicsContextSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
  if (d > FLT_EPSILON) {
    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance < curveAngleToleranceEpsilon) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}


//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildArc: () => (/* binding */ buildArc)
/* harmony export */ });

function buildArc(points, x, y, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
  steps = Math.max(steps, 3);
  let f = dist / steps;
  let t = start;
  f *= clockwise ? -1 : 1;
  for (let i = 0; i < steps + 1; i++) {
    const cs = Math.cos(t);
    const sn = Math.sin(t);
    const nx = x + cs * radius;
    const ny = y + sn * radius;
    points.push(nx, ny);
    t += f;
  }
}


//# sourceMappingURL=buildArc.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildArcTo: () => (/* binding */ buildArcTo)
/* harmony export */ });
/* harmony import */ var _buildArc_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buildArc.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs");


"use strict";
function buildArcTo(points, x1, y1, x2, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x2 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k2 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j2 = k2 * tt / cc;
  const cx = k1 * b2 + k2 * b1;
  const cy = k1 * a2 + k2 * a1;
  const px = b1 * (k2 + j1);
  const py = a1 * (k2 + j1);
  const qx = b2 * (k1 + j2);
  const qy = a2 * (k1 + j2);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  (0,_buildArc_mjs__WEBPACK_IMPORTED_MODULE_0__.buildArc)(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}


//# sourceMappingURL=buildArcTo.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildArcToSvg: () => (/* binding */ buildArcToSvg)
/* harmony export */ });
/* harmony import */ var _buildAdaptiveBezier_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buildAdaptiveBezier.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs");


"use strict";
const TAU = Math.PI * 2;
const out = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
};
const mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
  x *= rx;
  y *= ry;
  const xp = cosPhi * x - sinPhi * y;
  const yp = sinPhi * x + cosPhi * y;
  out2.x = xp + centerX;
  out2.y = yp + centerY;
  return out2;
};
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x2 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a,
      y: y1 + x1 * a
    },
    {
      x: x2 + y2 * a,
      y: y2 - x2 * a
    },
    {
      x: x2,
      y: y2
    }
  ];
}
const vectorAngle = (ux, uy, vx, vy) => {
  const sign = ux * vy - uy * vx < 0 ? -1 : 1;
  let dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
const getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
  const rxSq = Math.pow(rx, 2);
  const rySq = Math.pow(ry, 2);
  const pxpSq = Math.pow(pxp, 2);
  const pypSq = Math.pow(pyp, 2);
  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxSq * pypSq + rySq * pxpSq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  const centerXp = radicant * rx / ry * pyp;
  const centerYp = radicant * -ry / rx * pxp;
  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
  const vx1 = (pxp - centerXp) / rx;
  const vy1 = (pyp - centerYp) / ry;
  const vx2 = (-pxp - centerXp) / rx;
  const vy2 = (-pyp - centerYp) / ry;
  const ang1 = vectorAngle(1, 0, vx1, vy1);
  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  out2.centerX = centerX;
  out2.centerY = centerY;
  out2.ang1 = ang1;
  out2.ang2 = ang2;
};
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i = 0; i < segments; i++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    (0,_buildAdaptiveBezier_mjs__WEBPACK_IMPORTED_MODULE_0__.buildAdaptiveBezier)(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x2,
      y2,
      x,
      y
    );
    lastX = x;
    lastY = y;
    ang1 += ang2;
  }
}


//# sourceMappingURL=buildArcToSvg.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildCircle: () => (/* binding */ buildCircle),
/* harmony export */   buildEllipse: () => (/* binding */ buildEllipse),
/* harmony export */   buildRoundedRectangle: () => (/* binding */ buildRoundedRectangle)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const buildCircle = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ShapeBuilder,
    name: "circle"
  },
  build(shape, points) {
    let x;
    let y;
    let dx;
    let dy;
    let rx;
    let ry;
    if (shape.type === "circle") {
      const circle = shape;
      x = circle.x;
      y = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (shape.type === "ellipse") {
      const ellipse = shape;
      x = ellipse.x;
      y = ellipse.y;
      rx = ellipse.halfWidth;
      ry = ellipse.halfHeight;
      dx = dy = 0;
    } else {
      const roundedRect = shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      return points;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    if (m === 0) {
      return points;
    }
    if (n === 0) {
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y - dy;
      return points;
    }
    let j1 = 0;
    let j2 = n * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m;
    let x0 = dx + rx;
    let y0 = dy;
    let x1 = x + x0;
    let x2 = x - x0;
    let y1 = y + y0;
    points[j1++] = x1;
    points[j1++] = y1;
    points[--j2] = y1;
    points[--j2] = x2;
    if (dy) {
      const y22 = y - y0;
      points[j3++] = x2;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x1;
    }
    for (let i = 1; i < n; i++) {
      const a = Math.PI / 2 * (i / n);
      const x02 = dx + Math.cos(a) * rx;
      const y02 = dy + Math.sin(a) * ry;
      const x12 = x + x02;
      const x22 = x - x02;
      const y12 = y + y02;
      const y22 = y - y02;
      points[j1++] = x12;
      points[j1++] = y12;
      points[--j2] = y12;
      points[--j2] = x22;
      points[j3++] = x22;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x12;
    }
    x0 = dx;
    y0 = dy + ry;
    x1 = x + x0;
    x2 = x - x0;
    y1 = y + y0;
    const y2 = y - y0;
    points[j1++] = x1;
    points[j1++] = y1;
    points[--j4] = y2;
    points[--j4] = x1;
    if (dx) {
      points[j1++] = x2;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x2;
    }
    return points;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    if (points.length === 0) {
      return;
    }
    let centerX = 0;
    let centerY = 0;
    for (let i = 0; i < points.length; i += 2) {
      centerX += points[i];
      centerY += points[i + 1];
    }
    centerX /= points.length / 2;
    centerY /= points.length / 2;
    let count = verticesOffset;
    vertices[count * verticesStride] = centerX;
    vertices[count * verticesStride + 1] = centerY;
    const centerIndex = count++;
    for (let i = 0; i < points.length; i += 2) {
      vertices[count * verticesStride] = points[i];
      vertices[count * verticesStride + 1] = points[i + 1];
      if (i > 0) {
        indices[indicesOffset++] = count;
        indices[indicesOffset++] = centerIndex;
        indices[indicesOffset++] = count - 1;
      }
      count++;
    }
    indices[indicesOffset++] = centerIndex + 1;
    indices[indicesOffset++] = centerIndex;
    indices[indicesOffset++] = count - 1;
  }
};
const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };


//# sourceMappingURL=buildCircle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildLine: () => (/* binding */ buildLine)
/* harmony export */ });
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs");
/* harmony import */ var _utils_getOrientationOfPoints_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getOrientationOfPoints.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs");




"use strict";
function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
  const eps = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = (0,_utils_getOrientationOfPoints_mjs__WEBPACK_IMPORTED_MODULE_1__.getOrientationOfPoints)(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(points[0], points[1]);
  const lastPoint = new _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.curveEps * _const_mjs__WEBPACK_IMPORTED_MODULE_0__.curveEps;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}


//# sourceMappingURL=buildLine.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildPixelLine: () => (/* binding */ buildPixelLine)
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs");


"use strict";
function buildPixelLine(points, closed, vertices, indices) {
  const eps = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.closePointEps;
  if (points.length === 0) {
    return;
  }
  const fx = points[0];
  const fy = points[1];
  const lx = points[points.length - 2];
  const ly = points[points.length - 1];
  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
  const verts = vertices;
  const length = points.length / 2;
  const indexStart = verts.length / 2;
  for (let i = 0; i < length; i++) {
    verts.push(points[i * 2]);
    verts.push(points[i * 2 + 1]);
  }
  for (let i = 0; i < length - 1; i++) {
    indices.push(indexStart + i, indexStart + i + 1);
  }
  if (closePath) {
    indices.push(indexStart + length - 1, indexStart);
  }
}


//# sourceMappingURL=buildPixelLine.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildPolygon: () => (/* binding */ buildPolygon)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_triangulateWithHoles_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/triangulateWithHoles.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs");



"use strict";
const emptyArray = [];
const buildPolygon = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ShapeBuilder,
    name: "polygon"
  },
  build(shape, points) {
    for (let i = 0; i < shape.points.length; i++) {
      points[i] = shape.points[i];
    }
    return points;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    (0,_utils_triangulateWithHoles_mjs__WEBPACK_IMPORTED_MODULE_1__.triangulateWithHoles)(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
  }
};


//# sourceMappingURL=buildPolygon.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildRectangle: () => (/* binding */ buildRectangle)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const buildRectangle = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ShapeBuilder,
    name: "rectangle"
  },
  build(shape, points) {
    const rectData = shape;
    const x = rectData.x;
    const y = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    if (!(width >= 0 && height >= 0)) {
      return points;
    }
    points[0] = x;
    points[1] = y;
    points[2] = x + width;
    points[3] = y;
    points[4] = x + width;
    points[5] = y + height;
    points[6] = x;
    points[7] = y + height;
    return points;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    let count = 0;
    verticesOffset *= verticesStride;
    vertices[verticesOffset + count] = points[0];
    vertices[verticesOffset + count + 1] = points[1];
    count += verticesStride;
    vertices[verticesOffset + count] = points[2];
    vertices[verticesOffset + count + 1] = points[3];
    count += verticesStride;
    vertices[verticesOffset + count] = points[6];
    vertices[verticesOffset + count + 1] = points[7];
    count += verticesStride;
    vertices[verticesOffset + count] = points[4];
    vertices[verticesOffset + count + 1] = points[5];
    count += verticesStride;
    const verticesIndex = verticesOffset / verticesStride;
    indices[indicesOffset++] = verticesIndex;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 2;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 3;
    indices[indicesOffset++] = verticesIndex + 2;
  }
};


//# sourceMappingURL=buildRectangle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildTriangle: () => (/* binding */ buildTriangle)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");


"use strict";
const buildTriangle = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ShapeBuilder,
    name: "triangle"
  },
  build(shape, points) {
    points[0] = shape.x;
    points[1] = shape.y;
    points[2] = shape.x2;
    points[3] = shape.y2;
    points[4] = shape.x3;
    points[5] = shape.y3;
    return points;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    let count = 0;
    verticesOffset *= verticesStride;
    vertices[verticesOffset + count] = points[0];
    vertices[verticesOffset + count + 1] = points[1];
    count += verticesStride;
    vertices[verticesOffset + count] = points[2];
    vertices[verticesOffset + count + 1] = points[3];
    count += verticesStride;
    vertices[verticesOffset + count] = points[4];
    vertices[verticesOffset + count + 1] = points[5];
    const verticesIndex = verticesOffset / verticesStride;
    indices[indicesOffset++] = verticesIndex;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 2;
  }
};


//# sourceMappingURL=buildTriangle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closePointEps: () => (/* binding */ closePointEps),
/* harmony export */   curveEps: () => (/* binding */ curveEps)
/* harmony export */ });

const closePointEps = 1e-4;
const curveEps = 1e-4;


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FillGradient: () => (/* binding */ FillGradient)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../container/utils/definedProps.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs");









"use strict";
const emptyColorStops = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }];
const _FillGradient = class _FillGradient {
  constructor(...args) {
    /** Unique identifier for this gradient instance */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.uid)("fillGradient");
    /** Type of gradient - currently only supports 'linear' */
    this.type = "linear";
    /** Array of color stops defining the gradient */
    this.colorStops = [];
    let options = ensureGradientOptions(args);
    const defaults = options.type === "radial" ? _FillGradient.defaultRadialOptions : _FillGradient.defaultLinearOptions;
    options = { ...defaults, ...(0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_1__.definedProps)(options) };
    this._textureSize = options.textureSize;
    this._wrapMode = options.wrapMode;
    if (options.type === "radial") {
      this.center = options.center;
      this.outerCenter = options.outerCenter ?? this.center;
      this.innerRadius = options.innerRadius;
      this.outerRadius = options.outerRadius;
      this.scale = options.scale;
      this.rotation = options.rotation;
    } else {
      this.start = options.start;
      this.end = options.end;
    }
    this.textureSpace = options.textureSpace;
    this.type = options.type;
    options.colorStops.forEach((stop) => {
      this.addColorStop(stop.offset, stop.color);
    });
  }
  /**
   * Adds a color stop to the gradient
   * @param offset - Position of the stop (0-1)
   * @param color - Color of the stop
   * @returns This gradient instance for chaining
   */
  addColorStop(offset, color) {
    this.colorStops.push({ offset, color: _color_Color_mjs__WEBPACK_IMPORTED_MODULE_2__.Color.shared.setValue(color).toHexa() });
    return this;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildLinearGradient() {
    if (this.texture)
      return;
    let { x: x0, y: y0 } = this.start;
    let { x: x1, y: y1 } = this.end;
    let dx = x1 - x0;
    let dy = y1 - y0;
    const flip = dx < 0 || dy < 0;
    if (this._wrapMode === "clamp-to-edge") {
      if (dx < 0) {
        const temp = x0;
        x0 = x1;
        x1 = temp;
        dx *= -1;
      }
      if (dy < 0) {
        const temp = y0;
        y0 = y1;
        y1 = temp;
        dy *= -1;
      }
    }
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context } = getCanvas(defaultSize, 1);
    const gradient = !flip ? context.createLinearGradient(0, 0, this._textureSize, 0) : context.createLinearGradient(this._textureSize, 0, 0, 0);
    addColorStops(gradient, colorStops);
    context.fillStyle = gradient;
    context.fillRect(0, 0, defaultSize, 1);
    this.texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture({
      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__.ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    const m = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__.Matrix();
    m.scale(dist / defaultSize, 1);
    m.rotate(angle);
    m.translate(x0, y0);
    if (this.textureSpace === "local") {
      m.scale(defaultSize, defaultSize);
    }
    this.transform = m;
  }
  buildGradient() {
    if (this.type === "linear") {
      this.buildLinearGradient();
    } else {
      this.buildRadialGradient();
    }
  }
  buildRadialGradient() {
    if (this.texture)
      return;
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context } = getCanvas(defaultSize, defaultSize);
    const { x: x0, y: y0 } = this.center;
    const { x: x1, y: y1 } = this.outerCenter;
    const r0 = this.innerRadius;
    const r1 = this.outerRadius;
    const ox = x1 - r1;
    const oy = y1 - r1;
    const scale = defaultSize / (r1 * 2);
    const cx = (x0 - ox) * scale;
    const cy = (y0 - oy) * scale;
    const gradient = context.createRadialGradient(
      cx,
      cy,
      r0 * scale,
      (x1 - ox) * scale,
      (y1 - oy) * scale,
      r1 * scale
    );
    addColorStops(gradient, colorStops);
    context.fillStyle = colorStops[colorStops.length - 1].color;
    context.fillRect(0, 0, defaultSize, defaultSize);
    context.fillStyle = gradient;
    context.translate(cx, cy);
    context.rotate(this.rotation);
    context.scale(1, this.scale);
    context.translate(-cx, -cy);
    context.fillRect(0, 0, defaultSize, defaultSize);
    this.texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture({
      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_4__.ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const m = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_5__.Matrix();
    m.scale(1 / scale, 1 / scale);
    m.translate(ox, oy);
    if (this.textureSpace === "local") {
      m.scale(defaultSize, defaultSize);
    }
    this.transform = m;
  }
  /**
   * Gets a unique key representing the current state of the gradient.
   * Used internally for caching.
   * @returns Unique string key
   */
  get styleKey() {
    return this.uid;
  }
  destroy() {
    this.texture?.destroy(true);
    this.texture = null;
  }
};
/**
 * Default options for creating a gradient fill
 * @property {PointData} start - Start point of the gradient (default: { x: 0, y: 0 })
 * @property {PointData} end - End point of the gradient (default: { x: 0, y: 1 })
 * @property {TextureSpace} textureSpace - Whether coordinates are 'global' or 'local' (default: 'local')
 * @property {number} textureSize - The size of the texture to use for the gradient (default: 256)
 * @property {Array<{offset: number, color: ColorSource}>} colorStops - Array of color stops (default: empty array)
 * @property {GradientType} type - Type of gradient (default: 'linear')
 * @property {WRAP_MODE} wrapMode - The wrap mode of the gradient (default: 'clamp-to-edge')
 */
_FillGradient.defaultLinearOptions = {
  start: { x: 0, y: 0 },
  end: { x: 0, y: 1 },
  colorStops: [],
  textureSpace: "local",
  type: "linear",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
/**
 * Default options for creating a radial gradient fill
 * @property {PointData} innerCenter - Center of the inner circle (default: { x: 0.5, y: 0.5 })
 * @property {number} innerRadius - Radius of the inner circle (default: 0)
 * @property {PointData} outerCenter - Center of the outer circle (default: { x: 0.5, y: 0.5 })
 * @property {number} outerRadius - Radius of the outer circle (default: 0.5)
 * @property {TextureSpace} textureSpace - Whether coordinates are 'global' or 'local' (default: 'local')
 * @property {number} textureSize - The size of the texture to use for the gradient (default: 256)
 * @property {Array<{offset: number, color: ColorSource}>} colorStops - Array of color stops (default: empty array)
 * @property {GradientType} type - Type of gradient (default: 'radial')
 * @property {WRAP_MODE} wrapMode - The wrap mode of the gradient (default: 'clamp-to-edge')
 */
_FillGradient.defaultRadialOptions = {
  center: { x: 0.5, y: 0.5 },
  innerRadius: 0,
  outerRadius: 0.5,
  colorStops: [],
  scale: 1,
  textureSpace: "local",
  type: "radial",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
let FillGradient = _FillGradient;
function addColorStops(gradient, colorStops) {
  for (let i = 0; i < colorStops.length; i++) {
    const stop = colorStops[i];
    gradient.addColorStop(stop.offset, stop.color);
  }
}
function getCanvas(width, height) {
  const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_6__.DOMAdapter.get().createCanvas(width, height);
  const context = canvas.getContext("2d");
  return { canvas, context };
}
function ensureGradientOptions(args) {
  let options = args[0] ?? {};
  if (typeof options === "number" || args[1]) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__.deprecation)("8.5.2", `use options object instead`);
    options = {
      type: "linear",
      start: { x: args[0], y: args[1] },
      end: { x: args[2], y: args[3] },
      textureSpace: args[4],
      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
    };
  }
  return options;
}


//# sourceMappingURL=FillGradient.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FillPattern: () => (/* binding */ FillPattern)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");



"use strict";
const repetitionMap = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class FillPattern {
  constructor(texture, repetition) {
    /** unique id for this fill pattern */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.uid)("fillPattern");
    this.transform = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.Matrix();
    this._styleKey = null;
    this.texture = texture;
    this.transform.scale(
      1 / texture.frame.width,
      1 / texture.frame.height
    );
    if (repetition) {
      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
    }
  }
  setTransform(transform) {
    const texture = this.texture;
    this.transform.copyFrom(transform);
    this.transform.invert();
    this.transform.scale(
      1 / texture.frame.width,
      1 / texture.frame.height
    );
    this._styleKey = null;
  }
  get styleKey() {
    if (this._styleKey)
      return this._styleKey;
    this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;
    return this._styleKey;
  }
}


//# sourceMappingURL=FillPattern.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphicsPath: () => (/* binding */ GraphicsPath)
/* harmony export */ });
/* harmony import */ var _maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../maths/point/Point.mjs */ "./node_modules/pixi.js/lib/maths/point/Point.mjs");
/* harmony import */ var _utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/data/uid.mjs */ "./node_modules/pixi.js/lib/utils/data/uid.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _svg_parseSVGPath_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../svg/parseSVGPath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs");
/* harmony import */ var _ShapePath_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShapePath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs");






"use strict";
class GraphicsPath {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   * @param signed
   */
  constructor(instructions, signed = false) {
    this.instructions = [];
    /** unique id for this graphics path */
    this.uid = (0,_utils_data_uid_mjs__WEBPACK_IMPORTED_MODULE_0__.uid)("graphicsPath");
    this._dirty = true;
    this.checkForHoles = signed;
    if (typeof instructions === "string") {
      (0,_svg_parseSVGPath_mjs__WEBPACK_IMPORTED_MODULE_1__.parseSVGPath)(instructions, this);
    } else {
      this.instructions = instructions?.slice() ?? [];
    }
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    if (!this._shapePath) {
      this._shapePath = new _ShapePath_mjs__WEBPACK_IMPORTED_MODULE_2__.ShapePath(this);
    }
    if (this._dirty) {
      this._dirty = false;
      this._shapePath.buildPath();
    }
    return this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(path, transform) {
    path = path.clone();
    this.instructions.push({ action: "addPath", data: [path, transform] });
    this._dirty = true;
    return this;
  }
  arc(...args) {
    this.instructions.push({ action: "arc", data: args });
    this._dirty = true;
    return this;
  }
  arcTo(...args) {
    this.instructions.push({ action: "arcTo", data: args });
    this._dirty = true;
    return this;
  }
  arcToSvg(...args) {
    this.instructions.push({ action: "arcToSvg", data: args });
    this._dirty = true;
    return this;
  }
  bezierCurveTo(...args) {
    this.instructions.push({ action: "bezierCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(_maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_3__.Point.shared);
    let cp1x = 0;
    let cp1y = 0;
    if (!last || last.action !== "bezierCurveTo") {
      cp1x = lastPoint.x;
      cp1y = lastPoint.y;
    } else {
      cp1x = last.data[2];
      cp1y = last.data[3];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cp1x = currentX + (currentX - cp1x);
      cp1y = currentY + (currentY - cp1y);
    }
    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });
    this._dirty = true;
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this.instructions.push({ action: "closePath", data: [] });
    this._dirty = true;
    return this;
  }
  ellipse(...args) {
    this.instructions.push({ action: "ellipse", data: args });
    this._dirty = true;
    return this;
  }
  lineTo(...args) {
    this.instructions.push({ action: "lineTo", data: args });
    this._dirty = true;
    return this;
  }
  moveTo(...args) {
    this.instructions.push({ action: "moveTo", data: args });
    return this;
  }
  quadraticCurveTo(...args) {
    this.instructions.push({ action: "quadraticCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(x, y, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(_maths_point_Point_mjs__WEBPACK_IMPORTED_MODULE_3__.Point.shared);
    let cpx1 = 0;
    let cpy1 = 0;
    if (!last || last.action !== "quadraticCurveTo") {
      cpx1 = lastPoint.x;
      cpy1 = lastPoint.y;
    } else {
      cpx1 = last.data[0];
      cpy1 = last.data[1];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cpx1 = currentX + (currentX - cpx1);
      cpy1 = currentY + (currentY - cpy1);
    }
    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x, y, w, h, transform) {
    this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x, y, radius, transform) {
    this.instructions.push({ action: "circle", data: [x, y, radius, transform] });
    this._dirty = true;
    return this;
  }
  roundRect(...args) {
    this.instructions.push({ action: "roundRect", data: args });
    this._dirty = true;
    return this;
  }
  poly(...args) {
    this.instructions.push({ action: "poly", data: args });
    this._dirty = true;
    return this;
  }
  regularPoly(...args) {
    this.instructions.push({ action: "regularPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundPoly(...args) {
    this.instructions.push({ action: "roundPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundShape(...args) {
    this.instructions.push({ action: "roundShape", data: args });
    this._dirty = true;
    return this;
  }
  filletRect(...args) {
    this.instructions.push({ action: "filletRect", data: args });
    this._dirty = true;
    return this;
  }
  chamferRect(...args) {
    this.instructions.push({ action: "chamferRect", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(x, y, points, radius, innerRadius, rotation, transform) {
    innerRadius || (innerRadius = radius / 2);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const len = points * 2;
    const delta = Math.PI * 2 / len;
    const polygon = [];
    for (let i = 0; i < len; i++) {
      const r = i % 2 ? innerRadius : radius;
      const angle = i * delta + startAngle;
      polygon.push(
        x + r * Math.cos(angle),
        y + r * Math.sin(angle)
      );
    }
    this.poly(polygon, true, transform);
    return this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(deep = false) {
    const newGraphicsPath2D = new GraphicsPath();
    newGraphicsPath2D.checkForHoles = this.checkForHoles;
    if (!deep) {
      newGraphicsPath2D.instructions = this.instructions.slice();
    } else {
      for (let i = 0; i < this.instructions.length; i++) {
        const instruction = this.instructions[i];
        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
      }
    }
    return newGraphicsPath2D;
  }
  clear() {
    this.instructions.length = 0;
    this._dirty = true;
    return this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(matrix) {
    if (matrix.isIdentity())
      return this;
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let x = 0;
    let y = 0;
    let cpx1 = 0;
    let cpy1 = 0;
    let cpx2 = 0;
    let cpy2 = 0;
    let rx = 0;
    let ry = 0;
    for (let i = 0; i < this.instructions.length; i++) {
      const instruction = this.instructions[i];
      const data = instruction.data;
      switch (instruction.action) {
        case "moveTo":
        case "lineTo":
          x = data[0];
          y = data[1];
          data[0] = a * x + c * y + tx;
          data[1] = b * x + d * y + ty;
          break;
        case "bezierCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          cpx2 = data[2];
          cpy2 = data[3];
          x = data[4];
          y = data[5];
          data[0] = a * cpx1 + c * cpy1 + tx;
          data[1] = b * cpx1 + d * cpy1 + ty;
          data[2] = a * cpx2 + c * cpy2 + tx;
          data[3] = b * cpx2 + d * cpy2 + ty;
          data[4] = a * x + c * y + tx;
          data[5] = b * x + d * y + ty;
          break;
        case "quadraticCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          x = data[2];
          y = data[3];
          data[0] = a * cpx1 + c * cpy1 + tx;
          data[1] = b * cpx1 + d * cpy1 + ty;
          data[2] = a * x + c * y + tx;
          data[3] = b * x + d * y + ty;
          break;
        case "arcToSvg":
          x = data[5];
          y = data[6];
          rx = data[0];
          ry = data[1];
          data[0] = a * rx + c * ry;
          data[1] = b * rx + d * ry;
          data[5] = a * x + c * y + tx;
          data[6] = b * x + d * y + ty;
          break;
        case "circle":
          data[4] = adjustTransform(data[3], matrix);
          break;
        case "rect":
          data[4] = adjustTransform(data[4], matrix);
          break;
        case "ellipse":
          data[8] = adjustTransform(data[8], matrix);
          break;
        case "roundRect":
          data[5] = adjustTransform(data[5], matrix);
          break;
        case "addPath":
          data[0].transform(matrix);
          break;
        case "poly":
          data[2] = adjustTransform(data[2], matrix);
          break;
        default:
          (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_4__.warn)("unknown transform action", instruction.action);
          break;
      }
    }
    this._dirty = true;
    return this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(out) {
    let index = this.instructions.length - 1;
    let lastInstruction = this.instructions[index];
    if (!lastInstruction) {
      out.x = 0;
      out.y = 0;
      return out;
    }
    while (lastInstruction.action === "closePath") {
      index--;
      if (index < 0) {
        out.x = 0;
        out.y = 0;
        return out;
      }
      lastInstruction = this.instructions[index];
    }
    switch (lastInstruction.action) {
      case "moveTo":
      case "lineTo":
        out.x = lastInstruction.data[0];
        out.y = lastInstruction.data[1];
        break;
      case "quadraticCurveTo":
        out.x = lastInstruction.data[2];
        out.y = lastInstruction.data[3];
        break;
      case "bezierCurveTo":
        out.x = lastInstruction.data[4];
        out.y = lastInstruction.data[5];
        break;
      case "arc":
      case "arcToSvg":
        out.x = lastInstruction.data[5];
        out.y = lastInstruction.data[6];
        break;
      case "addPath":
        lastInstruction.data[0].getLastPoint(out);
        break;
    }
    return out;
  }
}
function adjustTransform(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}


//# sourceMappingURL=GraphicsPath.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShapePath: () => (/* binding */ ShapePath)
/* harmony export */ });
/* harmony import */ var _maths_shapes_Circle_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../maths/shapes/Circle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Circle.mjs");
/* harmony import */ var _maths_shapes_Ellipse_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../maths/shapes/Ellipse.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs");
/* harmony import */ var _maths_shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../maths/shapes/Polygon.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _maths_shapes_RoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../maths/shapes/RoundedRectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs");
/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _buildCommands_buildAdaptiveBezier_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../buildCommands/buildAdaptiveBezier.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs");
/* harmony import */ var _buildCommands_buildAdaptiveQuadratic_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../buildCommands/buildAdaptiveQuadratic.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs");
/* harmony import */ var _buildCommands_buildArc_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../buildCommands/buildArc.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs");
/* harmony import */ var _buildCommands_buildArcTo_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../buildCommands/buildArcTo.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs");
/* harmony import */ var _buildCommands_buildArcToSvg_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../buildCommands/buildArcToSvg.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs");
/* harmony import */ var _roundShape_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./roundShape.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs");













"use strict";
const tempRectangle = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
class ShapePath {
  constructor(graphicsPath2D) {
    /** The list of shape primitives that make up the path. */
    this.shapePrimitives = [];
    this._currentPoly = null;
    this._bounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds();
    this._graphicsPath2D = graphicsPath2D;
    this.signed = graphicsPath2D.checkForHoles;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(x, y) {
    this.startPoly(x, y);
    return this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(x, y) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    this._ensurePoly(false);
    const points = this._currentPoly.points;
    (0,_buildCommands_buildArc_mjs__WEBPACK_IMPORTED_MODULE_2__.buildArc)(points, x, y, radius, startAngle, endAngle, counterclockwise);
    return this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    (0,_buildCommands_buildArcTo_mjs__WEBPACK_IMPORTED_MODULE_3__.buildArcTo)(points, x1, y1, x2, y2, radius);
    return this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
    const points = this._currentPoly.points;
    (0,_buildCommands_buildArcToSvg_mjs__WEBPACK_IMPORTED_MODULE_4__.buildArcToSvg)(
      points,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      x,
      y,
      rx,
      ry,
      xAxisRotation,
      largeArcFlag,
      sweepFlag
    );
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    (0,_buildCommands_buildAdaptiveBezier_mjs__WEBPACK_IMPORTED_MODULE_5__.buildAdaptiveBezier)(
      this._currentPoly.points,
      currentPoly.lastX,
      currentPoly.lastY,
      cp1x,
      cp1y,
      cp2x,
      cp2y,
      x,
      y,
      smoothness
    );
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    (0,_buildCommands_buildAdaptiveQuadratic_mjs__WEBPACK_IMPORTED_MODULE_6__.buildAdaptiveQuadratic)(
      this._currentPoly.points,
      currentPoly.lastX,
      currentPoly.lastY,
      cp1x,
      cp1y,
      x,
      y,
      smoothing
    );
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this.endPoly(true);
    return this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(path, transform) {
    this.endPoly();
    if (transform && !transform.isIdentity()) {
      path = path.clone(true);
      path.transform(transform);
    }
    const shapePrimitives = this.shapePrimitives;
    const start = shapePrimitives.length;
    for (let i = 0; i < path.instructions.length; i++) {
      const instruction = path.instructions[i];
      this[instruction.action](...instruction.data);
    }
    if (path.checkForHoles && shapePrimitives.length - start > 1) {
      let mainShape = null;
      for (let i = start; i < shapePrimitives.length; i++) {
        const shapePrimitive = shapePrimitives[i];
        if (shapePrimitive.shape.type === "polygon") {
          const polygon = shapePrimitive.shape;
          const mainPolygon = mainShape?.shape;
          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
            mainShape.holes || (mainShape.holes = []);
            mainShape.holes.push(shapePrimitive);
            shapePrimitives.copyWithin(i, i + 1);
            shapePrimitives.length--;
            i--;
          } else {
            mainShape = shapePrimitive;
          }
        }
      }
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(closePath = false) {
    this.endPoly(closePath);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x, y, w, h, transform) {
    this.drawShape(new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle(x, y, w, h), transform);
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x, y, radius, transform) {
    this.drawShape(new _maths_shapes_Circle_mjs__WEBPACK_IMPORTED_MODULE_7__.Circle(x, y, radius), transform);
    return this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(points, close, transform) {
    const polygon = new _maths_shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_8__.Polygon(points);
    polygon.closePath = close;
    this.drawShape(polygon, transform);
    return this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(x, y, radius, sides, rotation = 0, transform) {
    sides = Math.max(sides | 0, 3);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const polygon = [];
    for (let i = 0; i < sides; i++) {
      const angle = startAngle - i * delta;
      polygon.push(
        x + radius * Math.cos(angle),
        y + radius * Math.sin(angle)
      );
    }
    this.poly(polygon, true, transform);
    return this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {
    sides = Math.max(sides | 0, 3);
    if (corner <= 0) {
      return this.regularPoly(x, y, radius, sides, rotation);
    }
    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
    corner = Math.min(corner, sideLength);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const internalAngle = (sides - 2) * Math.PI / sides / 2;
    for (let i = 0; i < sides; i++) {
      const angle = i * delta + startAngle;
      const x0 = x + radius * Math.cos(angle);
      const y0 = y + radius * Math.sin(angle);
      const a1 = angle + Math.PI + internalAngle;
      const a2 = angle - Math.PI - internalAngle;
      const x1 = x0 + corner * Math.cos(a1);
      const y1 = y0 + corner * Math.sin(a1);
      const x3 = x0 + corner * Math.cos(a2);
      const y3 = y0 + corner * Math.sin(a2);
      if (i === 0) {
        this.moveTo(x1, y1);
      } else {
        this.lineTo(x1, y1);
      }
      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(points, radius, useQuadratic = false, smoothness) {
    if (points.length < 3) {
      return this;
    }
    if (useQuadratic) {
      (0,_roundShape_mjs__WEBPACK_IMPORTED_MODULE_9__.roundedShapeQuadraticCurve)(this, points, radius, smoothness);
    } else {
      (0,_roundShape_mjs__WEBPACK_IMPORTED_MODULE_9__.roundedShapeArc)(this, points, radius);
    }
    return this.closePath();
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(x, y, width, height, fillet) {
    if (fillet === 0) {
      return this.rect(x, y, width, height);
    }
    const maxFillet = Math.min(width, height) / 2;
    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
    const right = x + width;
    const bottom = y + height;
    const dir = inset < 0 ? -inset : 0;
    const size = Math.abs(inset);
    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(x, y, width, height, chamfer, transform) {
    if (chamfer <= 0) {
      return this.rect(x, y, width, height);
    }
    const inset = Math.min(chamfer, Math.min(width, height) / 2);
    const right = x + width;
    const bottom = y + height;
    const points = [
      x + inset,
      y,
      right - inset,
      y,
      right,
      y + inset,
      right,
      bottom - inset,
      right - inset,
      bottom,
      x + inset,
      bottom,
      x,
      bottom - inset,
      x,
      y + inset
    ];
    for (let i = points.length - 1; i >= 2; i -= 2) {
      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {
        points.splice(i - 1, 2);
      }
    }
    return this.poly(points, true, transform);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(x, y, radiusX, radiusY, transform) {
    this.drawShape(new _maths_shapes_Ellipse_mjs__WEBPACK_IMPORTED_MODULE_10__.Ellipse(x, y, radiusX, radiusY), transform);
    return this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(x, y, w, h, radius, transform) {
    this.drawShape(new _maths_shapes_RoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_11__.RoundedRectangle(x, y, w, h, radius), transform);
    return this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(shape, matrix) {
    this.endPoly();
    this.shapePrimitives.push({ shape, transform: matrix });
    return this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(x, y) {
    let currentPoly = this._currentPoly;
    if (currentPoly) {
      this.endPoly();
    }
    currentPoly = new _maths_shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_8__.Polygon();
    currentPoly.points.push(x, y);
    this._currentPoly = currentPoly;
    return this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(closePath = false) {
    const shape = this._currentPoly;
    if (shape && shape.points.length > 2) {
      shape.closePath = closePath;
      this.shapePrimitives.push({ shape });
    }
    this._currentPoly = null;
    return this;
  }
  _ensurePoly(start = true) {
    if (this._currentPoly)
      return;
    this._currentPoly = new _maths_shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_8__.Polygon();
    if (start) {
      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (lastShape) {
        let lx = lastShape.shape.x;
        let ly = lastShape.shape.y;
        if (lastShape.transform && !lastShape.transform.isIdentity()) {
          const t = lastShape.transform;
          const tempX = lx;
          lx = t.a * lx + t.c * ly + t.tx;
          ly = t.b * tempX + t.d * ly + t.ty;
        }
        this._currentPoly.points.push(lx, ly);
      } else {
        this._currentPoly.points.push(0, 0);
      }
    }
  }
  /** Builds the path. */
  buildPath() {
    const path = this._graphicsPath2D;
    this.shapePrimitives.length = 0;
    this._currentPoly = null;
    for (let i = 0; i < path.instructions.length; i++) {
      const instruction = path.instructions[i];
      this[instruction.action](...instruction.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const bounds = this._bounds;
    bounds.clear();
    const shapePrimitives = this.shapePrimitives;
    for (let i = 0; i < shapePrimitives.length; i++) {
      const shapePrimitive = shapePrimitives[i];
      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
      if (shapePrimitive.transform) {
        bounds.addRect(boundsRect, shapePrimitive.transform);
      } else {
        bounds.addRect(boundsRect);
      }
    }
    return bounds;
  }
}


//# sourceMappingURL=ShapePath.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   roundedShapeArc: () => (/* binding */ roundedShapeArc),
/* harmony export */   roundedShapeQuadraticCurve: () => (/* binding */ roundedShapeQuadraticCurve)
/* harmony export */ });

function roundedShapeArc(g, points, radius) {
  const vecFrom = (p, pp) => {
    const x = pp.x - p.x;
    const y = pp.y - p.y;
    const len = Math.sqrt(x * x + y * y);
    const nx = x / len;
    const ny = y / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i, p) => {
    if (i === 0) {
      g.moveTo(p.x, p.y);
    } else {
      g.lineTo(p.x, p.y);
    }
  };
  let p1 = points[points.length - 1];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i % points.length];
    const pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i, p2);
      p1 = p2;
      continue;
    }
    const p3 = points[(i + 1) % points.length];
    const v1 = vecFrom(p2, p1);
    const v2 = vecFrom(p2, p3);
    if (v1.len < 1e-4 || v2.len < 1e-4) {
      sharpCorner(i, p2);
      p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
    let radDirection = 1;
    let drawDirection = false;
    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
    const halfAngle = angle / 2;
    let cRadius;
    let lenOut = Math.abs(
      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
    );
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = pRadius;
    }
    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
    if (i === 0) {
      g.moveTo(
        cX + Math.cos(startAngle) * cRadius,
        cY + Math.sin(startAngle) * cRadius
      );
    }
    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
    p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g, points, radius, smoothness) {
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t) => ({
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  });
  const numPoints = points.length;
  for (let i = 0; i < numPoints; i++) {
    const thisPoint = points[(i + 1) % numPoints];
    const pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      if (i === 0) {
        g.moveTo(thisPoint.x, thisPoint.y);
      } else {
        g.lineTo(thisPoint.x, thisPoint.y);
      }
      continue;
    }
    const lastPoint = points[i];
    const nextPoint = points[(i + 2) % numPoints];
    const lastEdgeLength = distance(lastPoint, thisPoint);
    let start;
    if (lastEdgeLength < 1e-4) {
      start = thisPoint;
    } else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start = pointLerp(
        thisPoint,
        lastPoint,
        lastOffsetDistance / lastEdgeLength
      );
    }
    const nextEdgeLength = distance(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 1e-4) {
      end = thisPoint;
    } else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(
        thisPoint,
        nextPoint,
        nextOffsetDistance / nextEdgeLength
      );
    }
    if (i === 0) {
      g.moveTo(start.x, start.y);
    } else {
      g.lineTo(start.x, start.y);
    }
    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
  }
}


//# sourceMappingURL=roundShape.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SVGParser: () => (/* binding */ SVGParser)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../path/GraphicsPath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs");
/* harmony import */ var _parseSVGDefinitions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseSVGDefinitions.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs");
/* harmony import */ var _parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parseSVGFloatAttribute.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs");
/* harmony import */ var _parseSVGStyle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parseSVGStyle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs");






"use strict";
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    defs: {},
    path: new _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_0__.GraphicsPath()
  };
  (0,_parseSVGDefinitions_mjs__WEBPACK_IMPORTED_MODULE_1__.parseSVGDefinitions)(svg, session);
  const children = svg.children;
  const { fillStyle, strokeStyle } = (0,_parseSVGStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.parseSVGStyle)(svg, session);
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.nodeName.toLowerCase() === "defs")
      continue;
    renderChildren(child, session, fillStyle, strokeStyle);
  }
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = (0,_parseSVGStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.parseSVGStyle)(svg, session);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  const noStyle = !fillStyle && !strokeStyle;
  if (noStyle) {
    fillStyle = { color: 0 };
  }
  let x;
  let y;
  let x1;
  let y1;
  let x2;
  let y2;
  let cx;
  let cy;
  let r;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path":
      d = svg.getAttribute("d");
      if (svg.getAttribute("fill-rule") === "evenodd") {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__.warn)("SVG Evenodd fill rule not supported, your svg may render incorrectly");
      }
      graphicsPath = new _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_0__.GraphicsPath(d, true);
      session.context.path(graphicsPath);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "circle":
      cx = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "cx", 0);
      cy = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "cy", 0);
      r = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "r", 0);
      session.context.ellipse(cx, cy, r, r);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "rect":
      x = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "x", 0);
      y = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "y", 0);
      width = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "width", 0);
      height = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "height", 0);
      rx = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "rx", 0);
      ry = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x, y, width, height, rx || ry);
      } else {
        session.context.rect(x, y, width, height);
      }
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "ellipse":
      cx = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "cx", 0);
      cy = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "cy", 0);
      rx = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "rx", 0);
      ry = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "line":
      x1 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "x1", 0);
      y1 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "y1", 0);
      x2 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "x2", 0);
      y2 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_4__.parseSVGFloatAttribute)(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x2, y2);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n) => parseInt(n, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n) => parseInt(n, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "g":
    case "svg":
      break;
    default: {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__.warn)(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  if (noStyle) {
    fillStyle = null;
  }
  for (let i = 0; i < children.length; i++) {
    renderChildren(children[i], session, fillStyle, strokeStyle);
  }
}


//# sourceMappingURL=SVGParser.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseSVGDefinitions: () => (/* binding */ parseSVGDefinitions)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fill/FillGradient.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs");
/* harmony import */ var _parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseSVGFloatAttribute.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs");





"use strict";
function parseSVGDefinitions(svg, session) {
  const definitions = svg.querySelectorAll("defs");
  for (let i = 0; i < definitions.length; i++) {
    const definition = definitions[i];
    for (let j = 0; j < definition.children.length; j++) {
      const child = definition.children[j];
      switch (child.nodeName.toLowerCase()) {
        case "lineargradient":
          session.defs[child.id] = parseLinearGradient(child);
          break;
        case "radialgradient":
          session.defs[child.id] = parseRadialGradient(child);
          break;
        default:
          break;
      }
    }
  }
}
function parseLinearGradient(child) {
  const x0 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_0__.parseSVGFloatAttribute)(child, "x1", 0);
  const y0 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_0__.parseSVGFloatAttribute)(child, "y1", 0);
  const x1 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_0__.parseSVGFloatAttribute)(child, "x2", 1);
  const y1 = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_0__.parseSVGFloatAttribute)(child, "y2", 0);
  const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
  const gradient = new _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_1__.FillGradient(
    x0,
    y0,
    x1,
    y1,
    gradientUnit === "objectBoundingBox" ? "local" : "global"
  );
  for (let k = 0; k < child.children.length; k++) {
    const stop = child.children[k];
    const offset = (0,_parseSVGFloatAttribute_mjs__WEBPACK_IMPORTED_MODULE_0__.parseSVGFloatAttribute)(stop, "offset", 0);
    const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_2__.Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
    gradient.addColorStop(offset, color);
  }
  return gradient;
}
function parseRadialGradient(_child) {
  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__.warn)("[SVG Parser] Radial gradients are not yet supported");
  return new _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_1__.FillGradient(0, 0, 1, 0);
}


//# sourceMappingURL=parseSVGDefinitions.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseSVGFloatAttribute: () => (/* binding */ parseSVGFloatAttribute)
/* harmony export */ });

function parseSVGFloatAttribute(svg, id, defaultValue) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue;
}


//# sourceMappingURL=parseSVGFloatAttribute.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseSVGPath: () => (/* binding */ parseSVGPath)
/* harmony export */ });
/* harmony import */ var parse_svg_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse-svg-path */ "./node_modules/parse-svg-path/index.js");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");



"use strict";
function parseSVGPath(svgPath, path) {
  const commands = parse_svg_path__WEBPACK_IMPORTED_MODULE_0__(svgPath);
  const subpaths = [];
  let currentSubPath = null;
  let lastX = 0;
  let lastY = 0;
  for (let i = 0; i < commands.length; i++) {
    const command = commands[i];
    const type = command[0];
    const data = command;
    switch (type) {
      case "M":
        lastX = data[1];
        lastY = data[2];
        path.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[1];
        lastY += data[2];
        path.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[1];
        path.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[1];
        path.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[1];
        path.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[1];
        path.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[1];
        lastY = data[2];
        path.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[1];
        lastY += data[2];
        path.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[5];
        lastY = data[6];
        path.bezierCurveTo(
          data[1],
          data[2],
          // First control point
          data[3],
          data[4],
          // Second control point
          lastX,
          lastY
          // End point
        );
        break;
      case "c":
        path.bezierCurveTo(
          lastX + data[1],
          lastY + data[2],
          // First control point
          lastX + data[3],
          lastY + data[4],
          // Second control point
          lastX + data[5],
          lastY + data[6]
          // End point
        );
        lastX += data[5];
        lastY += data[6];
        break;
      case "S":
        lastX = data[3];
        lastY = data[4];
        path.bezierCurveToShort(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "s":
        path.bezierCurveToShort(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "Q":
        lastX = data[3];
        lastY = data[4];
        path.quadraticCurveTo(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "q":
        path.quadraticCurveTo(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "T":
        lastX = data[1];
        lastY = data[2];
        path.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "t":
        lastX += data[1];
        lastY += data[2];
        path.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "A":
        lastX = data[6];
        lastY = data[7];
        path.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "a":
        lastX += data[6];
        lastY += data[7];
        path.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "Z":
      case "z":
        path.closePath();
        if (subpaths.length > 0) {
          currentSubPath = subpaths.pop();
          if (currentSubPath) {
            lastX = currentSubPath.startX;
            lastY = currentSubPath.startY;
          } else {
            lastX = 0;
            lastY = 0;
          }
        }
        currentSubPath = null;
        break;
      default:
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__.warn)(`Unknown SVG path command: ${type}`);
    }
    if (type !== "Z" && type !== "z") {
      if (currentSubPath === null) {
        currentSubPath = { startX: lastX, startY: lastY };
        subpaths.push(currentSubPath);
      }
    }
  }
  return path;
}


//# sourceMappingURL=parseSVGPath.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAttribute: () => (/* binding */ parseAttribute),
/* harmony export */   parseSVGStyle: () => (/* binding */ parseSVGStyle),
/* harmony export */   styleAttributes: () => (/* binding */ styleAttributes)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _utils_extractSvgUrlId_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/extractSvgUrlId.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs");



"use strict";
const styleAttributes = {
  // Fill properties
  fill: { type: "paint", default: 0 },
  // Fill color/gradient
  "fill-opacity": { type: "number", default: 1 },
  // Fill transparency
  // Stroke properties
  stroke: { type: "paint", default: 0 },
  // Stroke color/gradient
  "stroke-width": { type: "number", default: 1 },
  // Width of stroke
  "stroke-opacity": { type: "number", default: 1 },
  // Stroke transparency
  "stroke-linecap": { type: "string", default: "butt" },
  // End cap style: butt, round, square
  "stroke-linejoin": { type: "string", default: "miter" },
  // Join style: miter, round, bevel
  "stroke-miterlimit": { type: "number", default: 10 },
  // Limit on miter join sharpness
  "stroke-dasharray": { type: "string", default: "none" },
  // Dash pattern
  "stroke-dashoffset": { type: "number", default: 0 },
  // Offset for dash pattern
  // Global properties
  opacity: { type: "number", default: 1 }
  // Overall opacity
};
function parseSVGStyle(svg, session) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  const result = {
    strokeStyle,
    fillStyle,
    useFill: false,
    useStroke: false
  };
  for (const key in styleAttributes) {
    const attribute = svg.getAttribute(key);
    if (attribute) {
      parseAttribute(session, result, key, attribute.trim());
    }
  }
  if (style) {
    const styleParts = style.split(";");
    for (let i = 0; i < styleParts.length; i++) {
      const stylePart = styleParts[i].trim();
      const [key, value] = stylePart.split(":");
      if (styleAttributes[key]) {
        parseAttribute(session, result, key, value.trim());
      }
    }
  }
  return {
    strokeStyle: result.useStroke ? strokeStyle : null,
    fillStyle: result.useFill ? fillStyle : null,
    useFill: result.useFill,
    useStroke: result.useStroke
  };
}
function parseAttribute(session, result, id, value) {
  switch (id) {
    case "stroke":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = (0,_utils_extractSvgUrlId_mjs__WEBPACK_IMPORTED_MODULE_0__.extractSvgUrlId)(value);
          result.strokeStyle.fill = session.defs[id2];
        } else {
          result.strokeStyle.color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Color.shared.setValue(value).toNumber();
        }
        result.useStroke = true;
      }
      break;
    case "stroke-width":
      result.strokeStyle.width = Number(value);
      break;
    case "fill":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = (0,_utils_extractSvgUrlId_mjs__WEBPACK_IMPORTED_MODULE_0__.extractSvgUrlId)(value);
          result.fillStyle.fill = session.defs[id2];
        } else {
          result.fillStyle.color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Color.shared.setValue(value).toNumber();
        }
        result.useFill = true;
      }
      break;
    case "fill-opacity":
      result.fillStyle.alpha = Number(value);
      break;
    case "stroke-opacity":
      result.strokeStyle.alpha = Number(value);
      break;
    case "opacity":
      result.fillStyle.alpha = Number(value);
      result.strokeStyle.alpha = Number(value);
      break;
  }
}


//# sourceMappingURL=parseSVGStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractSvgUrlId: () => (/* binding */ extractSvgUrlId)
/* harmony export */ });

function extractSvgUrlId(url) {
  const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return match ? match[1] : "";
}


//# sourceMappingURL=extractSvgUrlId.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildContextBatches: () => (/* binding */ buildContextBatches),
/* harmony export */   shapeBuilders: () => (/* binding */ shapeBuilders)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_transformVertices_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _BatchableGraphics_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../BatchableGraphics.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs");
/* harmony import */ var _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../buildCommands/buildCircle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs");
/* harmony import */ var _buildCommands_buildLine_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../buildCommands/buildLine.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs");
/* harmony import */ var _buildCommands_buildPixelLine_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../buildCommands/buildPixelLine.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs");
/* harmony import */ var _buildCommands_buildPolygon_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../buildCommands/buildPolygon.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs");
/* harmony import */ var _buildCommands_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../buildCommands/buildRectangle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs");
/* harmony import */ var _buildCommands_buildTriangle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../buildCommands/buildTriangle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs");
/* harmony import */ var _generateTextureFillMatrix_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./generateTextureFillMatrix.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs");
/* harmony import */ var _triangulateWithHoles_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./triangulateWithHoles.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs");

















"use strict";
const shapeBuilders = {};
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions.handleByMap(_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ShapeBuilder, shapeBuilders);
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions.add(_buildCommands_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.buildRectangle, _buildCommands_buildPolygon_mjs__WEBPACK_IMPORTED_MODULE_2__.buildPolygon, _buildCommands_buildTriangle_mjs__WEBPACK_IMPORTED_MODULE_3__.buildTriangle, _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_4__.buildCircle, _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_4__.buildEllipse, _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_4__.buildRoundedRectangle);
const tempRect = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__.Rectangle();
const tempTextureMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__.Matrix();
function buildContextBatches(context, gpuContext) {
  const { geometryData, batches } = gpuContext;
  batches.length = 0;
  geometryData.indices.length = 0;
  geometryData.vertices.length = 0;
  geometryData.uvs.length = 0;
  for (let i = 0; i < context.instructions.length; i++) {
    const instruction = context.instructions[i];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
      }
      if (hole) {
        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
      }
      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
    }
  }
}
function addTextureToGeometryData(data, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  const points = [];
  const build = shapeBuilders.rectangle;
  const rect = tempRect;
  const texture = data.image;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  build.build(rect, points);
  if (matrix) {
    (0,_rendering_renderers_shared_geometry_utils_transformVertices_mjs__WEBPACK_IMPORTED_MODULE_7__.transformVertices)(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const textureUvs = texture.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_8__.BigPool.get(_BatchableGraphics_mjs__WEBPACK_IMPORTED_MODULE_9__.BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.attributeOffset = vertOffset;
  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
  graphicsBatch.baseColor = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = shapeBuilders[shape.type];
    let topology = "triangle-list";
    build.build(shape, points);
    if (matrix) {
      (0,_rendering_renderers_shared_geometry_utils_transformVertices_mjs__WEBPACK_IMPORTED_MODULE_7__.transformVertices)(points, matrix);
    }
    if (!isStroke) {
      if (holes) {
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(holes);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        (0,_triangulateWithHoles_mjs__WEBPACK_IMPORTED_MODULE_10__.triangulateWithHoles)(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      if (!lineStyle.pixelLine) {
        (0,_buildCommands_buildLine_mjs__WEBPACK_IMPORTED_MODULE_11__.buildLine)(points, lineStyle, false, close, vertices, indices);
      } else {
        (0,_buildCommands_buildPixelLine_mjs__WEBPACK_IMPORTED_MODULE_12__.buildPixelLine)(points, close, vertices, indices);
        topology = "line-list";
      }
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_13__.Texture.WHITE) {
      const textureMatrix = (0,_generateTextureFillMatrix_mjs__WEBPACK_IMPORTED_MODULE_14__.generateTextureMatrix)(tempTextureMatrix, style, shape, matrix);
      (0,_rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_15__.buildUvs)(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      (0,_rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_15__.buildSimpleUvs)(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_8__.BigPool.get(_BatchableGraphics_mjs__WEBPACK_IMPORTED_MODULE_9__.BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    graphicsBatch.topology = topology;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(holePrimitives) {
  const holeArrays = [];
  for (let k = 0; k < holePrimitives.length; k++) {
    const holePrimitive = holePrimitives[k].shape;
    const holePoints = [];
    const holeBuilder = shapeBuilders[holePrimitive.type];
    holeBuilder.build(holePrimitive, holePoints);
    holeArrays.push(holePoints);
  }
  return holeArrays;
}


//# sourceMappingURL=buildContextBatches.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildGeometryFromPath: () => (/* binding */ buildGeometryFromPath)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_transformVertices_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs");
/* harmony import */ var _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../mesh/shared/MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");
/* harmony import */ var _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../buildCommands/buildCircle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs");
/* harmony import */ var _buildCommands_buildPolygon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../buildCommands/buildPolygon.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs");
/* harmony import */ var _buildCommands_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../buildCommands/buildRectangle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs");
/* harmony import */ var _buildCommands_buildTriangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../buildCommands/buildTriangle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs");
/* harmony import */ var _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../path/GraphicsPath.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs");









"use strict";
const buildMap = {
  rectangle: _buildCommands_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.buildRectangle,
  polygon: _buildCommands_buildPolygon_mjs__WEBPACK_IMPORTED_MODULE_1__.buildPolygon,
  triangle: _buildCommands_buildTriangle_mjs__WEBPACK_IMPORTED_MODULE_2__.buildTriangle,
  circle: _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_3__.buildCircle,
  ellipse: _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_3__.buildCircle,
  roundedRectangle: _buildCommands_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_3__.buildCircle
};
function buildGeometryFromPath(options) {
  if (options instanceof _path_GraphicsPath_mjs__WEBPACK_IMPORTED_MODULE_4__.GraphicsPath) {
    options = {
      path: options,
      textureMatrix: null,
      out: null
    };
  }
  const vertices = [];
  const uvs = [];
  const indices = [];
  const shapePath = options.path.shapePath;
  const textureMatrix = options.textureMatrix;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = buildMap[shape.type];
    build.build(shape, points);
    if (matrix) {
      (0,_rendering_renderers_shared_geometry_utils_transformVertices_mjs__WEBPACK_IMPORTED_MODULE_5__.transformVertices)(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const uvsOffset = uvs.length / 2;
    if (textureMatrix) {
      if (matrix) {
        textureMatrix.append(matrix.clone().invert());
      }
      (0,_rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_6__.buildUvs)(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      (0,_rendering_renderers_shared_geometry_utils_buildUvs_mjs__WEBPACK_IMPORTED_MODULE_6__.buildSimpleUvs)(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
  });
  const out = options.out;
  if (out) {
    out.positions = new Float32Array(vertices);
    out.uvs = new Float32Array(uvs);
    out.indices = new Uint32Array(indices);
    return out;
  }
  const geometry = new _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_7__.MeshGeometry({
    positions: new Float32Array(vertices),
    uvs: new Float32Array(uvs),
    indices: new Uint32Array(indices)
  });
  return geometry;
}


//# sourceMappingURL=buildGeometryFromPath.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toFillStyle: () => (/* binding */ toFillStyle),
/* harmony export */   toStrokeStyle: () => (/* binding */ toStrokeStyle)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fill/FillGradient.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs");
/* harmony import */ var _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../fill/FillPattern.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs");





"use strict";
function isColorLike(value) {
  return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.isColorLike(value);
}
function isFillPattern(value) {
  return value instanceof _fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_1__.FillPattern;
}
function isFillGradient(value) {
  return value instanceof _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__.FillGradient;
}
function isTexture(value) {
  return value instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture;
}
function handleColorLike(fill, value, defaultStyle) {
  const temp = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(value ?? 0);
  fill.color = temp.toNumber();
  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
  fill.texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture.WHITE;
  return { ...defaultStyle, ...fill };
}
function handleTexture(fill, value, defaultStyle) {
  fill.texture = value;
  return { ...defaultStyle, ...fill };
}
function handleFillPattern(fill, value, defaultStyle) {
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillGradient(fill, value, defaultStyle) {
  value.buildGradient();
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  fill.textureSpace = value.textureSpace;
  return { ...defaultStyle, ...fill };
}
function handleFillObject(value, defaultStyle) {
  const style = { ...defaultStyle, ...value };
  const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(style.color);
  style.alpha *= color.alpha;
  style.color = color.toNumber();
  return style;
}
function toFillStyle(value, defaultStyle) {
  if (value === void 0 || value === null) {
    return null;
  }
  const fill = {};
  const objectStyle = value;
  if (isColorLike(value)) {
    return handleColorLike(fill, value, defaultStyle);
  } else if (isTexture(value)) {
    return handleTexture(fill, value, defaultStyle);
  } else if (isFillPattern(value)) {
    return handleFillPattern(fill, value, defaultStyle);
  } else if (isFillGradient(value)) {
    return handleFillGradient(fill, value, defaultStyle);
  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
  }
  return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value, defaultStyle) {
  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;
  const fill = toFillStyle(value, rest);
  if (!fill) {
    return null;
  }
  return {
    width,
    alignment,
    miterLimit,
    cap,
    join,
    pixelLine,
    ...fill
  };
}


//# sourceMappingURL=convertFillInputToFillStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateTextureMatrix: () => (/* binding */ generateTextureMatrix)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fill/FillGradient.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs");




"use strict";
const tempTextureMatrix = new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
const tempRect = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
function generateTextureMatrix(out, style, shape, matrix) {
  const textureMatrix = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();
  if (style.textureSpace === "local") {
    const bounds = shape.getBounds(tempRect);
    if (style.width) {
      bounds.pad(style.width);
    }
    const { x: tx, y: ty } = bounds;
    const sx = 1 / bounds.width;
    const sy = 1 / bounds.height;
    const mTx = -tx * sx;
    const mTy = -ty * sy;
    const a1 = textureMatrix.a;
    const b1 = textureMatrix.b;
    const c1 = textureMatrix.c;
    const d1 = textureMatrix.d;
    textureMatrix.a *= sx;
    textureMatrix.b *= sx;
    textureMatrix.c *= sy;
    textureMatrix.d *= sy;
    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
  } else {
    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
  }
  const sourceStyle = style.texture.source.style;
  if (!(style.fill instanceof _fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_2__.FillGradient) && sourceStyle.addressMode === "clamp-to-edge") {
    sourceStyle.addressMode = "repeat";
    sourceStyle.update();
  }
  if (matrix) {
    textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());
  }
  return textureMatrix;
}


//# sourceMappingURL=generateTextureFillMatrix.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getOrientationOfPoints: () => (/* binding */ getOrientationOfPoints)
/* harmony export */ });

function getOrientationOfPoints(points) {
  const m = points.length;
  if (m < 6) {
    return 1;
  }
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}


//# sourceMappingURL=getOrientationOfPoints.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triangulateWithHoles: () => (/* binding */ triangulateWithHoles)
/* harmony export */ });
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");


"use strict";
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = earcut__WEBPACK_IMPORTED_MODULE_0__(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i = 0; i < triangles.length; i += 3) {
    indices[indicesOffset++] = triangles[i] + verticesOffset;
    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i = 0; i < points.length; i += 2) {
    vertices[index] = points[i];
    vertices[index + 1] = points[i + 1];
    index += verticesStride;
  }
}


//# sourceMappingURL=triangulateWithHoles.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/layers/RenderLayer.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/layers/RenderLayer.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderLayer: () => (/* binding */ RenderLayer),
/* harmony export */   RenderLayerClass: () => (/* binding */ RenderLayerClass)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");



"use strict";
const _RenderLayerClass = class _RenderLayerClass extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__.Container {
  /**
   * Creates a new RenderLayer instance
   * @param options - Configuration options for the RenderLayer
   * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render
   * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex
   */
  constructor(options = {}) {
    options = { ..._RenderLayerClass.defaultOptions, ...options };
    super();
    /** List of objects to be rendered by this layer */
    this.renderLayerChildren = [];
    this.sortableChildren = options.sortableChildren;
    this.sortFunction = options.sortFunction;
  }
  /**
   * Add an Container to this render layer. The Container will be rendered as part of this layer
   * while maintaining its original parent in the scene graph.
   * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.
   * @param children - The Container(s) to add to this layer
   */
  attach(...children) {
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.parentRenderLayer) {
        if (child.parentRenderLayer === this)
          continue;
        child.parentRenderLayer.detach(child);
      }
      this.renderLayerChildren.push(child);
      child.parentRenderLayer = this;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
    }
    return children[0];
  }
  /**
   * Remove an Container from this render layer. The Container will no longer be rendered
   * as part of this layer but maintains its original parent.
   * @param children - The Container(s) to remove from this layer
   */
  detach(...children) {
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const index = this.renderLayerChildren.indexOf(child);
      if (index !== -1) {
        this.renderLayerChildren.splice(index, 1);
      }
      child.parentRenderLayer = null;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
    }
    return children[0];
  }
  /** Remove all objects from this render layer. */
  detachAll() {
    const layerChildren = this.renderLayerChildren;
    for (let i = 0; i < layerChildren.length; i++) {
      layerChildren[i].parentRenderLayer = null;
    }
    this.renderLayerChildren.length = 0;
  }
  collectRenderables(instructionSet, renderer, _currentLayer) {
    const layerChildren = this.renderLayerChildren;
    const length = layerChildren.length;
    if (this.sortableChildren) {
      this.sortRenderLayerChildren();
    }
    for (let i = 0; i < length; i++) {
      if (!layerChildren[i].parent) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_1__.warn)(
          "Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)",
          layerChildren[i]
        );
      }
      layerChildren[i].collectRenderables(instructionSet, renderer, this);
    }
  }
  /**
   * Sort the layer's children using the defined sort function.
   * Will be called each render if sortableChildren is true.
   * Otherwise can call this manually.
   */
  sortRenderLayerChildren() {
    this.renderLayerChildren.sort(this.sortFunction);
  }
  _getGlobalBoundsRecursive(factorRenderLayers, bounds, _currentLayer) {
    if (!factorRenderLayers)
      return;
    const children = this.renderLayerChildren;
    for (let i = 0; i < children.length; i++) {
      children[i]._getGlobalBoundsRecursive(true, bounds, this);
    }
  }
};
/**
 * Default options for RenderLayer instances
 * @property {boolean} sortableChildren - If true, layer children will be automatically sorted each render.
 * Default false.
 * @property {Function} sortFunction - Function used to sort layer children. Default sorts by zIndex.
 */
_RenderLayerClass.defaultOptions = {
  sortableChildren: false,
  sortFunction: (a, b) => a.zIndex - b.zIndex
};
let RenderLayerClass = _RenderLayerClass;
const RenderLayer = RenderLayerClass;


//# sourceMappingURL=RenderLayer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerspectiveMesh: () => (/* binding */ PerspectiveMesh)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/utils/definedProps.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs");
/* harmony import */ var _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/shared/Mesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs");
/* harmony import */ var _PerspectivePlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PerspectivePlaneGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs");





"use strict";
const _PerspectiveMesh = class _PerspectiveMesh extends _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__.Mesh {
  /**
   * @param options - Options to be applied to PerspectiveMesh
   */
  constructor(options) {
    options = { ..._PerspectiveMesh.defaultOptions, ...options };
    const { texture, verticesX, verticesY, ...rest } = options;
    const planeGeometry = new _PerspectivePlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__.PerspectivePlaneGeometry((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({
      width: texture.width,
      height: texture.height,
      verticesX,
      verticesY
    }));
    super((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({ ...rest, geometry: planeGeometry }));
    this._texture = texture;
    this.geometry.setCorners(
      options.x0,
      options.y0,
      options.x1,
      options.y1,
      options.x2,
      options.y2,
      options.x3,
      options.y3
    );
  }
  /** Update the geometry when the texture is updated */
  textureUpdated() {
    const geometry = this.geometry;
    if (!geometry)
      return;
    const { width, height } = this.texture;
    if (geometry.width !== width || geometry.height !== height) {
      geometry.width = width;
      geometry.height = height;
      geometry.updateProjection();
    }
  }
  set texture(value) {
    if (this._texture === value)
      return;
    super.texture = value;
    this.textureUpdated();
  }
  /** The texture that the mesh uses */
  get texture() {
    return this._texture;
  }
  /**
   * Set the corners of the quad to the given coordinates
   * The mesh will then calculate the perspective so it looks correct!
   * @param x0 - x coordinate of the first corner
   * @param y0 - y coordinate of the first corner
   * @param x1 - x coordinate of the second corner
   * @param y1 - y coordinate of the second corner
   * @param x2 - x coordinate of the third corner
   * @param y2 - y coordinate of the third corner
   * @param x3 - x coordinate of the fourth corner
   * @param y3 - y coordinate of the fourth corner
   */
  setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
    this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);
  }
};
/** default options for the mesh */
_PerspectiveMesh.defaultOptions = {
  texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture.WHITE,
  verticesX: 10,
  verticesY: 10,
  x0: 0,
  y0: 0,
  x1: 100,
  y1: 0,
  x2: 100,
  y2: 100,
  x3: 0,
  y3: 100
};
let PerspectiveMesh = _PerspectiveMesh;


//# sourceMappingURL=PerspectiveMesh.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerspectivePlaneGeometry: () => (/* binding */ PerspectivePlaneGeometry)
/* harmony export */ });
/* harmony import */ var _mesh_plane_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh-plane/PlaneGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs");
/* harmony import */ var _utils_applyProjectiveTransformationToPlane_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/applyProjectiveTransformationToPlane.mjs */ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs");
/* harmony import */ var _utils_compute2DProjections_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/compute2DProjections.mjs */ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs");




"use strict";
class PerspectivePlaneGeometry extends _mesh_plane_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry {
  /**
   * @param options - Options to be applied to MeshPlane
   * @param options.width - The width of the plane
   * @param options.height - The height of the plane
   * @param options.verticesX - The amount of vertices on the x axis
   * @param options.verticesY - The amount of vertices on the y axis
   */
  constructor(options) {
    super(options);
    this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    const { width, height } = options;
    this.corners = [0, 0, width, 0, width, height, 0, height];
  }
  /**
   * Will set the corners of the quad to the given coordinates
   * Calculating the perspective so it looks correct!
   * @param x0 - x coordinate of the first corner
   * @param y0 - y coordinate of the first corner
   * @param x1 - x coordinate of the second corner
   * @param y1 - y coordinate of the second corner
   * @param x2 - x coordinate of the third corner
   * @param y2 - y coordinate of the third corner
   * @param x3 - x coordinate of the fourth corner
   * @param y3 - y coordinate of the fourth corner
   */
  setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
    const corners = this.corners;
    corners[0] = x0;
    corners[1] = y0;
    corners[2] = x1;
    corners[3] = y1;
    corners[4] = x2;
    corners[5] = y2;
    corners[6] = x3;
    corners[7] = y3;
    this.updateProjection();
  }
  /** Update the projection matrix based on the corners */
  updateProjection() {
    const { width, height } = this;
    const corners = this.corners;
    const projectionMatrix = (0,_utils_compute2DProjections_mjs__WEBPACK_IMPORTED_MODULE_1__.compute2DProjection)(
      this._projectionMatrix,
      0,
      0,
      // top-left source
      corners[0],
      corners[1],
      // top-left dest
      width,
      0,
      // top-right source
      corners[2],
      corners[3],
      // top-right dest
      width,
      height,
      // bottom-right source
      corners[4],
      corners[5],
      // bottom-right dest
      0,
      height,
      // bottom-left source
      corners[6],
      corners[7]
      // bottom-left dest
    );
    (0,_utils_applyProjectiveTransformationToPlane_mjs__WEBPACK_IMPORTED_MODULE_2__.applyProjectiveTransformationToPlane)(
      width,
      height,
      this,
      projectionMatrix
    );
  }
}


//# sourceMappingURL=PerspectivePlaneGeometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyProjectiveTransformationToPlane: () => (/* binding */ applyProjectiveTransformationToPlane)
/* harmony export */ });

function applyProjectiveTransformationToPlane(width, height, geometry, transformationMatrix) {
  const buffer = geometry.buffers[0];
  const vertices = buffer.data;
  const { verticesX, verticesY } = geometry;
  const sizeX = width / (verticesX - 1);
  const sizeY = height / (verticesY - 1);
  let index = 0;
  const a00 = transformationMatrix[0];
  const a01 = transformationMatrix[1];
  const a02 = transformationMatrix[2];
  const a10 = transformationMatrix[3];
  const a11 = transformationMatrix[4];
  const a12 = transformationMatrix[5];
  const a20 = transformationMatrix[6];
  const a21 = transformationMatrix[7];
  const a22 = transformationMatrix[8];
  for (let i = 0; i < vertices.length; i += 2) {
    const x = index % verticesX * sizeX;
    const y = (index / verticesX | 0) * sizeY;
    const newX = a00 * x + a01 * y + a02;
    const newY = a10 * x + a11 * y + a12;
    const w = a20 * x + a21 * y + a22;
    vertices[i] = newX / w;
    vertices[i + 1] = newY / w;
    index++;
  }
  buffer.update();
}


//# sourceMappingURL=applyProjectiveTransformationToPlane.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compute2DProjection: () => (/* binding */ compute2DProjection)
/* harmony export */ });

function computeAdjugate(out, matrix) {
  const a00 = matrix[0];
  const a01 = matrix[1];
  const a02 = matrix[2];
  const a10 = matrix[3];
  const a11 = matrix[4];
  const a12 = matrix[5];
  const a20 = matrix[6];
  const a21 = matrix[7];
  const a22 = matrix[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function multiplyMatrix3x3(out, a, b) {
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[3];
  const a11 = a[4];
  const a12 = a[5];
  const a20 = a[6];
  const a21 = a[7];
  const a22 = a[8];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b10 = b[3];
  const b11 = b[4];
  const b12 = b[5];
  const b20 = b[6];
  const b21 = b[7];
  const b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyMatrixAndVector(out, m, v) {
  const x = v[0];
  const y = v[1];
  const z = v[2];
  out[0] = m[0] * x + m[1] * y + m[2] * z;
  out[1] = m[3] * x + m[4] * y + m[5] * z;
  out[2] = m[6] * x + m[7] * y + m[8] * z;
  return out;
}
const tempMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
const tempVec = [0, 0, 0];
const tempVec2 = [0, 0, 0];
function generateBasisToPointsMatrix(out, x1, y1, x2, y2, x3, y3, x4, y4) {
  const m = tempMatrix;
  m[0] = x1;
  m[1] = x2;
  m[2] = x3;
  m[3] = y1;
  m[4] = y2;
  m[5] = y3;
  m[6] = 1;
  m[7] = 1;
  m[8] = 1;
  const adjugateM = computeAdjugate(
    out,
    // reusing out as adjugateM is only used once
    m
  );
  tempVec2[0] = x4;
  tempVec2[1] = y4;
  tempVec2[2] = 1;
  const v = multiplyMatrixAndVector(
    tempVec,
    adjugateM,
    tempVec2
  );
  const diagonalMatrix = out;
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = v[2];
  return multiplyMatrix3x3(out, diagonalMatrix, m);
}
const tempSourceMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
const tempDestinationMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
function compute2DProjection(out, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
  const sourceMatrix = generateBasisToPointsMatrix(
    tempSourceMatrix,
    x1s,
    y1s,
    x2s,
    y2s,
    x3s,
    y3s,
    x4s,
    y4s
  );
  const destinationMatrix = generateBasisToPointsMatrix(
    tempDestinationMatrix,
    x1d,
    y1d,
    x2d,
    y2d,
    x3d,
    y3d,
    x4d,
    y4d
  );
  return multiplyMatrix3x3(
    out,
    computeAdjugate(sourceMatrix, sourceMatrix),
    destinationMatrix
  );
}


//# sourceMappingURL=compute2DProjections.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshPlane: () => (/* binding */ MeshPlane)
/* harmony export */ });
/* harmony import */ var _container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/utils/definedProps.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs");
/* harmony import */ var _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/shared/Mesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs");
/* harmony import */ var _PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PlaneGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs");




"use strict";
class MeshPlane extends _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__.Mesh {
  /**
   * @param options - Options to be applied to MeshPlane
   */
  constructor(options) {
    const { texture, verticesX, verticesY, ...rest } = options;
    const planeGeometry = new _PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__.PlaneGeometry((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({
      width: texture.width,
      height: texture.height,
      verticesX,
      verticesY
    }));
    super((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({ ...rest, geometry: planeGeometry, texture }));
    this.texture = texture;
    this.autoResize = true;
  }
  /**
   * Method used for overrides, to do something in case texture frame was changed.
   * Meshes based on plane can override it and change more details based on texture.
   */
  textureUpdated() {
    const geometry = this.geometry;
    const { width, height } = this.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = width;
      geometry.height = height;
      geometry.build({});
    }
  }
  set texture(value) {
    this._texture?.off("update", this.textureUpdated, this);
    super.texture = value;
    value.on("update", this.textureUpdated, this);
    this.textureUpdated();
  }
  /** The texture of the MeshPlane */
  get texture() {
    return this._texture;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options) {
    this.texture.off("update", this.textureUpdated, this);
    super.destroy(options);
  }
}


//# sourceMappingURL=MeshPlane.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PlaneGeometry: () => (/* binding */ PlaneGeometry)
/* harmony export */ });
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/shared/MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");



"use strict";
const _PlaneGeometry = class _PlaneGeometry extends _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry {
  constructor(...args) {
    super({});
    let options = args[0] ?? {};
    if (typeof options === "number") {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
      options = {
        width: options,
        height: args[1],
        verticesX: args[2],
        verticesY: args[3]
      };
    }
    this.build(options);
  }
  /**
   * Refreshes plane coordinates
   * @param options - Options to be applied to plane geometry
   */
  build(options) {
    options = { ..._PlaneGeometry.defaultOptions, ...options };
    this.verticesX = this.verticesX ?? options.verticesX;
    this.verticesY = this.verticesY ?? options.verticesY;
    this.width = this.width ?? options.width;
    this.height = this.height ?? options.height;
    const total = this.verticesX * this.verticesY;
    const verts = [];
    const uvs = [];
    const indices = [];
    const verticesX = this.verticesX - 1;
    const verticesY = this.verticesY - 1;
    const sizeX = this.width / verticesX;
    const sizeY = this.height / verticesY;
    for (let i = 0; i < total; i++) {
      const x = i % this.verticesX;
      const y = i / this.verticesX | 0;
      verts.push(x * sizeX, y * sizeY);
      uvs.push(x / verticesX, y / verticesY);
    }
    const totalSub = verticesX * verticesY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % verticesX;
      const ypos = i / verticesX | 0;
      const value = ypos * this.verticesX + xpos;
      const value2 = ypos * this.verticesX + xpos + 1;
      const value3 = (ypos + 1) * this.verticesX + xpos;
      const value4 = (ypos + 1) * this.verticesX + xpos + 1;
      indices.push(
        value,
        value2,
        value3,
        value2,
        value4,
        value3
      );
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint32Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
};
_PlaneGeometry.defaultOptions = {
  width: 100,
  height: 100,
  verticesX: 10,
  verticesY: 10
};
let PlaneGeometry = _PlaneGeometry;


//# sourceMappingURL=PlaneGeometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshRope: () => (/* binding */ MeshRope)
/* harmony export */ });
/* harmony import */ var _container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/utils/definedProps.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs");
/* harmony import */ var _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/shared/Mesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs");
/* harmony import */ var _RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RopeGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs");




"use strict";
const _MeshRope = class _MeshRope extends _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__.Mesh {
  /**
   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
   * @param options
   * @param options.texture - The texture to use on the rope.
   * @param options.points - An array of {@link math.Point} objects to construct this rope.
   * @param {number} options.textureScale - Optional. Positive values scale rope texture
   * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
   * and downsampling here. If set to zero, texture will be stretched instead.
   */
  constructor(options) {
    const { texture, points, textureScale, ...rest } = { ..._MeshRope.defaultOptions, ...options };
    const ropeGeometry = new _RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__.RopeGeometry((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({ width: texture.height, points, textureScale }));
    if (textureScale > 0) {
      texture.source.style.addressMode = "repeat";
    }
    super((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({
      ...rest,
      texture,
      geometry: ropeGeometry
    }));
    this.autoUpdate = true;
    this.onRender = this._render;
  }
  _render() {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.texture.height) {
      geometry._width = this.texture.height;
      geometry.update();
    }
  }
};
_MeshRope.defaultOptions = {
  textureScale: 0
};
let MeshRope = _MeshRope;


//# sourceMappingURL=MeshRope.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshSimple: () => (/* binding */ MeshSimple)
/* harmony export */ });
/* harmony import */ var _container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/utils/definedProps.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs");
/* harmony import */ var _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/shared/Mesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs");
/* harmony import */ var _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh/shared/MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");




"use strict";
class MeshSimple extends _mesh_shared_Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__.Mesh {
  /**
   * @param options - Options to be used for construction
   */
  constructor(options) {
    const { texture, vertices, uvs, indices, topology, ...rest } = options;
    const geometry = new _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__.MeshGeometry((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({
      positions: vertices,
      uvs,
      indices,
      topology
    }));
    super((0,_container_utils_definedProps_mjs__WEBPACK_IMPORTED_MODULE_2__.definedProps)({
      ...rest,
      texture,
      geometry
    }));
    this.autoUpdate = true;
    this.onRender = this._render;
  }
  /**
   * Collection of vertices data.
   * @type {Float32Array}
   */
  get vertices() {
    return this.geometry.getBuffer("aPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aPosition").data = value;
  }
  _render() {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aPosition").update();
    }
  }
}


//# sourceMappingURL=MeshSimple.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RopeGeometry: () => (/* binding */ RopeGeometry)
/* harmony export */ });
/* harmony import */ var _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/shared/MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");


"use strict";
const _RopeGeometry = class _RopeGeometry extends _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry {
  /**
   * @param options - Options to be applied to rope geometry
   */
  constructor(options) {
    const { width, points, textureScale } = { ..._RopeGeometry.defaultOptions, ...options };
    super({
      positions: new Float32Array(points.length * 4),
      uvs: new Float32Array(points.length * 4),
      indices: new Uint32Array((points.length - 1) * 6)
    });
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this._build();
  }
  /**
   * The width (i.e., thickness) of the rope.
   * @readonly
   */
  get width() {
    return this._width;
  }
  /** Refreshes Rope indices and uvs */
  _build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aPosition");
    const uvBuffer = this.getBuffer("aUV");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i = 0; i < total; i++) {
      const index = i * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i].x;
        const dy = prev.y - points[i].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    let indexCount = 0;
    for (let i = 0; i < total - 1; i++) {
      const index = i * 2;
      indices[indexCount++] = index;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  /** refreshes vertices of Rope mesh */
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i = 0; i < total; i++) {
      const point = points[i];
      const index = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      let ratio = (1 - i / (total - 1)) * 10;
      if (ratio > 1) {
        ratio = 1;
      }
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  /** Refreshes Rope indices and uvs */
  update() {
    if (this.textureScale > 0) {
      this._build();
    } else {
      this.updateVertices();
    }
  }
};
/** Default options for RopeGeometry constructor. */
_RopeGeometry.defaultOptions = {
  /** The width (i.e., thickness) of the rope. */
  width: 200,
  /** An array of points that determine the rope. */
  points: [],
  /** Rope texture scale, if zero then the rope texture is stretched. */
  textureScale: 0
};
let RopeGeometry = _RopeGeometry;


//# sourceMappingURL=RopeGeometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlMeshAdaptor: () => (/* binding */ GlMeshAdaptor)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_textureBit_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/textureBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");










"use strict";
class GlMeshAdaptor {
  init() {
    const glProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_0__.compileHighShaderGlProgram)({
      name: "mesh",
      bits: [
        _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_1__.localUniformBitGl,
        _rendering_high_shader_shader_bits_textureBit_mjs__WEBPACK_IMPORTED_MODULE_2__.textureBitGl,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_3__.roundPixelsBitGl
      ]
    });
    this._shader = new _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_4__.Shader({
      glProgram,
      resources: {
        uTexture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__.Texture.EMPTY.source,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__.Matrix() }
        }
      }
    });
  }
  execute(meshPipe, mesh) {
    const renderer = meshPipe.renderer;
    let shader = mesh._shader;
    if (!shader) {
      shader = this._shader;
      const texture = mesh.texture;
      const source = texture.source;
      shader.resources.uTexture = source;
      shader.resources.uSampler = source.style;
      shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
    } else if (!shader.glProgram) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_7__.warn)("Mesh shader has no glProgram", mesh.shader);
      return;
    }
    shader.groups[100] = renderer.globalUniforms.bindGroup;
    shader.groups[101] = meshPipe.localUniformsBindGroup;
    renderer.encoder.draw({
      geometry: mesh._geometry,
      shader,
      state: mesh.state
    });
  }
  destroy() {
    this._shader.destroy(true);
    this._shader = null;
  }
}
GlMeshAdaptor.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_8__.ExtensionType.WebGLPipesAdaptor
  ],
  name: "mesh"
};


//# sourceMappingURL=GlMeshAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuMeshAdapter: () => (/* binding */ GpuMeshAdapter)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_textureBit_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/textureBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");










"use strict";
class GpuMeshAdapter {
  init() {
    const gpuProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_0__.compileHighShaderGpuProgram)({
      name: "mesh",
      bits: [
        _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_1__.localUniformBit,
        _rendering_high_shader_shader_bits_textureBit_mjs__WEBPACK_IMPORTED_MODULE_2__.textureBit,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_3__.roundPixelsBit
      ]
    });
    this._shader = new _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_4__.Shader({
      gpuProgram,
      resources: {
        uTexture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__.Texture.EMPTY._source,
        uSampler: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__.Texture.EMPTY._source.style,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__.Matrix() }
        }
      }
    });
  }
  execute(meshPipe, mesh) {
    const renderer = meshPipe.renderer;
    let shader = mesh._shader;
    if (!shader) {
      shader = this._shader;
      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
    } else if (!shader.gpuProgram) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_7__.warn)("Mesh shader has no gpuProgram", mesh.shader);
      return;
    }
    const gpuProgram = shader.gpuProgram;
    if (gpuProgram.autoAssignGlobalUniforms) {
      shader.groups[0] = renderer.globalUniforms.bindGroup;
    }
    if (gpuProgram.autoAssignLocalUniforms) {
      const localUniforms = meshPipe.localUniforms;
      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
    }
    renderer.encoder.draw({
      geometry: mesh._geometry,
      shader,
      state: mesh.state
    });
  }
  destroy() {
    this._shader.destroy(true);
    this._shader = null;
  }
}
/** @ignore */
GpuMeshAdapter.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_8__.ExtensionType.WebGPUPipesAdaptor
  ],
  name: "mesh"
};


//# sourceMappingURL=GpuMeshAdapter.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BatchableMesh: () => (/* binding */ BatchableMesh)
/* harmony export */ });

class BatchableMesh {
  constructor() {
    this.batcherName = "default";
    this.packAsQuad = false;
    this.indexOffset = 0;
    this.attributeOffset = 0;
    this.roundPixels = 0;
    this._batcher = null;
    this._batch = null;
    this._textureMatrixUpdateId = -1;
    this._uvUpdateId = -1;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get topology() {
    return this._topology || this.geometry.topology;
  }
  set topology(value) {
    this._topology = value;
  }
  reset() {
    this.renderable = null;
    this.texture = null;
    this._batcher = null;
    this._batch = null;
    this.geometry = null;
    this._uvUpdateId = -1;
    this._textureMatrixUpdateId = -1;
  }
  /**
   * Sets the texture for the batchable mesh.
   * As it does so, it resets the texture matrix update ID.
   * this is to ensure that the texture matrix is recalculated when the uvs are referenced
   * @param value - The texture to set.
   */
  setTexture(value) {
    if (this.texture === value)
      return;
    this.texture = value;
    this._textureMatrixUpdateId = -1;
  }
  get uvs() {
    const geometry = this.geometry;
    const uvBuffer = geometry.getBuffer("aUV");
    const uvs = uvBuffer.data;
    let transformedUvs = uvs;
    const textureMatrix = this.texture.textureMatrix;
    if (!textureMatrix.isSimple) {
      transformedUvs = this._transformedUvs;
      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
        if (!transformedUvs || transformedUvs.length < uvs.length) {
          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
        }
        this._textureMatrixUpdateId = textureMatrix._updateID;
        this._uvUpdateId = uvBuffer._updateID;
        textureMatrix.multiplyUvs(uvs, transformedUvs);
      }
    }
    return transformedUvs;
  }
  get positions() {
    return this.geometry.positions;
  }
  get indices() {
    return this.geometry.indices;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  get groupTransform() {
    return this.renderable.groupTransform;
  }
  get attributeSize() {
    return this.geometry.positions.length / 2;
  }
  get indexSize() {
    return this.geometry.indices.length;
  }
}


//# sourceMappingURL=BatchableMesh.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mesh: () => (/* binding */ Mesh)
/* harmony export */ });
/* harmony import */ var _maths_point_pointInTriangle_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../maths/point/pointInTriangle.mjs */ "./node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/Geometry.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs");
/* harmony import */ var _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");
/* harmony import */ var _MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");








"use strict";
class Mesh extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  constructor(...args) {
    let options = args[0];
    if (options instanceof _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_1__.Geometry) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Mesh: use new Mesh({ geometry, shader }) instead");
      options = {
        geometry: options,
        shader: args[1]
      };
      if (args[3]) {
        (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "Mesh: drawMode argument has been removed, use geometry.topology instead");
        options.geometry.topology = args[3];
      }
    }
    const { geometry, shader, texture, roundPixels, state, ...rest } = options;
    super({
      label: "Mesh",
      ...rest
    });
    this.renderPipeId = "mesh";
    /** @ignore */
    this._shader = null;
    this.allowChildren = false;
    this.shader = shader ?? null;
    this.texture = texture ?? shader?.texture ?? _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture.WHITE;
    this.state = state ?? _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_4__.State.for2d();
    this._geometry = geometry;
    this._geometry.on("update", this.onViewUpdate, this);
    this.roundPixels = roundPixels ?? false;
  }
  /** Alias for {@link scene.Mesh#shader}. */
  get material() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "mesh.material property has been removed, use mesh.shader instead");
    return this._shader;
  }
  /**
   * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
   * Can be shared between multiple Mesh objects.
   */
  set shader(value) {
    if (this._shader === value)
      return;
    this._shader = value;
    this.onViewUpdate();
  }
  get shader() {
    return this._shader;
  }
  /**
   * Includes vertex positions, face indices, colors, UVs, and
   * custom attributes within buffers, reducing the cost of passing all
   * this data to the GPU. Can be shared between multiple Mesh objects.
   */
  set geometry(value) {
    if (this._geometry === value)
      return;
    this._geometry?.off("update", this.onViewUpdate, this);
    value.on("update", this.onViewUpdate, this);
    this._geometry = value;
    this.onViewUpdate();
  }
  get geometry() {
    return this._geometry;
  }
  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
  set texture(value) {
    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_3__.Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value)
      return;
    if (currentTexture && currentTexture.dynamic)
      currentTexture.off("update", this.onViewUpdate, this);
    if (value.dynamic)
      value.on("update", this.onViewUpdate, this);
    if (this.shader) {
      this.shader.texture = value;
    }
    this._texture = value;
    this.onViewUpdate();
  }
  get texture() {
    return this._texture;
  }
  get batched() {
    if (this._shader)
      return false;
    if ((this.state.data & 12) !== 0)
      return false;
    if (this._geometry instanceof _MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_5__.MeshGeometry) {
      if (this._geometry.batchMode === "auto") {
        return this._geometry.positions.length / 2 <= 100;
      }
      return this._geometry.batchMode === "batch";
    }
    return false;
  }
  /**
   * The local bounds of the mesh.
   * @type {rendering.Bounds}
   */
  get bounds() {
    return this._geometry.bounds;
  }
  /**
   * Update local bounds of the mesh.
   * @private
   */
  updateBounds() {
    this._bounds = this._geometry.bounds;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(point) {
    const { x, y } = point;
    if (!this.bounds.containsPoint(x, y))
      return false;
    const vertices = this.geometry.getBuffer("aPosition").data;
    const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
    if (this.geometry.getIndex()) {
      const indices = this.geometry.getIndex().data;
      const len = indices.length;
      for (let i = 0; i + 2 < len; i += step) {
        const ind0 = indices[i] * 2;
        const ind1 = indices[i + 1] * 2;
        const ind2 = indices[i + 2] * 2;
        if ((0,_maths_point_pointInTriangle_mjs__WEBPACK_IMPORTED_MODULE_6__.pointInTriangle)(
          x,
          y,
          vertices[ind0],
          vertices[ind0 + 1],
          vertices[ind1],
          vertices[ind1 + 1],
          vertices[ind2],
          vertices[ind2 + 1]
        )) {
          return true;
        }
      }
    } else {
      const len = vertices.length / 2;
      for (let i = 0; i + 2 < len; i += step) {
        const ind0 = i * 2;
        const ind1 = (i + 1) * 2;
        const ind2 = (i + 2) * 2;
        if ((0,_maths_point_pointInTriangle_mjs__WEBPACK_IMPORTED_MODULE_6__.pointInTriangle)(
          x,
          y,
          vertices[ind0],
          vertices[ind0 + 1],
          vertices[ind1],
          vertices[ind1 + 1],
          vertices[ind2],
          vertices[ind2 + 1]
        )) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options) {
    super.destroy(options);
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._geometry?.off("update", this.onViewUpdate, this);
    this._texture = null;
    this._geometry = null;
    this._shader = null;
  }
}


//# sourceMappingURL=Mesh.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshGeometry: () => (/* binding */ MeshGeometry)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/Geometry.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");





"use strict";
const _MeshGeometry = class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__.Geometry {
  constructor(...args) {
    let options = args[0] ?? {};
    if (options instanceof Float32Array) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
      options = {
        positions: options,
        uvs: args[1],
        indices: args[2]
      };
    }
    options = { ..._MeshGeometry.defaultOptions, ...options };
    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    let uvs = options.uvs;
    if (!uvs) {
      if (options.positions) {
        uvs = new Float32Array(positions.length);
      } else {
        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      }
    }
    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
    const shrinkToFit = options.shrinkBuffersToFit;
    const positionBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__.Buffer({
      data: positions,
      label: "attribute-mesh-positions",
      shrinkToFit,
      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.BufferUsage.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.BufferUsage.COPY_DST
    });
    const uvBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__.Buffer({
      data: uvs,
      label: "attribute-mesh-uvs",
      shrinkToFit,
      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.BufferUsage.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.BufferUsage.COPY_DST
    });
    const indexBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__.Buffer({
      data: indices,
      label: "index-mesh-buffer",
      shrinkToFit,
      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.BufferUsage.INDEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__.BufferUsage.COPY_DST
    });
    super({
      attributes: {
        aPosition: {
          buffer: positionBuffer,
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        },
        aUV: {
          buffer: uvBuffer,
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer,
      topology: options.topology
    });
    this.batchMode = "auto";
  }
  /** The positions of the mesh. */
  get positions() {
    return this.attributes.aPosition.buffer.data;
  }
  /**
   * Set the positions of the mesh.
   * When setting the positions, its important that the uvs array is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The positions of the mesh.
   */
  set positions(value) {
    this.attributes.aPosition.buffer.data = value;
  }
  /** The UVs of the mesh. */
  get uvs() {
    return this.attributes.aUV.buffer.data;
  }
  /**
   * Set the UVs of the mesh.
   * Its important that the uvs array you set is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The UVs of the mesh.
   */
  set uvs(value) {
    this.attributes.aUV.buffer.data = value;
  }
  /** The indices of the mesh. */
  get indices() {
    return this.indexBuffer.data;
  }
  set indices(value) {
    this.indexBuffer.data = value;
  }
};
_MeshGeometry.defaultOptions = {
  topology: "triangle-list",
  shrinkBuffersToFit: false
};
let MeshGeometry = _MeshGeometry;


//# sourceMappingURL=MeshGeometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MeshPipe: () => (/* binding */ MeshPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/renderers/gpu/shader/BindGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../graphics/gpu/colorToUniform.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs");
/* harmony import */ var _BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BatchableMesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs");









"use strict";
class MeshPipe {
  constructor(renderer, adaptor) {
    this.localUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.UniformGroup({
      uTransformMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_1__.Matrix(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    this.localUniformsBindGroup = new _rendering_renderers_gpu_shader_BindGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.BindGroup({
      0: this.localUniforms
    });
    this._meshDataHash = /* @__PURE__ */ Object.create(null);
    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this.renderer = renderer;
    this._adaptor = adaptor;
    this._adaptor.init();
    renderer.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash");
    renderer.renderableGC.addManagedHash(this, "_meshDataHash");
  }
  validateRenderable(mesh) {
    const meshData = this._getMeshData(mesh);
    const wasBatched = meshData.batched;
    const isBatched = mesh.batched;
    meshData.batched = isBatched;
    if (wasBatched !== isBatched) {
      return true;
    } else if (isBatched) {
      const geometry = mesh._geometry;
      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
        meshData.indexSize = geometry.indices.length;
        meshData.vertexSize = geometry.positions.length;
        return true;
      }
      const batchableMesh = this._getBatchableMesh(mesh);
      if (batchableMesh.texture.uid !== mesh._texture.uid) {
        batchableMesh._textureMatrixUpdateId = -1;
      }
      return !batchableMesh._batcher.checkAndUpdateTexture(
        batchableMesh,
        mesh._texture
      );
    }
    return false;
  }
  addRenderable(mesh, instructionSet) {
    const batcher = this.renderer.renderPipes.batch;
    const { batched } = this._getMeshData(mesh);
    if (batched) {
      const gpuBatchableMesh = this._getBatchableMesh(mesh);
      gpuBatchableMesh.setTexture(mesh._texture);
      gpuBatchableMesh.geometry = mesh._geometry;
      batcher.addToBatch(gpuBatchableMesh, instructionSet);
    } else {
      batcher.break(instructionSet);
      instructionSet.add(mesh);
    }
  }
  updateRenderable(mesh) {
    if (mesh.batched) {
      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
      gpuBatchableMesh.setTexture(mesh._texture);
      gpuBatchableMesh.geometry = mesh._geometry;
      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
    }
  }
  destroyRenderable(mesh) {
    this._meshDataHash[mesh.uid] = null;
    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
    if (gpuMesh) {
      _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.BigPool.return(gpuMesh);
      this._gpuBatchableMeshHash[mesh.uid] = null;
    }
    mesh.off("destroyed", this._destroyRenderableBound);
  }
  execute(mesh) {
    if (!mesh.isRenderable)
      return;
    mesh.state.blendMode = (0,_rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_4__.getAdjustedBlendModeBlend)(mesh.groupBlendMode, mesh.texture._source);
    const localUniforms = this.localUniforms;
    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
    localUniforms.update();
    (0,_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_5__.color32BitToUniform)(
      mesh.groupColorAlpha,
      localUniforms.uniforms.uColor,
      0
    );
    this._adaptor.execute(this, mesh);
  }
  _getMeshData(mesh) {
    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
  }
  _initMeshData(mesh) {
    this._meshDataHash[mesh.uid] = {
      batched: mesh.batched,
      indexSize: mesh._geometry.indices?.length,
      vertexSize: mesh._geometry.positions?.length
    };
    mesh.on("destroyed", this._destroyRenderableBound);
    return this._meshDataHash[mesh.uid];
  }
  _getBatchableMesh(mesh) {
    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
  }
  _initBatchableMesh(mesh) {
    const gpuMesh = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.BigPool.get(_BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_6__.BatchableMesh);
    gpuMesh.renderable = mesh;
    gpuMesh.setTexture(mesh._texture);
    gpuMesh.transform = mesh.groupTransform;
    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
    return gpuMesh;
  }
  destroy() {
    for (const i in this._gpuBatchableMeshHash) {
      if (this._gpuBatchableMeshHash[i]) {
        _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.BigPool.return(this._gpuBatchableMeshHash[i]);
      }
    }
    this._gpuBatchableMeshHash = null;
    this._meshDataHash = null;
    this.localUniforms = null;
    this.localUniformsBindGroup = null;
    this._adaptor.destroy();
    this._adaptor = null;
    this.renderer = null;
  }
}
/** @ignore */
MeshPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_7__.ExtensionType.CanvasPipes
  ],
  name: "mesh"
};


//# sourceMappingURL=MeshPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTextureDefaultMatrix: () => (/* binding */ getTextureDefaultMatrix)
/* harmony export */ });

function getTextureDefaultMatrix(texture, out) {
  const { width, height } = texture.frame;
  out.scale(1 / width, 1 / height);
  return out;
}


//# sourceMappingURL=getTextureDefaultMatrix.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlParticleContainerAdaptor: () => (/* binding */ GlParticleContainerAdaptor)
/* harmony export */ });

class GlParticleContainerAdaptor {
  execute(particleContainerPipe, container) {
    const state = particleContainerPipe.state;
    const renderer = particleContainerPipe.renderer;
    const shader = container.shader || particleContainerPipe.defaultShader;
    shader.resources.uTexture = container.texture._source;
    shader.resources.uniforms = particleContainerPipe.localUniforms;
    const gl = renderer.gl;
    const buffer = particleContainerPipe.getBuffers(container);
    renderer.shader.bind(shader);
    renderer.state.set(state);
    renderer.geometry.bind(buffer.geometry, shader.glProgram);
    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
  }
}


//# sourceMappingURL=GlParticleContainerAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuParticleContainerAdaptor: () => (/* binding */ GpuParticleContainerAdaptor)
/* harmony export */ });

class GpuParticleContainerAdaptor {
  execute(particleContainerPipe, container) {
    const renderer = particleContainerPipe.renderer;
    const shader = container.shader || particleContainerPipe.defaultShader;
    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);
    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
    const state = particleContainerPipe.state;
    const buffer = particleContainerPipe.getBuffers(container);
    renderer.encoder.draw({
      geometry: buffer.geometry,
      shader: container.shader || particleContainerPipe.defaultShader,
      state,
      size: container.particleChildren.length * 6
    });
  }
}


//# sourceMappingURL=GpuParticleContainerAdaptor.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlParticleContainerPipe: () => (/* binding */ GlParticleContainerPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _gl_GlParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gl/GlParticleContainerAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs");
/* harmony import */ var _ParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParticleContainerPipe.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs");




"use strict";
class GlParticleContainerPipe extends _ParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_0__.ParticleContainerPipe {
  constructor(renderer) {
    super(renderer, new _gl_GlParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__.GlParticleContainerAdaptor());
  }
}
/** @ignore */
GlParticleContainerPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLPipes
  ],
  name: "particle"
};


//# sourceMappingURL=GlParticleContainerPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GpuParticleContainerPipe: () => (/* binding */ GpuParticleContainerPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _gpu_GpuParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gpu/GpuParticleContainerAdaptor.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs");
/* harmony import */ var _ParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParticleContainerPipe.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs");




"use strict";
class GpuParticleContainerPipe extends _ParticleContainerPipe_mjs__WEBPACK_IMPORTED_MODULE_0__.ParticleContainerPipe {
  constructor(renderer) {
    super(renderer, new _gpu_GpuParticleContainerAdaptor_mjs__WEBPACK_IMPORTED_MODULE_1__.GpuParticleContainerAdaptor());
  }
}
/** @ignore */
GpuParticleContainerPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUPipes
  ],
  name: "particle"
};


//# sourceMappingURL=GpuParticleContainerPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Particle: () => (/* binding */ Particle)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _container_container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../container/container-mixins/getGlobalMixin.mjs */ "./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs");
/* harmony import */ var _container_utils_assignWithIgnore_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../container/utils/assignWithIgnore.mjs */ "./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs");





"use strict";
const _Particle = class _Particle {
  constructor(options) {
    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture) {
      this.texture = options;
      (0,_container_utils_assignWithIgnore_mjs__WEBPACK_IMPORTED_MODULE_1__.assignWithIgnore)(this, _Particle.defaultOptions, {});
    } else {
      const combined = { ..._Particle.defaultOptions, ...options };
      (0,_container_utils_assignWithIgnore_mjs__WEBPACK_IMPORTED_MODULE_1__.assignWithIgnore)(this, combined, {});
    }
  }
  /** Gets or sets the alpha value of the particle. */
  get alpha() {
    return this._alpha;
  }
  set alpha(value) {
    this._alpha = Math.min(Math.max(value, 0), 1);
    this._updateColor();
  }
  /** Gets or sets the tint color of the particle. */
  get tint() {
    return (0,_container_container_mixins_getGlobalMixin_mjs__WEBPACK_IMPORTED_MODULE_2__.bgr2rgb)(this._tint);
  }
  set tint(value) {
    if (typeof value === "number") {
      this._tint = value;
    } else {
      this._tint = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_3__.Color.shared.setValue(value ?? 16777215).toBgrNumber();
    }
    this._updateColor();
  }
  _updateColor() {
    this.color = this._tint + ((this._alpha * 255 | 0) << 24);
  }
};
/** Default options for constructing with options */
_Particle.defaultOptions = {
  anchorX: 0,
  anchorY: 0,
  x: 0,
  y: 0,
  scaleX: 1,
  scaleY: 1,
  rotation: 0,
  tint: 16777215,
  alpha: 1
};
let Particle = _Particle;


//# sourceMappingURL=Particle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParticleBuffer: () => (/* binding */ ParticleBuffer)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/Buffer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs");
/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/renderers/shared/buffer/const.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/Geometry.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs");
/* harmony import */ var _rendering_renderers_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");
/* harmony import */ var _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/data/ViewableBuffer.mjs */ "./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs");
/* harmony import */ var _utils_createIndicesForQuads_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/createIndicesForQuads.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs");
/* harmony import */ var _utils_generateParticleUpdateFunction_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/generateParticleUpdateFunction.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs");








"use strict";
class ParticleBuffer {
  constructor(options) {
    this._size = 0;
    this._generateParticleUpdateCache = {};
    const size = this._size = options.size ?? 1e3;
    const properties = options.properties;
    let staticVertexSize = 0;
    let dynamicVertexSize = 0;
    for (const i in properties) {
      const property = properties[i];
      const attributeInfo = (0,_rendering_renderers_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_0__.getAttributeInfoFromFormat)(property.format);
      if (property.dynamic) {
        dynamicVertexSize += attributeInfo.stride;
      } else {
        staticVertexSize += attributeInfo.stride;
      }
    }
    this._dynamicStride = dynamicVertexSize / 4;
    this._staticStride = staticVertexSize / 4;
    this.staticAttributeBuffer = new _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__.ViewableBuffer(size * 4 * staticVertexSize);
    this.dynamicAttributeBuffer = new _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__.ViewableBuffer(size * 4 * dynamicVertexSize);
    this.indexBuffer = (0,_utils_createIndicesForQuads_mjs__WEBPACK_IMPORTED_MODULE_2__.createIndicesForQuads)(size);
    const geometry = new _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_3__.Geometry();
    let dynamicOffset = 0;
    let staticOffset = 0;
    this._staticBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer({
      data: new Float32Array(1),
      label: "static-particle-buffer",
      shrinkToFit: false,
      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_5__.BufferUsage.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_5__.BufferUsage.COPY_DST
    });
    this._dynamicBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer({
      data: new Float32Array(1),
      label: "dynamic-particle-buffer",
      shrinkToFit: false,
      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_5__.BufferUsage.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_5__.BufferUsage.COPY_DST
    });
    for (const i in properties) {
      const property = properties[i];
      const attributeInfo = (0,_rendering_renderers_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_0__.getAttributeInfoFromFormat)(property.format);
      if (property.dynamic) {
        geometry.addAttribute(property.attributeName, {
          buffer: this._dynamicBuffer,
          stride: this._dynamicStride * 4,
          offset: dynamicOffset * 4,
          format: property.format
        });
        dynamicOffset += attributeInfo.size;
      } else {
        geometry.addAttribute(property.attributeName, {
          buffer: this._staticBuffer,
          stride: this._staticStride * 4,
          offset: staticOffset * 4,
          format: property.format
        });
        staticOffset += attributeInfo.size;
      }
    }
    geometry.addIndex(this.indexBuffer);
    const uploadFunction = this.getParticleUpdate(properties);
    this._dynamicUpload = uploadFunction.dynamicUpdate;
    this._staticUpload = uploadFunction.staticUpdate;
    this.geometry = geometry;
  }
  getParticleUpdate(properties) {
    const key = getParticleSyncKey(properties);
    if (this._generateParticleUpdateCache[key]) {
      return this._generateParticleUpdateCache[key];
    }
    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
    return this._generateParticleUpdateCache[key];
  }
  generateParticleUpdate(properties) {
    return (0,_utils_generateParticleUpdateFunction_mjs__WEBPACK_IMPORTED_MODULE_6__.generateParticleUpdateFunction)(properties);
  }
  update(particles, uploadStatic) {
    if (particles.length > this._size) {
      uploadStatic = true;
      this._size = Math.max(particles.length, this._size * 1.5 | 0);
      this.staticAttributeBuffer = new _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__.ViewableBuffer(this._size * this._staticStride * 4 * 4);
      this.dynamicAttributeBuffer = new _utils_data_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__.ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
      this.indexBuffer = (0,_utils_createIndicesForQuads_mjs__WEBPACK_IMPORTED_MODULE_2__.createIndicesForQuads)(this._size);
      this.geometry.indexBuffer.setDataWithSize(
        this.indexBuffer,
        this.indexBuffer.byteLength,
        true
      );
    }
    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
    this._dynamicBuffer.setDataWithSize(
      this.dynamicAttributeBuffer.float32View,
      particles.length * this._dynamicStride * 4,
      true
    );
    if (uploadStatic) {
      const staticAttributeBuffer = this.staticAttributeBuffer;
      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
      this._staticBuffer.setDataWithSize(
        staticAttributeBuffer.float32View,
        particles.length * this._staticStride * 4,
        true
      );
    }
  }
  destroy() {
    this._staticBuffer.destroy();
    this._dynamicBuffer.destroy();
    this.geometry.destroy();
  }
}
function getParticleSyncKey(properties) {
  const keyGen = [];
  for (const key in properties) {
    const property = properties[key];
    keyGen.push(key, property.code, property.dynamic ? "d" : "s");
  }
  return keyGen.join("_");
}


//# sourceMappingURL=ParticleBuffer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParticleContainer: () => (/* binding */ ParticleContainer)
/* harmony export */ });
/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");
/* harmony import */ var _particleData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./particleData.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs");




"use strict";
const emptyBounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__.Bounds(0, 0, 0, 0);
const _ParticleContainer = class _ParticleContainer extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_1__.ViewContainer {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(options = {}) {
    options = {
      ..._ParticleContainer.defaultOptions,
      ...options,
      dynamicProperties: {
        ..._ParticleContainer.defaultOptions.dynamicProperties,
        ...options?.dynamicProperties
      }
    };
    const { dynamicProperties, shader, roundPixels, texture, particles, ...rest } = options;
    super({
      label: "ParticleContainer",
      ...rest
    });
    /** The unique identifier for the render pipe of this ParticleContainer. */
    this.renderPipeId = "particle";
    this.batched = false;
    /** Indicates if the children of this ParticleContainer have changed and need to be updated. */
    this._childrenDirty = false;
    this.texture = texture || null;
    this.shader = shader;
    this._properties = {};
    for (const key in _particleData_mjs__WEBPACK_IMPORTED_MODULE_2__.particleData) {
      const property = _particleData_mjs__WEBPACK_IMPORTED_MODULE_2__.particleData[key];
      const dynamic = dynamicProperties[key];
      this._properties[key] = {
        ...property,
        dynamic
      };
    }
    this.allowChildren = true;
    this.roundPixels = roundPixels ?? false;
    this.particleChildren = particles ?? [];
  }
  /**
   * Adds one or more particles to the container.
   *
   * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`
   * @param {...IParticle} children - The Particle(s) to add to the container
   * @returns {IParticle} - The first child that was added.
   */
  addParticle(...children) {
    for (let i = 0; i < children.length; i++) {
      this.particleChildren.push(children[i]);
    }
    this.onViewUpdate();
    return children[0];
  }
  /**
   * Removes one or more particles from the container.
   * @param {...IParticle} children - The Particle(s) to remove
   * @returns {IParticle} The first child that was removed.
   */
  removeParticle(...children) {
    let didRemove = false;
    for (let i = 0; i < children.length; i++) {
      const index = this.particleChildren.indexOf(children[i]);
      if (index > -1) {
        this.particleChildren.splice(index, 1);
        didRemove = true;
      }
    }
    if (didRemove)
      this.onViewUpdate();
    return children[0];
  }
  /**
   * Updates the particle container.
   * Please call this when you modify the particleChildren array.
   * or any static properties of the particles.
   */
  update() {
    this._childrenDirty = true;
  }
  onViewUpdate() {
    this._childrenDirty = true;
    super.onViewUpdate();
  }
  /**
   * ParticleContainer does not calculated bounds as it would slow things down,
   * its up to you to set this via the boundsArea property
   */
  get bounds() {
    return emptyBounds;
  }
  /** @private */
  updateBounds() {
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options = false) {
    super.destroy(options);
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      const texture = this.texture ?? this.particleChildren[0]?.texture;
      if (texture) {
        texture.destroy(destroyTextureSource);
      }
    }
    this.texture = null;
    this.shader?.destroy();
  }
  /**
   * Removes all particles from this container that are within the begin and end indexes.
   * @param beginIndex - The beginning position.
   * @param endIndex - The ending position. Default value is size of the container.
   * @returns - List of removed particles
   */
  removeParticles(beginIndex, endIndex) {
    const children = this.particleChildren.splice(beginIndex, endIndex);
    this.onViewUpdate();
    return children;
  }
  /**
   * Removes a particle from the specified index position.
   * @param index - The index to get the particle from
   * @returns The particle that was removed.
   */
  removeParticleAt(index) {
    const child = this.particleChildren.splice(index, 1);
    this.onViewUpdate();
    return child[0];
  }
  /**
   * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.
   * If the particle is already in this container, it will be moved to the specified index.
   * @param {Container} child - The particle to add.
   * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.
   * @returns {Container} The particle that was added.
   */
  addParticleAt(child, index) {
    this.particleChildren.splice(index, 0, child);
    this.onViewUpdate();
    return child;
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   */
  addChild(..._children) {
    throw new Error(
      "ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.
   * @param {...any} _children
   * @throws {Error} Always throws an error as this method is not available.
   */
  removeChild(..._children) {
    throw new Error(
      "ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.
   * @param {number} [_beginIndex]
   * @param {number} [_endIndex]
   * @throws {Error} Always throws an error as this method is not available.
   */
  removeChildren(_beginIndex, _endIndex) {
    throw new Error(
      "ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */
  removeChildAt(_index) {
    throw new Error(
      "ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */
  getChildAt(_index) {
    throw new Error(
      "ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.
   * @param {ContainerChild} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */
  setChildIndex(_child, _index) {
    throw new Error(
      "ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.
   * @param {ContainerChild} _child
   * @throws {Error} Always throws an error as this method is not available.
   */
  getChildIndex(_child) {
    throw new Error(
      "ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.
   * @param {ContainerChild} _child
   * @param {number} _index
   * @throws {Error} Always throws an error as this method is not available.
   */
  addChildAt(_child, _index) {
    throw new Error(
      "ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.
   * @param {ContainerChild} _child
   * @param {ContainerChild} _child2
   */
  swapChildren(_child, _child2) {
    throw new Error(
      "ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()"
    );
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @throws {Error} Always throws an error as this method is not available.
   */
  reparentChild(..._child) {
    throw new Error("ParticleContainer.reparentChild() is not available with the particle container");
  }
  /**
   * This method is not available in ParticleContainer.
   *
   * Calling this method will throw an error.
   * @param _child - The child to reparent
   * @param _index - The index to reparent the child to
   * @throws {Error} Always throws an error as this method is not available.
   */
  reparentChildAt(_child, _index) {
    throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container");
  }
};
/**
 * Defines the default options for creating a ParticleContainer.
 * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.
 * @property {boolean} roundPixels - Indicates if pixels should be  rounded.
 */
_ParticleContainer.defaultOptions = {
  dynamicProperties: {
    vertex: false,
    // Indicates if vertex positions are dynamic.
    position: true,
    // Indicates if particle positions are dynamic.
    rotation: false,
    // Indicates if particle rotations are dynamic.
    uvs: false,
    // Indicates if UV coordinates are dynamic.
    color: false
    // Indicates if particle colors are dynamic.
  },
  roundPixels: false
  // Indicates if pixels should be rounded for rendering.
};
let ParticleContainer = _ParticleContainer;


//# sourceMappingURL=ParticleContainer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParticleContainerPipe: () => (/* binding */ ParticleContainerPipe)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs");
/* harmony import */ var _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../graphics/gpu/colorToUniform.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs");
/* harmony import */ var _ParticleBuffer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ParticleBuffer.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs");
/* harmony import */ var _shader_ParticleShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shader/ParticleShader.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs");








"use strict";
class ParticleContainerPipe {
  /**
   * @param renderer - The renderer this sprite batch works for.
   * @param adaptor
   */
  constructor(renderer, adaptor) {
    this.state = _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
    this._gpuBufferHash = /* @__PURE__ */ Object.create(null);
    // eslint-disable-next-line max-len
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this.localUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.UniformGroup({
      uTranslationMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array(4), type: "vec4<f32>" },
      uRound: { value: 1, type: "f32" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    });
    this.renderer = renderer;
    this.adaptor = adaptor;
    this.defaultShader = new _shader_ParticleShader_mjs__WEBPACK_IMPORTED_MODULE_3__.ParticleShader();
    this.state = _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
  }
  validateRenderable(_renderable) {
    return false;
  }
  addRenderable(renderable, instructionSet) {
    this.renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add(renderable);
  }
  getBuffers(renderable) {
    return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);
  }
  _initBuffer(renderable) {
    this._gpuBufferHash[renderable.uid] = new _ParticleBuffer_mjs__WEBPACK_IMPORTED_MODULE_4__.ParticleBuffer({
      size: renderable.particleChildren.length,
      properties: renderable._properties
    });
    renderable.on("destroyed", this._destroyRenderableBound);
    return this._gpuBufferHash[renderable.uid];
  }
  updateRenderable(_renderable) {
  }
  destroyRenderable(renderable) {
    const buffer = this._gpuBufferHash[renderable.uid];
    buffer.destroy();
    this._gpuBufferHash[renderable.uid] = null;
    renderable.off("destroyed", this._destroyRenderableBound);
  }
  execute(container) {
    const children = container.particleChildren;
    if (children.length === 0) {
      return;
    }
    const renderer = this.renderer;
    const buffer = this.getBuffers(container);
    container.texture || (container.texture = children[0].texture);
    const state = this.state;
    buffer.update(children, container._childrenDirty);
    container._childrenDirty = false;
    state.blendMode = (0,_rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_5__.getAdjustedBlendModeBlend)(container.blendMode, container.texture._source);
    const uniforms = this.localUniforms.uniforms;
    const transformationMatrix = uniforms.uTranslationMatrix;
    container.worldTransform.copyTo(transformationMatrix);
    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
    uniforms.uRound = renderer._roundPixels | container._roundPixels;
    (0,_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_6__.color32BitToUniform)(
      container.groupColorAlpha,
      uniforms.uColor,
      0
    );
    this.adaptor.execute(this, container);
  }
  /** Destroys the ParticleRenderer. */
  destroy() {
    if (this.defaultShader) {
      this.defaultShader.destroy();
      this.defaultShader = null;
    }
  }
}


//# sourceMappingURL=ParticleContainerPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   particleData: () => (/* binding */ particleData)
/* harmony export */ });

const particleData = {
  vertex: {
    attributeName: "aVertex",
    format: "float32x2",
    code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
    dynamic: false
  },
  // positionData
  position: {
    attributeName: "aPosition",
    format: "float32x2",
    code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
    dynamic: true
  },
  // rotationData
  rotation: {
    attributeName: "aRotation",
    format: "float32",
    code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
    dynamic: false
  },
  // uvsData
  uvs: {
    attributeName: "aUV",
    format: "float32x2",
    code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
    dynamic: false
  },
  // tintData
  color: {
    attributeName: "aColor",
    format: "unorm8x4",
    code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
    dynamic: false
  }
};


//# sourceMappingURL=particleData.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParticleShader: () => (/* binding */ ParticleShader)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../rendering/renderers/gl/shader/GlProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs");
/* harmony import */ var _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../rendering/renderers/gpu/shader/GpuProgram.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TextureStyle_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/TextureStyle.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs");
/* harmony import */ var _particles_frag_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./particles.frag.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs");
/* harmony import */ var _particles_vert_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./particles.vert.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs");
/* harmony import */ var _particles_wgsl_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./particles.wgsl.mjs */ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs");











"use strict";
class ParticleShader extends _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__.Shader {
  constructor() {
    const glProgram = _rendering_renderers_gl_shader_GlProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.GlProgram.from({
      vertex: _particles_vert_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
      fragment: _particles_frag_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]
    });
    const gpuProgram = _rendering_renderers_gpu_shader_GpuProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.GpuProgram.from({
      fragment: {
        source: _particles_wgsl_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
        entryPoint: "mainFragment"
      },
      vertex: {
        source: _particles_wgsl_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
        entryPoint: "mainVertex"
      }
    });
    super({
      glProgram,
      gpuProgram,
      resources: {
        // this will be replaced with the texture from the particle container
        uTexture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_6__.Texture.WHITE.source,
        // this will be replaced with the texture style from the particle container
        uSampler: new _rendering_renderers_shared_texture_TextureStyle_mjs__WEBPACK_IMPORTED_MODULE_7__.TextureStyle({}),
        // this will be replaced with the local uniforms from the particle container
        uniforms: {
          uTranslationMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_8__.Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new _color_Color_mjs__WEBPACK_IMPORTED_MODULE_9__.Color(16777215), type: "vec4<f32>" },
          uRound: { value: 1, type: "f32" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        }
      }
    });
  }
}


//# sourceMappingURL=ParticleShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fragment)
/* harmony export */ });
var fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";


//# sourceMappingURL=particles.frag.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vertex)
/* harmony export */ });
var vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n";


//# sourceMappingURL=particles.vert.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ wgsl)
/* harmony export */ });
var wgsl = "\nstruct ParticleUniforms {\n  uProjectionMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uResolution:vec2<f32>,\n  uRoundPixels:f32,\n};\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";


//# sourceMappingURL=particles.wgsl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createIndicesForQuads: () => (/* binding */ createIndicesForQuads)
/* harmony export */ });

function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  if (totalIndices > 65535) {
    outBuffer || (outBuffer = new Uint32Array(totalIndices));
  } else {
    outBuffer || (outBuffer = new Uint16Array(totalIndices));
  }
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
    outBuffer[i + 0] = j + 0;
    outBuffer[i + 1] = j + 1;
    outBuffer[i + 2] = j + 2;
    outBuffer[i + 3] = j + 0;
    outBuffer[i + 4] = j + 2;
    outBuffer[i + 5] = j + 3;
  }
  return outBuffer;
}


//# sourceMappingURL=createIndicesForQuads.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateParticleUpdateFunction: () => (/* binding */ generateParticleUpdateFunction)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs");


"use strict";
function generateParticleUpdateFunction(properties) {
  return {
    dynamicUpdate: generateUpdateFunction(properties, true),
    staticUpdate: generateUpdateFunction(properties, false)
  };
}
function generateUpdateFunction(properties, dynamic) {
  const funcFragments = [];
  funcFragments.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
  let offset = 0;
  for (const i in properties) {
    const property = properties[i];
    if (dynamic !== property.dynamic)
      continue;
    funcFragments.push(`offset = index + ${offset}`);
    funcFragments.push(property.code);
    const attributeInfo = (0,_rendering_renderers_shared_geometry_utils_getAttributeInfoFromFormat_mjs__WEBPACK_IMPORTED_MODULE_0__.getAttributeInfoFromFormat)(property.format);
    offset += attributeInfo.stride / 4;
  }
  funcFragments.push(`
            index += stride * 4;
        }
    `);
  funcFragments.unshift(`
        var stride = ${offset};
    `);
  const functionSource = funcFragments.join("\n");
  return new Function("ps", "f32v", "u32v", functionSource);
}


//# sourceMappingURL=generateParticleUpdateFunction.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimatedSprite: () => (/* binding */ AnimatedSprite)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ticker/const.mjs */ "./node_modules/pixi.js/lib/ticker/const.mjs");
/* harmony import */ var _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ticker/Ticker.mjs */ "./node_modules/pixi.js/lib/ticker/Ticker.mjs");
/* harmony import */ var _sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sprite/Sprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs");





"use strict";
class AnimatedSprite extends _sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__.Sprite {
  /** @ignore */
  constructor(...args) {
    let options = args[0];
    if (Array.isArray(args[0])) {
      options = {
        textures: args[0],
        autoUpdate: args[1]
      };
    }
    const {
      animationSpeed = 1,
      autoPlay = false,
      autoUpdate = true,
      loop = true,
      onComplete = null,
      onFrameChange = null,
      onLoop = null,
      textures,
      updateAnchor = false,
      ...rest
    } = options;
    const [firstFrame] = textures;
    super({
      ...rest,
      texture: firstFrame instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture ? firstFrame : firstFrame.texture
    });
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = animationSpeed;
    this.loop = loop;
    this.updateAnchor = updateAnchor;
    this.onComplete = onComplete;
    this.onFrameChange = onFrameChange;
    this.onLoop = onLoop;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
    if (autoPlay) {
      this.play();
    }
  }
  /** Stops the AnimatedSprite. */
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  /** Plays the AnimatedSprite. */
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker.shared.add(this.update, this, _ticker_const_mjs__WEBPACK_IMPORTED_MODULE_3__.UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  /**
   * Stops the AnimatedSprite and goes to a specific frame.
   * @param frameNumber - Frame index to stop at.
   */
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  /**
   * Goes to a specific frame and begins playing the AnimatedSprite.
   * @param frameNumber - Frame index to start at.
   */
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  /**
   * Updates the object transform for rendering.
   * @param ticker - the ticker to use to update the object.
   */
  update(ticker) {
    if (!this._playing) {
      return;
    }
    const deltaTime = ticker.deltaTime;
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign;
        this._currentTime += sign;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this._updateTexture();
    }
  }
  /** Updates the displayed texture to match the current frame index. */
  _updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this.texture = this._textures[currentFrame];
    if (this.updateAnchor && this.texture.defaultAnchor) {
      this.anchor.copyFrom(this.texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  /** Stops the AnimatedSprite and destroys it. */
  destroy() {
    this.stop();
    super.destroy();
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of frame ids.
   * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.
   * @returns - The new animated sprite with the specified frames.
   */
  static fromFrames(frames) {
    const textures = [];
    for (let i = 0; i < frames.length; ++i) {
      textures.push(_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.from(frames[i]));
    }
    return new AnimatedSprite(textures);
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of image ids.
   * @param images - The array of image urls the AnimatedSprite will use as its texture frames.
   * @returns The new animate sprite with the specified images as frames.
   */
  static fromImages(images) {
    const textures = [];
    for (let i = 0; i < images.length; ++i) {
      textures.push(_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.from(images[i]));
    }
    return new AnimatedSprite(textures);
  }
  /**
   * The total number of frames in the AnimatedSprite. This is the same as number of textures
   * assigned to the AnimatedSprite.
   * @readonly
   * @default 0
   */
  get totalFrames() {
    return this._textures.length;
  }
  /** The array of textures used for this AnimatedSprite. */
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      this._textures = value;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i = 0; i < value.length; i++) {
        this._textures.push(value[i].texture);
        this._durations.push(value[i].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this._updateTexture();
  }
  /** The AnimatedSprite's current frame index. */
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value;
    if (previousFrame !== this.currentFrame) {
      this._updateTexture();
    }
  }
  /**
   * Indicates if the AnimatedSprite is currently playing.
   * @readonly
   */
  get playing() {
    return this._playing;
  }
  /** Whether to use Ticker.shared to auto update animation time. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        _ticker_Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}


//# sourceMappingURL=AnimatedSprite.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NineSliceGeometry: () => (/* binding */ NineSliceGeometry)
/* harmony export */ });
/* harmony import */ var _mesh_plane_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh-plane/PlaneGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs");


"use strict";
const _NineSliceGeometry = class _NineSliceGeometry extends _mesh_plane_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry {
  constructor(options = {}) {
    options = { ..._NineSliceGeometry.defaultOptions, ...options };
    super({
      width: options.width,
      height: options.height,
      verticesX: 4,
      verticesY: 4
    });
    this.update(options);
  }
  /**
   * Updates the NineSliceGeometry with the options.
   * @param options - The options of the NineSliceGeometry.
   */
  update(options) {
    this.width = options.width ?? this.width;
    this.height = options.height ?? this.height;
    this._originalWidth = options.originalWidth ?? this._originalWidth;
    this._originalHeight = options.originalHeight ?? this._originalHeight;
    this._leftWidth = options.leftWidth ?? this._leftWidth;
    this._rightWidth = options.rightWidth ?? this._rightWidth;
    this._topHeight = options.topHeight ?? this._topHeight;
    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
    this._anchorX = options.anchor?.x;
    this._anchorY = options.anchor?.y;
    this.updateUvs();
    this.updatePositions();
  }
  /** Updates the positions of the vertices. */
  updatePositions() {
    const p = this.positions;
    const {
      width,
      height,
      _leftWidth,
      _rightWidth,
      _topHeight,
      _bottomHeight,
      _anchorX,
      _anchorY
    } = this;
    const w = _leftWidth + _rightWidth;
    const scaleW = width > w ? 1 : width / w;
    const h = _topHeight + _bottomHeight;
    const scaleH = height > h ? 1 : height / h;
    const scale = Math.min(scaleW, scaleH);
    const anchorOffsetX = _anchorX * width;
    const anchorOffsetY = _anchorY * height;
    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;
    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;
    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;
    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;
    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;
    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;
    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;
    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;
    this.getBuffer("aPosition").update();
  }
  /** Updates the UVs of the vertices. */
  updateUvs() {
    const uvs = this.uvs;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    const _uvw = 1 / this._originalWidth;
    const _uvh = 1 / this._originalHeight;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.getBuffer("aUV").update();
  }
};
/** The default options for the NineSliceGeometry. */
_NineSliceGeometry.defaultOptions = {
  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  width: 100,
  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  height: 100,
  /** The width of the left column. */
  leftWidth: 10,
  /** The height of the top row. */
  topHeight: 10,
  /** The width of the right column. */
  rightWidth: 10,
  /** The height of the bottom row. */
  bottomHeight: 10,
  /** The original width of the texture */
  originalWidth: 100,
  /** The original height of the texture */
  originalHeight: 100
};
let NineSliceGeometry = _NineSliceGeometry;


//# sourceMappingURL=NineSliceGeometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NineSlicePlane: () => (/* binding */ NineSlicePlane),
/* harmony export */   NineSliceSprite: () => (/* binding */ NineSliceSprite)
/* harmony export */ });
/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../maths/point/ObservablePoint.mjs */ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");
/* harmony import */ var _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NineSliceGeometry.mjs */ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs");






"use strict";
const _NineSliceSprite = class _NineSliceSprite extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  /**
   * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use
   * @param options.texture - The texture to use on the NineSliceSprite.
   * @param options.leftWidth - Width of the left vertical bar (A)
   * @param options.topHeight - Height of the top horizontal bar (C)
   * @param options.rightWidth - Width of the right vertical bar (B)
   * @param options.bottomHeight - Height of the bottom horizontal bar (D)
   * @param options.width - Width of the NineSliceSprite,
   * setting this will actually modify the vertices and not the UV's of this plane.
   * @param options.height - Height of the NineSliceSprite,
   * setting this will actually modify the vertices and not UV's of this plane.
   */
  constructor(options) {
    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      options = { texture: options };
    }
    const {
      width,
      height,
      anchor,
      leftWidth,
      rightWidth,
      topHeight,
      bottomHeight,
      texture,
      roundPixels,
      ...rest
    } = options;
    super({
      label: "NineSliceSprite",
      ...rest
    });
    this.renderPipeId = "nineSliceSprite";
    this.batched = true;
    this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSliceGeometry.defaultOptions.leftWidth;
    this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSliceGeometry.defaultOptions.topHeight;
    this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSliceGeometry.defaultOptions.rightWidth;
    this._bottomHeight = bottomHeight ?? texture?.defaultBorders?.bottom ?? _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSliceGeometry.defaultOptions.bottomHeight;
    this._width = width ?? texture.width ?? _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSliceGeometry.defaultOptions.width;
    this._height = height ?? texture.height ?? _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSliceGeometry.defaultOptions.height;
    this.allowChildren = false;
    this.texture = texture ?? _NineSliceSprite.defaultOptions.texture;
    this.roundPixels = roundPixels ?? false;
    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_3__.ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor) {
      this.anchor = anchor;
    } else if (this.texture.defaultAnchor) {
      this.anchor = this.texture.defaultAnchor;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this.onViewUpdate();
  }
  /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this.onViewUpdate();
  }
  /**
   * Sets the size of the NiceSliceSprite to the specified width and height.
   * setting this will actually modify the vertices and UV's of this plane
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(value, height) {
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    }
    this._width = value;
    this._height = height ?? value;
    this.onViewUpdate();
  }
  /**
   * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the NineSliceSprite.
   */
  getSize(out) {
    out || (out = {});
    out.width = this._width;
    out.height = this._height;
    return out;
  }
  /** The width of the left column (a) of the NineSliceSprite. */
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value;
    this.onViewUpdate();
  }
  /** The width of the right column (b) of the NineSliceSprite. */
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value;
    this.onViewUpdate();
  }
  /** The width of the right column (b) of the NineSliceSprite. */
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value;
    this.onViewUpdate();
  }
  /** The width of the right column (b) of the NineSliceSprite. */
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value;
    this.onViewUpdate();
  }
  /** The texture that the NineSliceSprite is using. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value)
      return;
    if (currentTexture && currentTexture.dynamic)
      currentTexture.off("update", this.onViewUpdate, this);
    if (value.dynamic)
      value.on("update", this.onViewUpdate, this);
    this._texture = value;
    this.onViewUpdate();
  }
  /** The original width of the texture */
  get originalWidth() {
    return this._texture.width;
  }
  /** The original height of the texture */
  get originalHeight() {
    return this._texture.height;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options) {
    super.destroy(options);
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
  }
  /**
   * @private
   */
  updateBounds() {
    const bounds = this._bounds;
    const anchor = this._anchor;
    const width = this._width;
    const height = this._height;
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
};
/** The default options, used to override the initial values of any options passed in the constructor. */
_NineSliceSprite.defaultOptions = {
  /** @default Texture.EMPTY */
  texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY
};
let NineSliceSprite = _NineSliceSprite;
class NineSlicePlane extends NineSliceSprite {
  constructor(...args) {
    let options = args[0];
    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__.v8_0_0, "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");
      options = {
        texture: options,
        leftWidth: args[1],
        topHeight: args[2],
        rightWidth: args[3],
        bottomHeight: args[4]
      };
    }
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__.v8_0_0, "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
    super(options);
  }
}


//# sourceMappingURL=NineSliceSprite.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NineSliceSpritePipe: () => (/* binding */ NineSliceSpritePipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _mesh_shared_BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh/shared/BatchableMesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs");
/* harmony import */ var _NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NineSliceGeometry.mjs */ "./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs");





"use strict";
class NineSliceSpritePipe {
  constructor(renderer) {
    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
  }
  addRenderable(sprite, instructionSet) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
  }
  updateRenderable(sprite) {
    const gpuSprite = this._gpuSpriteHash[sprite.uid];
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    gpuSprite._batcher.updateElement(gpuSprite);
  }
  validateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    return !gpuSprite._batcher.checkAndUpdateTexture(
      gpuSprite,
      sprite._texture
    );
  }
  destroyRenderable(sprite) {
    const batchableMesh = this._gpuSpriteHash[sprite.uid];
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(batchableMesh.geometry);
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(batchableMesh);
    this._gpuSpriteHash[sprite.uid] = null;
    sprite.off("destroyed", this._destroyRenderableBound);
  }
  _updateBatchableSprite(sprite, batchableSprite) {
    batchableSprite.geometry.update(sprite);
    batchableSprite.setTexture(sprite._texture);
  }
  _getGpuSprite(sprite) {
    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
  }
  _initGPUSprite(sprite) {
    const batchableMesh = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(_mesh_shared_BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_1__.BatchableMesh);
    batchableMesh.geometry = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(_NineSliceGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSliceGeometry);
    batchableMesh.renderable = sprite;
    batchableMesh.transform = sprite.groupTransform;
    batchableMesh.texture = sprite._texture;
    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
    this._gpuSpriteHash[sprite.uid] = batchableMesh;
    if (!sprite.didViewUpdate) {
      this._updateBatchableSprite(sprite, batchableMesh);
    }
    sprite.on("destroyed", this._destroyRenderableBound);
    return batchableMesh;
  }
  destroy() {
    for (const i in this._gpuSpriteHash) {
      const batchableMesh = this._gpuSpriteHash[i];
      batchableMesh.geometry.destroy();
    }
    this._gpuSpriteHash = null;
    this._renderer = null;
  }
}
/** @ignore */
NineSliceSpritePipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.CanvasPipes
  ],
  name: "nineSliceSprite"
};


//# sourceMappingURL=NineSliceSpritePipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TilingSprite: () => (/* binding */ TilingSprite)
/* harmony export */ });
/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../assets/cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../maths/point/ObservablePoint.mjs */ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_misc_Transform_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/misc/Transform.mjs */ "./node_modules/pixi.js/lib/utils/misc/Transform.mjs");
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");








"use strict";
const _TilingSprite = class _TilingSprite extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  constructor(...args) {
    let options = args[0] || {};
    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      options = { texture: options };
    }
    if (args.length > 1) {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, "use new TilingSprite({ texture, width:100, height:100 }) instead");
      options.width = args[1];
      options.height = args[2];
    }
    options = { ..._TilingSprite.defaultOptions, ...options };
    const {
      texture,
      anchor,
      tilePosition,
      tileScale,
      tileRotation,
      width,
      height,
      applyAnchorToTexture,
      roundPixels,
      ...rest
    } = options ?? {};
    super({
      label: "TilingSprite",
      ...rest
    });
    this.renderPipeId = "tilingSprite";
    this.batched = true;
    this.allowChildren = false;
    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_3__.ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    this.applyAnchorToTexture = applyAnchorToTexture;
    this.texture = texture;
    this._width = width ?? texture.width;
    this._height = height ?? texture.height;
    this._tileTransform = new _utils_misc_Transform_mjs__WEBPACK_IMPORTED_MODULE_4__.Transform({
      observer: {
        _onUpdate: () => this.onViewUpdate()
      }
    });
    if (anchor)
      this.anchor = anchor;
    this.tilePosition = tilePosition;
    this.tileScale = tileScale;
    this.tileRotation = tileRotation;
    this.roundPixels = roundPixels ?? false;
  }
  /**
   * Creates a new tiling sprite.
   * @param source - The source to create the texture from.
   * @param options - The options for creating the tiling sprite.
   * @returns A new tiling sprite.
   */
  static from(source, options = {}) {
    if (typeof source === "string") {
      return new _TilingSprite({
        texture: _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_5__.Cache.get(source),
        ...options
      });
    }
    return new _TilingSprite({
      texture: source,
      ...options
    });
  }
  /**
   * @see {@link scene.TilingSpriteOptions.applyAnchorToTexture}
   * @deprecated since 8.0.0
   */
  get uvRespectAnchor() {
    (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_6__.warn)("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
    return this.applyAnchorToTexture;
  }
  set uvRespectAnchor(value) {
    (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_6__.warn)("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
    this.applyAnchorToTexture = value;
  }
  /**
   * Changes frame clamping in corresponding textureMatrix
   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
   * @default 0.5
   * @member {number}
   */
  get clampMargin() {
    return this._texture.textureMatrix.clampMargin;
  }
  set clampMargin(value) {
    this._texture.textureMatrix.clampMargin = value;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { TilingSprite } from 'pixi.js';
   *
   * const sprite = new TilingSprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /** The offset of the image that is being tiled. */
  get tilePosition() {
    return this._tileTransform.position;
  }
  set tilePosition(value) {
    this._tileTransform.position.copyFrom(value);
  }
  /** The scaling of the image that is being tiled. */
  get tileScale() {
    return this._tileTransform.scale;
  }
  set tileScale(value) {
    typeof value === "number" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
  }
  set tileRotation(value) {
    this._tileTransform.rotation = value;
  }
  /** The rotation of the image that is being tiled. */
  get tileRotation() {
    return this._tileTransform.rotation;
  }
  /** The transform of the image that is being tiled. */
  get tileTransform() {
    return this._tileTransform;
  }
  set texture(value) {
    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value)
      return;
    if (currentTexture && currentTexture.dynamic)
      currentTexture.off("update", this.onViewUpdate, this);
    if (value.dynamic)
      value.on("update", this.onViewUpdate, this);
    this._texture = value;
    this.onViewUpdate();
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /** The width of the tiling area. */
  set width(value) {
    this._width = value;
    this.onViewUpdate();
  }
  get width() {
    return this._width;
  }
  set height(value) {
    this._height = value;
    this.onViewUpdate();
  }
  /** The height of the tiling area. */
  get height() {
    return this._height;
  }
  /**
   * Sets the size of the TilingSprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(value, height) {
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    }
    this._width = value;
    this._height = height ?? value;
    this.onViewUpdate();
  }
  /**
   * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the TilingSprite.
   */
  getSize(out) {
    out || (out = {});
    out.width = this._width;
    out.height = this._height;
    return out;
  }
  /**
   * @private
   */
  updateBounds() {
    const bounds = this._bounds;
    const anchor = this._anchor;
    const width = this._width;
    const height = this._height;
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(point) {
    const width = this._width;
    const height = this._height;
    const x1 = -width * this._anchor._x;
    let y1 = 0;
    if (point.x >= x1 && point.x <= x1 + width) {
      y1 = -height * this._anchor._y;
      if (point.y >= y1 && point.y <= y1 + height)
        return true;
    }
    return false;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options = false) {
    super.destroy(options);
    this._anchor = null;
    this._tileTransform = null;
    this._bounds = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
  }
};
/** default options for the TilingSprite */
_TilingSprite.defaultOptions = {
  /** The texture to use for the sprite. */
  texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY,
  /** The anchor point of the sprite */
  anchor: { x: 0, y: 0 },
  /** The offset of the image that is being tiled. */
  tilePosition: { x: 0, y: 0 },
  /** Scaling of the image that is being tiled. */
  tileScale: { x: 1, y: 1 },
  /** The rotation of the image that is being tiled. */
  tileRotation: 0,
  /**
   * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in
   * local space.
   *
   * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without
   * this, the top-left corner always gets the (0, 0) texture coordinate.
   * @default false
   */
  applyAnchorToTexture: false
};
let TilingSprite = _TilingSprite;


//# sourceMappingURL=TilingSprite.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TilingSpritePipe: () => (/* binding */ TilingSpritePipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs");
/* harmony import */ var _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/state/State.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs");
/* harmony import */ var _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../rendering/renderers/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graphics/gpu/colorToUniform.mjs */ "./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs");
/* harmony import */ var _mesh_shared_BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh/shared/BatchableMesh.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs");
/* harmony import */ var _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../mesh/shared/MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");
/* harmony import */ var _shader_TilingSpriteShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shader/TilingSpriteShader.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs");
/* harmony import */ var _utils_QuadGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/QuadGeometry.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs");
/* harmony import */ var _utils_setPositions_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/setPositions.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs");
/* harmony import */ var _utils_setUvs_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/setUvs.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs");












"use strict";
const sharedQuad = new _utils_QuadGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__.QuadGeometry();
class TilingSpritePipe {
  constructor(renderer) {
    this._state = _rendering_renderers_shared_state_State_mjs__WEBPACK_IMPORTED_MODULE_1__.State.default2d;
    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash");
  }
  validateRenderable(renderable) {
    const tilingSpriteData = this._getTilingSpriteData(renderable);
    const couldBatch = tilingSpriteData.canBatch;
    this._updateCanBatch(renderable);
    const canBatch = tilingSpriteData.canBatch;
    if (canBatch && canBatch === couldBatch) {
      const { batchableMesh } = tilingSpriteData;
      return !batchableMesh._batcher.checkAndUpdateTexture(
        batchableMesh,
        renderable.texture
      );
    }
    return couldBatch !== canBatch;
  }
  addRenderable(tilingSprite, instructionSet) {
    const batcher = this._renderer.renderPipes.batch;
    this._updateCanBatch(tilingSprite);
    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
    const { geometry, canBatch } = tilingSpriteData;
    if (canBatch) {
      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new _mesh_shared_BatchableMesh_mjs__WEBPACK_IMPORTED_MODULE_2__.BatchableMesh());
      const batchableMesh = tilingSpriteData.batchableMesh;
      if (tilingSprite.didViewUpdate) {
        this._updateBatchableMesh(tilingSprite);
        batchableMesh.geometry = geometry;
        batchableMesh.renderable = tilingSprite;
        batchableMesh.transform = tilingSprite.groupTransform;
        batchableMesh.setTexture(tilingSprite._texture);
      }
      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
      batcher.addToBatch(batchableMesh, instructionSet);
    } else {
      batcher.break(instructionSet);
      tilingSpriteData.shader || (tilingSpriteData.shader = new _shader_TilingSpriteShader_mjs__WEBPACK_IMPORTED_MODULE_3__.TilingSpriteShader());
      this.updateRenderable(tilingSprite);
      instructionSet.add(tilingSprite);
    }
  }
  execute(tilingSprite) {
    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];
    shader.groups[0] = this._renderer.globalUniforms.bindGroup;
    const localUniforms = shader.resources.localUniforms.uniforms;
    localUniforms.uTransformMatrix = tilingSprite.groupTransform;
    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
    (0,_graphics_gpu_colorToUniform_mjs__WEBPACK_IMPORTED_MODULE_4__.color32BitToUniform)(
      tilingSprite.groupColorAlpha,
      localUniforms.uColor,
      0
    );
    this._state.blendMode = (0,_rendering_renderers_shared_state_getAdjustedBlendModeBlend_mjs__WEBPACK_IMPORTED_MODULE_5__.getAdjustedBlendModeBlend)(tilingSprite.groupBlendMode, tilingSprite.texture._source);
    this._renderer.encoder.draw({
      geometry: sharedQuad,
      shader,
      state: this._state
    });
  }
  updateRenderable(tilingSprite) {
    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
    const { canBatch } = tilingSpriteData;
    if (canBatch) {
      const { batchableMesh } = tilingSpriteData;
      if (tilingSprite.didViewUpdate)
        this._updateBatchableMesh(tilingSprite);
      batchableMesh._batcher.updateElement(batchableMesh);
    } else if (tilingSprite.didViewUpdate) {
      const { shader } = tilingSpriteData;
      shader.updateUniforms(
        tilingSprite.width,
        tilingSprite.height,
        tilingSprite._tileTransform.matrix,
        tilingSprite.anchor.x,
        tilingSprite.anchor.y,
        tilingSprite.texture
      );
    }
  }
  destroyRenderable(tilingSprite) {
    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
    tilingSpriteData.batchableMesh = null;
    tilingSpriteData.shader?.destroy();
    this._tilingSpriteDataHash[tilingSprite.uid] = null;
    tilingSprite.off("destroyed", this._destroyRenderableBound);
  }
  _getTilingSpriteData(renderable) {
    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
  }
  _initTilingSpriteData(tilingSprite) {
    const geometry = new _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_6__.MeshGeometry({
      indices: sharedQuad.indices,
      positions: sharedQuad.positions.slice(),
      uvs: sharedQuad.uvs.slice()
    });
    this._tilingSpriteDataHash[tilingSprite.uid] = {
      canBatch: true,
      renderable: tilingSprite,
      geometry
    };
    tilingSprite.on("destroyed", this._destroyRenderableBound);
    return this._tilingSpriteDataHash[tilingSprite.uid];
  }
  _updateBatchableMesh(tilingSprite) {
    const renderableData = this._getTilingSpriteData(tilingSprite);
    const { geometry } = renderableData;
    const style = tilingSprite.texture.source.style;
    if (style.addressMode !== "repeat") {
      style.addressMode = "repeat";
      style.update();
    }
    (0,_utils_setUvs_mjs__WEBPACK_IMPORTED_MODULE_7__.setUvs)(tilingSprite, geometry.uvs);
    (0,_utils_setPositions_mjs__WEBPACK_IMPORTED_MODULE_8__.setPositions)(tilingSprite, geometry.positions);
  }
  destroy() {
    for (const i in this._tilingSpriteDataHash) {
      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);
    }
    this._tilingSpriteDataHash = null;
    this._renderer = null;
  }
  _updateCanBatch(tilingSprite) {
    const renderableData = this._getTilingSpriteData(tilingSprite);
    const texture = tilingSprite.texture;
    let _nonPowOf2wrapping = true;
    if (this._renderer.type === _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_9__.RendererType.WEBGL) {
      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
    }
    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
    return renderableData.canBatch;
  }
}
/** @ignore */
TilingSpritePipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_10__.ExtensionType.CanvasPipes
  ],
  name: "tilingSprite"
};


//# sourceMappingURL=TilingSpritePipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TilingSpriteShader: () => (/* binding */ TilingSpriteShader)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/localUniformBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _tilingBit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tilingBit.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs");









"use strict";
let gpuProgram;
let glProgram;
class TilingSpriteShader extends _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__.Shader {
  constructor() {
    gpuProgram ?? (gpuProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.compileHighShaderGpuProgram)({
      name: "tiling-sprite-shader",
      bits: [
        _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_2__.localUniformBit,
        _tilingBit_mjs__WEBPACK_IMPORTED_MODULE_3__.tilingBit,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_4__.roundPixelsBit
      ]
    }));
    glProgram ?? (glProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_1__.compileHighShaderGlProgram)({
      name: "tiling-sprite-shader",
      bits: [
        _rendering_high_shader_shader_bits_localUniformBit_mjs__WEBPACK_IMPORTED_MODULE_2__.localUniformBitGl,
        _tilingBit_mjs__WEBPACK_IMPORTED_MODULE_3__.tilingBitGl,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_4__.roundPixelsBitGl
      ]
    }));
    const tilingUniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.UniformGroup({
      uMapCoord: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__.Matrix(), type: "mat3x3<f32>" },
      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
      uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
      uTextureTransform: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__.Matrix(), type: "mat3x3<f32>" },
      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
    });
    super({
      glProgram,
      gpuProgram,
      resources: {
        localUniforms: new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.UniformGroup({
          uTransformMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_6__.Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        }),
        tilingUniforms,
        uTexture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__.Texture.EMPTY.source,
        uSampler: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_7__.Texture.EMPTY.source.style
      }
    });
  }
  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
    const tilingUniforms = this.resources.tilingUniforms;
    const textureWidth = texture.width;
    const textureHeight = texture.height;
    const textureMatrix = texture.textureMatrix;
    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
    uTextureTransform.set(
      matrix.a * textureWidth / width,
      matrix.b * textureWidth / height,
      matrix.c * textureHeight / width,
      matrix.d * textureHeight / height,
      matrix.tx / width,
      matrix.ty / height
    );
    uTextureTransform.invert();
    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
    tilingUniforms.uniforms.uSizeAnchor[0] = width;
    tilingUniforms.uniforms.uSizeAnchor[1] = height;
    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
    if (texture) {
      this.resources.uTexture = texture.source;
      this.resources.uSampler = texture.source.style;
    }
  }
}


//# sourceMappingURL=TilingSpriteShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tilingBit: () => (/* binding */ tilingBit),
/* harmony export */   tilingBitGl: () => (/* binding */ tilingBitGl)
/* harmony export */ });

const tilingBit = {
  name: "tiling-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
    ),
    main: (
      /* wgsl */
      `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
    ),
    main: (
      /* wgsl */
      `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
    )
  }
};
const tilingBitGl = {
  name: "tiling-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
    ),
    main: (
      /* glsl */
      `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
    ),
    main: (
      /* glsl */
      `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
    )
  }
};


//# sourceMappingURL=tilingBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QuadGeometry: () => (/* binding */ QuadGeometry)
/* harmony export */ });
/* harmony import */ var _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mesh/shared/MeshGeometry.mjs */ "./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs");


"use strict";
class QuadGeometry extends _mesh_shared_MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry {
  constructor() {
    super({
      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      indices: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
  }
}


//# sourceMappingURL=QuadGeometry.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyMatrix: () => (/* binding */ applyMatrix)
/* harmony export */ });

function applyMatrix(array, stride, offset, matrix) {
  let index = 0;
  const size = array.length / (stride || 2);
  const a = matrix.a;
  const b = matrix.b;
  const c = matrix.c;
  const d = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index < size) {
    const x = array[offset];
    const y = array[offset + 1];
    array[offset] = a * x + c * y + tx;
    array[offset + 1] = b * x + d * y + ty;
    offset += stride;
    index++;
  }
}


//# sourceMappingURL=applyMatrix.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setPositions: () => (/* binding */ setPositions)
/* harmony export */ });

function setPositions(tilingSprite, positions) {
  const anchorX = tilingSprite.anchor.x;
  const anchorY = tilingSprite.anchor.y;
  positions[0] = -anchorX * tilingSprite.width;
  positions[1] = -anchorY * tilingSprite.height;
  positions[2] = (1 - anchorX) * tilingSprite.width;
  positions[3] = -anchorY * tilingSprite.height;
  positions[4] = (1 - anchorX) * tilingSprite.width;
  positions[5] = (1 - anchorY) * tilingSprite.height;
  positions[6] = -anchorX * tilingSprite.width;
  positions[7] = (1 - anchorY) * tilingSprite.height;
}


//# sourceMappingURL=setPositions.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setUvs: () => (/* binding */ setUvs)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _applyMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./applyMatrix.mjs */ "./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs");



"use strict";
function setUvs(tilingSprite, uvs) {
  const texture = tilingSprite.texture;
  const width = texture.frame.width;
  const height = texture.frame.height;
  let anchorX = 0;
  let anchorY = 0;
  if (tilingSprite.applyAnchorToTexture) {
    anchorX = tilingSprite.anchor.x;
    anchorY = tilingSprite.anchor.y;
  }
  uvs[0] = uvs[6] = -anchorX;
  uvs[2] = uvs[4] = 1 - anchorX;
  uvs[1] = uvs[3] = -anchorY;
  uvs[5] = uvs[7] = 1 - anchorY;
  const textureMatrix = _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix.shared;
  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
  textureMatrix.tx /= tilingSprite.width;
  textureMatrix.ty /= tilingSprite.height;
  textureMatrix.invert();
  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
  (0,_applyMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__.applyMatrix)(uvs, 2, 0, textureMatrix);
}


//# sourceMappingURL=setUvs.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BatchableSprite: () => (/* binding */ BatchableSprite)
/* harmony export */ });

class BatchableSprite {
  constructor() {
    this.batcherName = "default";
    this.topology = "triangle-list";
    // batch specific..
    this.attributeSize = 4;
    this.indexSize = 6;
    this.packAsQuad = true;
    this.roundPixels = 0;
    this._attributeStart = 0;
    // location in the buffer
    this._batcher = null;
    this._batch = null;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  reset() {
    this.renderable = null;
    this.texture = null;
    this._batcher = null;
    this._batch = null;
    this.bounds = null;
  }
}


//# sourceMappingURL=BatchableSprite.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sprite: () => (/* binding */ Sprite)
/* harmony export */ });
/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../maths/point/ObservablePoint.mjs */ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/data/updateQuadBounds.mjs */ "./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");






"use strict";
class Sprite extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(options = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY) {
    if (options instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      options = { texture: options };
    }
    const { texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
    super({
      label: "Sprite",
      ...rest
    });
    this.renderPipeId = "sprite";
    this.batched = true;
    this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_2__.ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor) {
      this.anchor = anchor;
    } else if (texture.defaultAnchor) {
      this.anchor = texture.defaultAnchor;
    }
    this.texture = texture;
    this.allowChildren = false;
    this.roundPixels = roundPixels ?? false;
    if (width !== void 0)
      this.width = width;
    if (height !== void 0)
      this.height = height;
  }
  /**
   * Helper function that creates a new sprite based on the source you provide.
   * The source can be - frame id, image, video, canvas element, video element, texture
   * @param source - Source to create texture from
   * @param [skipCache] - Whether to skip the cache or not
   * @returns The newly created sprite
   */
  static from(source, skipCache = false) {
    if (source instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture) {
      return new Sprite(source);
    }
    return new Sprite(_rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.from(source, skipCache));
  }
  set texture(value) {
    value || (value = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value)
      return;
    if (currentTexture && currentTexture.dynamic)
      currentTexture.off("update", this.onViewUpdate, this);
    if (value.dynamic)
      value.on("update", this.onViewUpdate, this);
    this._texture = value;
    if (this._width) {
      this._setWidth(this._width, this._texture.orig.width);
    }
    if (this._height) {
      this._setHeight(this._height, this._texture.orig.height);
    }
    this.onViewUpdate();
  }
  /** The texture that the sprite is using. */
  get texture() {
    return this._texture;
  }
  /**
   * The bounds of the sprite, taking the texture's trim into account.
   * @type {rendering.Bounds}
   */
  get visualBounds() {
    (0,_utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_3__.updateQuadBounds)(this._visualBounds, this._anchor, this._texture);
    return this._visualBounds;
  }
  /**
   * @deprecated
   */
  get sourceBounds() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__.deprecation)("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
    return this.visualBounds;
  }
  /** @private */
  updateBounds() {
    const anchor = this._anchor;
    const texture = this._texture;
    const bounds = this._bounds;
    const { width, height } = texture.orig;
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options = false) {
    super.destroy(options);
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
    this._visualBounds = null;
    this._bounds = null;
    this._anchor = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * The default is `(0,0)`, this means the sprite's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Sprite } from 'pixi.js';
   *
   * const sprite = new Sprite({texture: Texture.WHITE});
   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this._setWidth(value, this._texture.orig.width);
    this._width = value;
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this._setHeight(value, this._texture.orig.height);
    this._height = value;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Sprite.
   */
  getSize(out) {
    out || (out = {});
    out.width = Math.abs(this.scale.x) * this._texture.orig.width;
    out.height = Math.abs(this.scale.y) * this._texture.orig.height;
    return out;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(value, height) {
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    } else {
      height ?? (height = value);
    }
    value !== void 0 && this._setWidth(value, this._texture.orig.width);
    height !== void 0 && this._setHeight(height, this._texture.orig.height);
  }
}


//# sourceMappingURL=Sprite.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpritePipe: () => (/* binding */ SpritePipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BatchableSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");




"use strict";
class SpritePipe {
  constructor(renderer) {
    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
  }
  addRenderable(sprite, instructionSet) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
  }
  updateRenderable(sprite) {
    const gpuSprite = this._gpuSpriteHash[sprite.uid];
    if (sprite.didViewUpdate)
      this._updateBatchableSprite(sprite, gpuSprite);
    gpuSprite._batcher.updateElement(gpuSprite);
  }
  validateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    return !gpuSprite._batcher.checkAndUpdateTexture(
      gpuSprite,
      sprite._texture
    );
  }
  destroyRenderable(sprite) {
    const batchableSprite = this._gpuSpriteHash[sprite.uid];
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(batchableSprite);
    this._gpuSpriteHash[sprite.uid] = null;
    sprite.off("destroyed", this._destroyRenderableBound);
  }
  _updateBatchableSprite(sprite, batchableSprite) {
    batchableSprite.bounds = sprite.visualBounds;
    batchableSprite.texture = sprite._texture;
  }
  _getGpuSprite(sprite) {
    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
  }
  _initGPUSprite(sprite) {
    const batchableSprite = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_1__.BatchableSprite);
    batchableSprite.renderable = sprite;
    batchableSprite.transform = sprite.groupTransform;
    batchableSprite.texture = sprite._texture;
    batchableSprite.bounds = sprite.visualBounds;
    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
    this._gpuSpriteHash[sprite.uid] = batchableSprite;
    sprite.on("destroyed", this._destroyRenderableBound);
    return batchableSprite;
  }
  destroy() {
    for (const i in this._gpuSpriteHash) {
      _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(this._gpuSpriteHash[i]);
    }
    this._gpuSpriteHash = null;
    this._renderer = null;
  }
}
/** @ignore */
SpritePipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.CanvasPipes
  ],
  name: "sprite"
};


//# sourceMappingURL=SpritePipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractBitmapFont: () => (/* binding */ AbstractBitmapFont)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");



"use strict";
class AbstractBitmapFont extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super(...arguments);
    /** The map of characters by character code. */
    this.chars = /* @__PURE__ */ Object.create(null);
    /**
     * The line-height of the font face in pixels.
     * @type {number}
     */
    this.lineHeight = 0;
    /**
     * The name of the font face
     * @type {string}
     */
    this.fontFamily = "";
    /** The metrics of the font face. */
    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
    /**
     * The offset of the font face from the baseline.
     * @type {number}
     */
    this.baseLineOffset = 0;
    /** The range and type of the distance field for this font. */
    this.distanceField = { type: "none", range: 0 };
    /** The map of base page textures (i.e., sheets of glyphs). */
    this.pages = [];
    /** should the fill for this font be applied as a tint to the text. */
    this.applyFillAsTint = true;
    /** The size of the font face in pixels. */
    this.baseMeasurementFontSize = 100;
    this.baseRenderedFontSize = 100;
  }
  /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */
  get font() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
    return this.fontFamily;
  }
  /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */
  get pageTextures() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
    return this.pages;
  }
  /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */
  get size() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
    return this.fontMetrics.fontSize;
  }
  /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */
  get distanceFieldRange() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
    return this.distanceField.range;
  }
  /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */
  get distanceFieldType() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
    return this.distanceField.type;
  }
  destroy(destroyTextures = false) {
    this.emit("destroy", this);
    this.removeAllListeners();
    for (const i in this.chars) {
      this.chars[i].texture?.destroy();
    }
    this.chars = null;
    if (destroyTextures) {
      this.pages.forEach((page) => page.texture.destroy(true));
      this.pages = null;
    }
  }
}


//# sourceMappingURL=AbstractBitmapFont.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitmapFont: () => (/* binding */ BitmapFont)
/* harmony export */ });
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _AbstractBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractBitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs");
/* harmony import */ var _BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BitmapFontManager.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs");





"use strict";
class BitmapFont extends _AbstractBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractBitmapFont {
  constructor(options, url) {
    super();
    const { textures, data } = options;
    Object.keys(data.pages).forEach((key) => {
      const pageData = data.pages[parseInt(key, 10)];
      const texture = textures[pageData.id];
      this.pages.push({ texture });
    });
    Object.keys(data.chars).forEach((key) => {
      const charData = data.chars[key];
      const {
        frame: textureFrame,
        source: textureSource
      } = textures[charData.page];
      const frameReal = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(
        charData.x + textureFrame.x,
        charData.y + textureFrame.y,
        charData.width,
        charData.height
      );
      const texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.Texture({
        source: textureSource,
        frame: frameReal
      });
      this.chars[key] = {
        id: key.codePointAt(0),
        xOffset: charData.xOffset,
        yOffset: charData.yOffset,
        xAdvance: charData.xAdvance,
        kerning: charData.kerning ?? {},
        texture
      };
    });
    this.baseRenderedFontSize = data.fontSize;
    this.baseMeasurementFontSize = data.fontSize;
    this.fontMetrics = {
      ascent: 0,
      descent: 0,
      fontSize: data.fontSize
    };
    this.baseLineOffset = data.baseLineOffset;
    this.lineHeight = data.lineHeight;
    this.fontFamily = data.fontFamily;
    this.distanceField = data.distanceField ?? {
      type: "none",
      range: 0
    };
    this.url = url;
  }
  /** Destroys the BitmapFont object. */
  destroy() {
    super.destroy();
    for (let i = 0; i < this.pages.length; i++) {
      const { texture } = this.pages[i];
      texture.destroy(true);
    }
    this.pages = null;
  }
  /**
   * Generates a bitmap-font for the given style and character set
   * @param options - Setup options for font generation.
   * @returns Font generated by style options.
   * @example
   * import { BitmapFont, BitmapText } from 'pixi.js';
   *
   * BitmapFont.install('TitleFont', {
   *     fontFamily: 'Arial',
   *     fontSize: 12,
   *     strokeThickness: 2,
   *     fill: 'purple',
   * });
   *
   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
   */
  static install(options) {
    _BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFontManager.install(options);
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  static uninstall(name) {
    _BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFontManager.uninstall(name);
  }
}


//# sourceMappingURL=BitmapFont.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitmapFontManager: () => (/* binding */ BitmapFontManager)
/* harmony export */ });
/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../assets/cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../text/TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");
/* harmony import */ var _DynamicBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DynamicBitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs");
/* harmony import */ var _utils_getBitmapTextLayout_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/getBitmapTextLayout.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs");
/* harmony import */ var _utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/resolveCharacters.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs");








"use strict";
let fontCount = 0;
class BitmapFontManagerClass {
  constructor() {
    /**
     * This character set includes all the letters in the alphabet (both lower- and upper- case).
     * @type {string[][]}
     * @example
     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })
     */
    this.ALPHA = [["a", "z"], ["A", "Z"], " "];
    /**
     * This character set includes all decimal digits (from 0 to 9).
     * @type {string[][]}
     * @example
     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })
     */
    this.NUMERIC = [["0", "9"]];
    /**
     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.
     * @type {string[][]}
     */
    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
    /**
     * This character set consists of all the ASCII table.
     * @member {string[][]}
     * @see http://www.asciitable.com/
     */
    this.ASCII = [[" ", "~"]];
    /** Default options for installing a new BitmapFont. */
    this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: false
    };
  }
  /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */
  getFont(text, style) {
    let fontFamilyKey = `${style.fontFamily}-bitmap`;
    let overrideFill = true;
    if (style._fill.fill && !style._stroke) {
      fontFamilyKey += style._fill.fill.styleKey;
      overrideFill = false;
    } else if (style._stroke || style.dropShadow) {
      let key = style.styleKey;
      key = key.substring(0, key.lastIndexOf("-"));
      fontFamilyKey = `${key}-bitmap`;
      overrideFill = false;
    }
    if (!_assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.has(fontFamilyKey)) {
      const fnt = new _DynamicBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_1__.DynamicBitmapFont({
        style,
        overrideFill,
        overrideSize: true,
        ...this.defaultOptions
      });
      fontCount++;
      if (fontCount > 50) {
        (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_2__.warn)("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
      }
      fnt.once("destroy", () => {
        fontCount--;
        _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.remove(fontFamilyKey);
      });
      _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.set(
        fontFamilyKey,
        fnt
      );
    }
    const dynamicFont = _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.get(fontFamilyKey);
    dynamicFont.ensureCharacters?.(text);
    return dynamicFont;
  }
  /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  getLayout(text, style, trimEnd = true) {
    const bitmapFont = this.getFont(text, style);
    return (0,_utils_getBitmapTextLayout_mjs__WEBPACK_IMPORTED_MODULE_3__.getBitmapTextLayout)([...text], style, bitmapFont, trimEnd);
  }
  /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  measureText(text, style, trimEnd = true) {
    return this.getLayout(text, style, trimEnd);
  }
  // eslint-disable-next-line max-len
  install(...args) {
    let options = args[0];
    if (typeof options === "string") {
      options = {
        name: options,
        style: args[1],
        chars: args[2]?.chars,
        resolution: args[2]?.resolution,
        padding: args[2]?.padding,
        skipKerning: args[2]?.skipKerning
      };
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_4__.v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
    }
    const name = options?.name;
    if (!name) {
      throw new Error("[BitmapFontManager] Property `name` is required.");
    }
    options = { ...this.defaultOptions, ...options };
    const textStyle = options.style;
    const style = textStyle instanceof _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_5__.TextStyle ? textStyle : new _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_5__.TextStyle(textStyle);
    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
    const font = new _DynamicBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_1__.DynamicBitmapFont({
      style,
      overrideFill,
      skipKerning: options.skipKerning,
      padding: options.padding,
      resolution: options.resolution,
      overrideSize: false
    });
    const flatChars = (0,_utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_6__.resolveCharacters)(options.chars);
    font.ensureCharacters(flatChars.join(""));
    _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.set(`${name}-bitmap`, font);
    font.once("destroy", () => _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.remove(`${name}-bitmap`));
    return font;
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  uninstall(name) {
    const cacheKey = `${name}-bitmap`;
    const font = _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.get(cacheKey);
    if (font) {
      font.destroy();
    }
  }
}
const BitmapFontManager = new BitmapFontManagerClass();


//# sourceMappingURL=BitmapFontManager.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitmapText: () => (/* binding */ BitmapText)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../text/AbstractText.mjs */ "./node_modules/pixi.js/lib/scene/text/AbstractText.mjs");
/* harmony import */ var _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../text/TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");
/* harmony import */ var _BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BitmapFontManager.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs");





"use strict";
class BitmapText extends _text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractText {
  constructor(...args) {
    var _a;
    const options = (0,_text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureTextOptions)(args, "BitmapText");
    options.style ?? (options.style = options.style || {});
    (_a = options.style).fill ?? (_a.fill = 16777215);
    super(options, _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.TextStyle);
    this.renderPipeId = "bitmapText";
  }
  /** @private */
  updateBounds() {
    const bounds = this._bounds;
    const anchor = this._anchor;
    const bitmapMeasurement = _BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_2__.BitmapFontManager.measureText(this.text, this._style);
    const scale = bitmapMeasurement.scale;
    const offset = bitmapMeasurement.offsetY * scale;
    let width = bitmapMeasurement.width * scale;
    let height = bitmapMeasurement.height * scale;
    const stroke = this._style._stroke;
    if (stroke) {
      width += stroke.width;
      height += stroke.width;
    }
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * (height + offset);
    bounds.maxY = bounds.minY + height;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(value) {
    if (value !== null) {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__.warn)(
        // eslint-disable-next-line max-len
        "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
      );
    }
  }
  get resolution() {
    return this._resolution;
  }
}


//# sourceMappingURL=BitmapText.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitmapTextPipe: () => (/* binding */ BitmapTextPipe)
/* harmony export */ });
/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../assets/cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _graphics_shared_Graphics_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graphics/shared/Graphics.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs");
/* harmony import */ var _text_sdfShader_SdfShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../text/sdfShader/SdfShader.mjs */ "./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs");
/* harmony import */ var _BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BitmapFontManager.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs");
/* harmony import */ var _utils_getBitmapTextLayout_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/getBitmapTextLayout.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs");








"use strict";
class BitmapTextPipe {
  constructor(renderer) {
    this._gpuBitmapText = {};
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this._renderer = renderer;
    this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText");
  }
  validateRenderable(bitmapText) {
    const graphicsRenderable = this._getGpuBitmapText(bitmapText);
    if (bitmapText._didTextUpdate) {
      bitmapText._didTextUpdate = false;
      this._updateContext(bitmapText, graphicsRenderable);
    }
    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
  }
  addRenderable(bitmapText, instructionSet) {
    const graphicsRenderable = this._getGpuBitmapText(bitmapText);
    syncWithProxy(bitmapText, graphicsRenderable);
    if (bitmapText._didTextUpdate) {
      bitmapText._didTextUpdate = false;
      this._updateContext(bitmapText, graphicsRenderable);
    }
    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
    if (graphicsRenderable.context.customShader) {
      this._updateDistanceField(bitmapText);
    }
  }
  destroyRenderable(bitmapText) {
    bitmapText.off("destroyed", this._destroyRenderableBound);
    this._destroyRenderableByUid(bitmapText.uid);
  }
  _destroyRenderableByUid(renderableUid) {
    const context = this._gpuBitmapText[renderableUid].context;
    if (context.customShader) {
      _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(context.customShader);
      context.customShader = null;
    }
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(this._gpuBitmapText[renderableUid]);
    this._gpuBitmapText[renderableUid] = null;
  }
  updateRenderable(bitmapText) {
    const graphicsRenderable = this._getGpuBitmapText(bitmapText);
    syncWithProxy(bitmapText, graphicsRenderable);
    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
    if (graphicsRenderable.context.customShader) {
      this._updateDistanceField(bitmapText);
    }
  }
  _updateContext(bitmapText, proxyGraphics) {
    const { context } = proxyGraphics;
    const bitmapFont = _BitmapFontManager_mjs__WEBPACK_IMPORTED_MODULE_1__.BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
    context.clear();
    if (bitmapFont.distanceField.type !== "none") {
      if (!context.customShader) {
        context.customShader = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(_text_sdfShader_SdfShader_mjs__WEBPACK_IMPORTED_MODULE_2__.SdfShader);
      }
    }
    const chars = Array.from(bitmapText.text);
    const style = bitmapText._style;
    let currentY = bitmapFont.baseLineOffset;
    const bitmapTextLayout = (0,_utils_getBitmapTextLayout_mjs__WEBPACK_IMPORTED_MODULE_3__.getBitmapTextLayout)(chars, style, bitmapFont, true);
    let index = 0;
    const padding = style.padding;
    const scale = bitmapTextLayout.scale;
    let tx = bitmapTextLayout.width;
    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
    if (style._stroke) {
      tx += style._stroke.width / scale;
      ty += style._stroke.width / scale;
    }
    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {
      const line = bitmapTextLayout.lines[i];
      for (let j = 0; j < line.charPositions.length; j++) {
        const char = chars[index++];
        const charData = bitmapFont.chars[char];
        if (charData?.texture) {
          context.texture(
            charData.texture,
            tint ? tint : "black",
            Math.round(line.charPositions[j] + charData.xOffset),
            Math.round(currentY + charData.yOffset)
          );
        }
      }
      currentY += bitmapFont.lineHeight;
    }
  }
  _getGpuBitmapText(bitmapText) {
    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
  }
  initGpuText(bitmapText) {
    const proxyRenderable = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(_graphics_shared_Graphics_mjs__WEBPACK_IMPORTED_MODULE_4__.Graphics);
    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
    this._updateContext(bitmapText, proxyRenderable);
    bitmapText.on("destroyed", this._destroyRenderableBound);
    return this._gpuBitmapText[bitmapText.uid];
  }
  _updateDistanceField(bitmapText) {
    const context = this._getGpuBitmapText(bitmapText).context;
    const fontFamily = bitmapText._style.fontFamily;
    const dynamicFont = _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_5__.Cache.get(`${fontFamily}-bitmap`);
    const { a, b, c, d } = bitmapText.groupTransform;
    const dx = Math.sqrt(a * a + b * b);
    const dy = Math.sqrt(c * c + d * d);
    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
    context.customShader.resources.localUniforms.uniforms.uDistance = distance;
  }
  destroy() {
    for (const uid in this._gpuBitmapText) {
      this._destroyRenderableByUid(uid);
    }
    this._gpuBitmapText = null;
    this._renderer = null;
  }
}
/** @ignore */
BitmapTextPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_6__.ExtensionType.CanvasPipes
  ],
  name: "bitmapText"
};
function syncWithProxy(container, proxy) {
  proxy.groupTransform = container.groupTransform;
  proxy.groupColorAlpha = container.groupColorAlpha;
  proxy.groupColor = container.groupColor;
  proxy.groupBlendMode = container.groupBlendMode;
  proxy.globalDisplayStatus = container.globalDisplayStatus;
  proxy.groupTransform = container.groupTransform;
  proxy.localDisplayStatus = container.localDisplayStatus;
  proxy.groupAlpha = container.groupAlpha;
  proxy._roundPixels = container._roundPixels;
}


//# sourceMappingURL=BitmapTextPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicBitmapFont: () => (/* binding */ DynamicBitmapFont)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/CanvasPool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/sources/ImageSource.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _text_canvas_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../text/canvas/CanvasTextMetrics.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs");
/* harmony import */ var _text_canvas_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../text/canvas/utils/fontStringFromTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs");
/* harmony import */ var _text_canvas_utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../text/canvas/utils/getCanvasFillStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs");
/* harmony import */ var _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../text/TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");
/* harmony import */ var _AbstractBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractBitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs");
/* harmony import */ var _utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/resolveCharacters.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs");













"use strict";
const _DynamicBitmapFont = class _DynamicBitmapFont extends _AbstractBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractBitmapFont {
  /**
   * @param options - The options for the dynamic bitmap font.
   */
  constructor(options) {
    super();
    /**
     * this is a resolution modifier for the font size..
     * texture resolution will also be used to scale texture according to its font size also
     */
    this.resolution = 1;
    /** The pages of the font. */
    this.pages = [];
    this._padding = 0;
    this._measureCache = /* @__PURE__ */ Object.create(null);
    this._currentChars = [];
    this._currentX = 0;
    this._currentY = 0;
    this._currentPageIndex = -1;
    this._skipKerning = false;
    const dynamicOptions = { ..._DynamicBitmapFont.defaultOptions, ...options };
    this._textureSize = dynamicOptions.textureSize;
    this._mipmap = dynamicOptions.mipmap;
    const style = dynamicOptions.style.clone();
    if (dynamicOptions.overrideFill) {
      style._fill.color = 16777215;
      style._fill.alpha = 1;
      style._fill.texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture.WHITE;
      style._fill.fill = null;
    }
    this.applyFillAsTint = dynamicOptions.overrideFill;
    const requestedFontSize = style.fontSize;
    style.fontSize = this.baseMeasurementFontSize;
    const font = (0,_text_canvas_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.fontStringFromTextStyle)(style);
    if (dynamicOptions.overrideSize) {
      if (style._stroke) {
        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
      }
    } else {
      style.fontSize = this.baseRenderedFontSize = requestedFontSize;
    }
    this._style = style;
    this._skipKerning = dynamicOptions.skipKerning ?? false;
    this.resolution = dynamicOptions.resolution ?? 1;
    this._padding = dynamicOptions.padding ?? 4;
    this.fontMetrics = _text_canvas_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.CanvasTextMetrics.measureFont(font);
    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
  }
  ensureCharacters(chars) {
    const charList = (0,_utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_4__.resolveCharacters)(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);
    if (!charList.length)
      return;
    this._currentChars = [...this._currentChars, ...charList];
    let pageData;
    if (this._currentPageIndex === -1) {
      pageData = this._nextPage();
    } else {
      pageData = this.pages[this._currentPageIndex];
    }
    let { canvas, context } = pageData.canvasAndContext;
    let textureSource = pageData.texture.source;
    const style = this._style;
    let currentX = this._currentX;
    let currentY = this._currentY;
    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
    const padding = this._padding * fontScale;
    let maxCharHeight = 0;
    let skipTexture = false;
    const maxTextureWidth = canvas.width / this.resolution;
    const maxTextureHeight = canvas.height / this.resolution;
    for (let i = 0; i < charList.length; i++) {
      const char = charList[i];
      const metrics = _text_canvas_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.CanvasTextMetrics.measureText(char, style, canvas, false);
      metrics.lineHeight = metrics.height;
      const width = metrics.width * fontScale;
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      const height = metrics.height * fontScale;
      const paddedWidth = textureGlyphWidth + padding * 2;
      const paddedHeight = height + padding * 2;
      skipTexture = false;
      if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
        skipTexture = true;
        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
      }
      if (currentX + paddedWidth > maxTextureWidth) {
        currentY += maxCharHeight;
        maxCharHeight = paddedHeight;
        currentX = 0;
        if (currentY + maxCharHeight > maxTextureHeight) {
          textureSource.update();
          const pageData2 = this._nextPage();
          canvas = pageData2.canvasAndContext.canvas;
          context = pageData2.canvasAndContext.context;
          textureSource = pageData2.texture.source;
          currentY = 0;
        }
      }
      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
      this.chars[char] = {
        id: char.codePointAt(0),
        xOffset: -this._padding,
        yOffset: -this._padding,
        xAdvance,
        kerning: {}
      };
      if (skipTexture) {
        this._drawGlyph(
          context,
          metrics,
          currentX + padding,
          currentY + padding,
          fontScale,
          style
        );
        const px = textureSource.width * fontScale;
        const py = textureSource.height * fontScale;
        const frame = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__.Rectangle(
          currentX / px * textureSource.width,
          currentY / py * textureSource.height,
          paddedWidth / px * textureSource.width,
          paddedHeight / py * textureSource.height
        );
        this.chars[char].texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture({
          source: textureSource,
          frame
        });
        currentX += Math.ceil(paddedWidth);
      }
    }
    textureSource.update();
    this._currentX = currentX;
    this._currentY = currentY;
    this._skipKerning && this._applyKerning(charList, context);
  }
  /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */
  get pageTextures() {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_6__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_6__.v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
    return this.pages;
  }
  _applyKerning(newChars, context) {
    const measureCache = this._measureCache;
    for (let i = 0; i < newChars.length; i++) {
      const first = newChars[i];
      for (let j = 0; j < this._currentChars.length; j++) {
        const second = this._currentChars[j];
        let c1 = measureCache[first];
        if (!c1)
          c1 = measureCache[first] = context.measureText(first).width;
        let c2 = measureCache[second];
        if (!c2)
          c2 = measureCache[second] = context.measureText(second).width;
        let total = context.measureText(first + second).width;
        let amount = total - (c1 + c2);
        if (amount) {
          this.chars[first].kerning[second] = amount;
        }
        total = context.measureText(first + second).width;
        amount = total - (c1 + c2);
        if (amount) {
          this.chars[second].kerning[first] = amount;
        }
      }
    }
  }
  _nextPage() {
    this._currentPageIndex++;
    const textureResolution = this.resolution;
    const canvasAndContext = _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_7__.CanvasPool.getOptimalCanvasAndContext(
      this._textureSize,
      this._textureSize,
      textureResolution
    );
    this._setupContext(canvasAndContext.context, this._style, textureResolution);
    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
    const texture = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_1__.Texture({
      source: new _rendering_renderers_shared_texture_sources_ImageSource_mjs__WEBPACK_IMPORTED_MODULE_8__.ImageSource({
        resource: canvasAndContext.canvas,
        resolution,
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: this._mipmap
      })
    });
    const pageData = {
      canvasAndContext,
      texture
    };
    this.pages[this._currentPageIndex] = pageData;
    return pageData;
  }
  // canvas style!
  _setupContext(context, style, resolution) {
    style.fontSize = this.baseRenderedFontSize;
    context.scale(resolution, resolution);
    context.font = (0,_text_canvas_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.fontStringFromTextStyle)(style);
    style.fontSize = this.baseMeasurementFontSize;
    context.textBaseline = style.textBaseline;
    const stroke = style._stroke;
    const strokeThickness = stroke?.width ?? 0;
    if (stroke) {
      context.lineWidth = strokeThickness;
      context.lineJoin = stroke.join;
      context.miterLimit = stroke.miterLimit;
      context.strokeStyle = (0,_text_canvas_utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_9__.getCanvasFillStyle)(stroke, context);
    }
    if (style._fill) {
      context.fillStyle = (0,_text_canvas_utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_9__.getCanvasFillStyle)(style._fill, context);
    }
    if (style.dropShadow) {
      const shadowOptions = style.dropShadow;
      const rgb = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_10__.Color.shared.setValue(shadowOptions.color).toArray();
      const dropShadowBlur = shadowOptions.blur * resolution;
      const dropShadowDistance = shadowOptions.distance * resolution;
      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
      context.shadowBlur = dropShadowBlur;
      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
    } else {
      context.shadowColor = "black";
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
  }
  _drawGlyph(context, metrics, x, y, fontScale, style) {
    const char = metrics.text;
    const fontProperties = metrics.fontProperties;
    const stroke = style._stroke;
    const strokeThickness = (stroke?.width ?? 0) * fontScale;
    const tx = x + strokeThickness / 2;
    const ty = y - strokeThickness / 2;
    const descent = fontProperties.descent * fontScale;
    const lineHeight = metrics.lineHeight * fontScale;
    if (style.stroke && strokeThickness) {
      context.strokeText(char, tx, ty + lineHeight - descent);
    }
    if (style._fill) {
      context.fillText(char, tx, ty + lineHeight - descent);
    }
  }
  destroy() {
    super.destroy();
    for (let i = 0; i < this.pages.length; i++) {
      const { canvasAndContext, texture } = this.pages[i];
      _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_7__.CanvasPool.returnCanvasAndContext(canvasAndContext);
      texture.destroy(true);
    }
    this.pages = null;
  }
};
_DynamicBitmapFont.defaultOptions = {
  textureSize: 512,
  style: new _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_11__.TextStyle(),
  mipmap: true
};
let DynamicBitmapFont = _DynamicBitmapFont;


//# sourceMappingURL=DynamicBitmapFont.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bitmapFontTextParser: () => (/* binding */ bitmapFontTextParser)
/* harmony export */ });

const bitmapFontTextParser = {
  test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  },
  parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i in items) {
      const name = items[i].match(/^[a-z]+/gm)[0];
      const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i2 in attributeList) {
        const split = attributeList[i2].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    const font = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    };
    const [info] = rawData.info;
    const [common] = rawData.common;
    const [distanceField] = rawData.distanceField ?? [];
    if (distanceField) {
      font.distanceField = {
        range: parseInt(distanceField.distanceRange, 10),
        type: distanceField.fieldType
      };
    }
    font.fontSize = parseInt(info.size, 10);
    font.fontFamily = info.face;
    font.lineHeight = parseInt(common.lineHeight, 10);
    const page = rawData.page;
    for (let i = 0; i < page.length; i++) {
      font.pages.push({
        id: parseInt(page[i].id, 10) || 0,
        file: page[i].file
      });
    }
    const map = {};
    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
    const char = rawData.char;
    for (let i = 0; i < char.length; i++) {
      const charNode = char[i];
      const id = parseInt(charNode.id, 10);
      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);
      if (letter === "space")
        letter = " ";
      map[id] = letter;
      font.chars[letter] = {
        id,
        // texture deets..
        page: parseInt(charNode.page, 10) || 0,
        x: parseInt(charNode.x, 10),
        y: parseInt(charNode.y, 10),
        width: parseInt(charNode.width, 10),
        height: parseInt(charNode.height, 10),
        xOffset: parseInt(charNode.xoffset, 10),
        yOffset: parseInt(charNode.yoffset, 10),
        xAdvance: parseInt(charNode.xadvance, 10),
        kerning: {}
      };
    }
    const kerning = rawData.kerning || [];
    for (let i = 0; i < kerning.length; i++) {
      const first = parseInt(kerning[i].first, 10);
      const second = parseInt(kerning[i].second, 10);
      const amount = parseInt(kerning[i].amount, 10);
      font.chars[map[second]].kerning[map[first]] = amount;
    }
    return font;
  }
};


//# sourceMappingURL=bitmapFontTextParser.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bitmapFontXMLParser: () => (/* binding */ bitmapFontXMLParser)
/* harmony export */ });

const bitmapFontXMLParser = {
  test(data) {
    const xml = data;
    return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  },
  parse(xml) {
    const data = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    };
    const info = xml.getElementsByTagName("info")[0];
    const common = xml.getElementsByTagName("common")[0];
    const distanceField = xml.getElementsByTagName("distanceField")[0];
    if (distanceField) {
      data.distanceField = {
        type: distanceField.getAttribute("fieldType"),
        range: parseInt(distanceField.getAttribute("distanceRange"), 10)
      };
    }
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    data.fontSize = parseInt(info.getAttribute("size"), 10);
    data.fontFamily = info.getAttribute("face");
    data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
    for (let i = 0; i < page.length; i++) {
      data.pages.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    const map = {};
    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
    for (let i = 0; i < char.length; i++) {
      const charNode = char[i];
      const id = parseInt(charNode.getAttribute("id"), 10);
      let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);
      if (letter === "space")
        letter = " ";
      map[id] = letter;
      data.chars[letter] = {
        id,
        // texture deets..
        page: parseInt(charNode.getAttribute("page"), 10) || 0,
        x: parseInt(charNode.getAttribute("x"), 10),
        y: parseInt(charNode.getAttribute("y"), 10),
        width: parseInt(charNode.getAttribute("width"), 10),
        height: parseInt(charNode.getAttribute("height"), 10),
        // render deets..
        xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
        yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
        // + baseLineOffset,
        xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
        kerning: {}
      };
    }
    for (let i = 0; i < kerning.length; i++) {
      const first = parseInt(kerning[i].getAttribute("first"), 10);
      const second = parseInt(kerning[i].getAttribute("second"), 10);
      const amount = parseInt(kerning[i].getAttribute("amount"), 10);
      data.chars[map[second]].kerning[map[first]] = amount;
    }
    return data;
  }
};


//# sourceMappingURL=bitmapFontXMLParser.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bitmapFontXMLStringParser: () => (/* binding */ bitmapFontXMLStringParser)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _bitmapFontXMLParser_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitmapFontXMLParser.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs");



"use strict";
const bitmapFontXMLStringParser = {
  test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return _bitmapFontXMLParser_mjs__WEBPACK_IMPORTED_MODULE_0__.bitmapFontXMLParser.test(_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().parseXML(data));
    }
    return false;
  },
  parse(data) {
    return _bitmapFontXMLParser_mjs__WEBPACK_IMPORTED_MODULE_0__.bitmapFontXMLParser.parse(_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().parseXML(data));
  }
};


//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bitmapFontCachePlugin: () => (/* binding */ bitmapFontCachePlugin),
/* harmony export */   loadBitmapFont: () => (/* binding */ loadBitmapFont)
/* harmony export */ });
/* harmony import */ var _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../assets/loader/parsers/LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _assets_utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../assets/utils/copySearchParams.mjs */ "./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs");
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/path.mjs */ "./node_modules/pixi.js/lib/utils/path.mjs");
/* harmony import */ var _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../BitmapFont.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs");
/* harmony import */ var _bitmapFontTextParser_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bitmapFontTextParser.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs");
/* harmony import */ var _bitmapFontXMLStringParser_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bitmapFontXMLStringParser.mjs */ "./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs");









"use strict";
const validExtensions = [".xml", ".fnt"];
const bitmapFontCachePlugin = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CacheParser,
    name: "cacheBitmapFont"
  },
  test: (asset) => asset instanceof _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_1__.BitmapFont,
  getCacheableAssets(keys, asset) {
    const out = {};
    keys.forEach((key) => {
      out[key] = asset;
      out[`${key}-bitmap`] = asset;
    });
    out[`${asset.fontFamily}-bitmap`] = asset;
    return out;
  }
};
const loadBitmapFont = {
  extension: {
    type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_2__.LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url) {
    return validExtensions.includes(_utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__.path.extname(url).toLowerCase());
  },
  async testParse(data) {
    return _bitmapFontTextParser_mjs__WEBPACK_IMPORTED_MODULE_4__.bitmapFontTextParser.test(data) || _bitmapFontXMLStringParser_mjs__WEBPACK_IMPORTED_MODULE_5__.bitmapFontXMLStringParser.test(data);
  },
  async parse(asset, data, loader) {
    const bitmapFontData = _bitmapFontTextParser_mjs__WEBPACK_IMPORTED_MODULE_4__.bitmapFontTextParser.test(asset) ? _bitmapFontTextParser_mjs__WEBPACK_IMPORTED_MODULE_4__.bitmapFontTextParser.parse(asset) : _bitmapFontXMLStringParser_mjs__WEBPACK_IMPORTED_MODULE_5__.bitmapFontXMLStringParser.parse(asset);
    const { src } = data;
    const { pages } = bitmapFontData;
    const textureUrls = [];
    const textureOptions = bitmapFontData.distanceField ? {
      scaleMode: "linear",
      alphaMode: "premultiply-alpha-on-upload",
      autoGenerateMipmaps: false,
      resolution: 1
    } : {};
    for (let i = 0; i < pages.length; ++i) {
      const pageFile = pages[i].file;
      let imagePath = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__.path.join(_utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__.path.dirname(src), pageFile);
      imagePath = (0,_assets_utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_6__.copySearchParams)(imagePath, src);
      textureUrls.push({
        src: imagePath,
        data: textureOptions
      });
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url) => loadedTextures[url.src]);
    const bitmapFont = new _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_1__.BitmapFont({
      data: bitmapFontData,
      textures
    }, src);
    return bitmapFont;
  },
  async load(url, _options) {
    const response = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_7__.DOMAdapter.get().fetch(url);
    return await response.text();
  },
  async unload(bitmapFont, _resolvedAsset, loader) {
    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
    bitmapFont.destroy();
  }
};


//# sourceMappingURL=loadBitmapFont.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBitmapTextLayout: () => (/* binding */ getBitmapTextLayout)
/* harmony export */ });

function getBitmapTextLayout(chars, style, font, trimEnd) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j = 0; j < currentWord.index; j++) {
      const position = word.positions[j];
      currentLine.chars.push(word.chars[j]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    if (trimEnd) {
      let lastChar = currentLine.chars[index];
      while (lastChar === " ") {
        currentLine.width -= font.chars[lastChar].xAdvance;
        lastChar = currentLine.chars[--index];
      }
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += font.lineHeight;
  };
  const scale = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale;
  for (let i = 0; i < chars.length + 1; i++) {
    let char;
    const isEnd = i === chars.length;
    if (!isEnd) {
      char = chars[i];
    }
    const charData = font.chars[char] || font.chars[" "];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        if (currentLine.width !== 0) {
          nextLine();
        }
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i = 0; i < measurementData.lines.length; i++) {
    const line = measurementData.lines[i];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j = 0; j < line.charPositions.length; j++) {
      line.charPositions[j] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i = 0; i < measurementData.lines.length; i++) {
    const line = measurementData.lines[i];
    const offset = measurementData.width - line.width;
    for (let j = 0; j < line.charPositions.length; j++) {
      line.charPositions[j] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i = 0; i < measurementData.lines.length; i++) {
    const line = measurementData.lines[i];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j = 0; j < line.charPositions.length; j++) {
      if (j === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j] += offset;
    }
  }
}


//# sourceMappingURL=getBitmapTextLayout.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveCharacters: () => (/* binding */ resolveCharacters)
/* harmony export */ });

function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i = 0, j = chars.length; i < j; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
        result.push(String.fromCharCode(i2));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}


//# sourceMappingURL=resolveCharacters.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTMLText: () => (/* binding */ HTMLText)
/* harmony export */ });
/* harmony import */ var _text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../text/AbstractText.mjs */ "./node_modules/pixi.js/lib/scene/text/AbstractText.mjs");
/* harmony import */ var _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HTMLTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs");
/* harmony import */ var _utils_measureHtmlText_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/measureHtmlText.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs");




"use strict";
class HTMLText extends _text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractText {
  constructor(...args) {
    const options = (0,_text_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureTextOptions)(args, "HtmlText");
    super(options, _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.HTMLTextStyle);
    this.renderPipeId = "htmlText";
  }
  /** @private */
  updateBounds() {
    const bounds = this._bounds;
    const anchor = this._anchor;
    const htmlMeasurement = (0,_utils_measureHtmlText_mjs__WEBPACK_IMPORTED_MODULE_2__.measureHtmlText)(this.text, this._style);
    const { width, height } = htmlMeasurement;
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
}


//# sourceMappingURL=HTMLText.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTMLTextPipe: () => (/* binding */ HTMLTextPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sprite/BatchableSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");
/* harmony import */ var _text_utils_updateTextBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../text/utils/updateTextBounds.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs");






"use strict";
class HTMLTextPipe {
  constructor(renderer) {
    this._gpuText = /* @__PURE__ */ Object.create(null);
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this._renderer = renderer;
    this._renderer.runners.resolutionChange.add(this);
    this._renderer.renderableGC.addManagedHash(this, "_gpuText");
  }
  resolutionChange() {
    for (const i in this._gpuText) {
      const gpuText = this._gpuText[i];
      if (!gpuText)
        continue;
      const text = gpuText.batchableSprite.renderable;
      if (text._autoResolution) {
        text._resolution = this._renderer.resolution;
        text.onViewUpdate();
      }
    }
  }
  validateRenderable(htmlText) {
    const gpuText = this._getGpuText(htmlText);
    const newKey = htmlText._getKey();
    if (gpuText.textureNeedsUploading) {
      gpuText.textureNeedsUploading = false;
      return true;
    }
    if (gpuText.currentKey !== newKey) {
      return true;
    }
    return false;
  }
  addRenderable(htmlText, instructionSet) {
    const gpuText = this._getGpuText(htmlText);
    const batchableSprite = gpuText.batchableSprite;
    if (htmlText._didTextUpdate) {
      this._updateText(htmlText);
    }
    this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
  }
  updateRenderable(htmlText) {
    const gpuText = this._getGpuText(htmlText);
    const batchableSprite = gpuText.batchableSprite;
    if (htmlText._didTextUpdate) {
      this._updateText(htmlText);
    }
    batchableSprite._batcher.updateElement(batchableSprite);
  }
  destroyRenderable(htmlText) {
    htmlText.off("destroyed", this._destroyRenderableBound);
    this._destroyRenderableById(htmlText.uid);
  }
  _destroyRenderableById(htmlTextUid) {
    const gpuText = this._gpuText[htmlTextUid];
    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(gpuText.batchableSprite);
    this._gpuText[htmlTextUid] = null;
  }
  _updateText(htmlText) {
    const newKey = htmlText._getKey();
    const gpuText = this._getGpuText(htmlText);
    const batchableSprite = gpuText.batchableSprite;
    if (gpuText.currentKey !== newKey) {
      this._updateGpuText(htmlText).catch((e) => {
        console.error(e);
      });
    }
    htmlText._didTextUpdate = false;
    (0,_text_utils_updateTextBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.updateTextBounds)(batchableSprite, htmlText);
  }
  async _updateGpuText(htmlText) {
    htmlText._didTextUpdate = false;
    const gpuText = this._getGpuText(htmlText);
    if (gpuText.generatingTexture)
      return;
    const newKey = htmlText._getKey();
    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
    gpuText.generatingTexture = true;
    gpuText.currentKey = newKey;
    const resolution = htmlText.resolution ?? this._renderer.resolution;
    const texture = await this._renderer.htmlText.getManagedTexture(
      htmlText.text,
      resolution,
      htmlText._style,
      htmlText._getKey()
    );
    const batchableSprite = gpuText.batchableSprite;
    batchableSprite.texture = gpuText.texture = texture;
    gpuText.generatingTexture = false;
    gpuText.textureNeedsUploading = true;
    htmlText.onViewUpdate();
    (0,_text_utils_updateTextBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.updateTextBounds)(batchableSprite, htmlText);
  }
  _getGpuText(htmlText) {
    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
  }
  initGpuText(htmlText) {
    const gpuTextData = {
      texture: _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.Texture.EMPTY,
      currentKey: "--",
      batchableSprite: _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(_sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchableSprite),
      textureNeedsUploading: false,
      generatingTexture: false
    };
    const batchableSprite = gpuTextData.batchableSprite;
    batchableSprite.renderable = htmlText;
    batchableSprite.transform = htmlText.groupTransform;
    batchableSprite.texture = _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_2__.Texture.EMPTY;
    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
    this._gpuText[htmlText.uid] = gpuTextData;
    htmlText.on("destroyed", this._destroyRenderableBound);
    return gpuTextData;
  }
  destroy() {
    for (const i in this._gpuText) {
      this._destroyRenderableById(i);
    }
    this._gpuText = null;
    this._renderer = null;
  }
}
/** @ignore */
HTMLTextPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_4__.ExtensionType.CanvasPipes
  ],
  name: "htmlText"
};


//# sourceMappingURL=HTMLTextPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTMLTextRenderData: () => (/* binding */ HTMLTextRenderData),
/* harmony export */   nssvg: () => (/* binding */ nssvg),
/* harmony export */   nsxhtml: () => (/* binding */ nsxhtml)
/* harmony export */ });

const nssvg = "http://www.w3.org/2000/svg";
const nsxhtml = "http://www.w3.org/1999/xhtml";
class HTMLTextRenderData {
  constructor() {
    this.svgRoot = document.createElementNS(nssvg, "svg");
    this.foreignObject = document.createElementNS(nssvg, "foreignObject");
    this.domElement = document.createElementNS(nsxhtml, "div");
    this.styleElement = document.createElementNS(nsxhtml, "style");
    this.image = new Image();
    const { foreignObject, svgRoot, styleElement, domElement } = this;
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    foreignObject.appendChild(styleElement);
    foreignObject.appendChild(domElement);
  }
}


//# sourceMappingURL=HTMLTextRenderData.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTMLTextStyle: () => (/* binding */ HTMLTextStyle)
/* harmony export */ });
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../text/TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");
/* harmony import */ var _text_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../text/utils/generateTextStyleKey.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs");
/* harmony import */ var _utils_textStyleToCSS_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/textStyleToCSS.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs");





"use strict";
class HTMLTextStyle extends _text_TextStyle_mjs__WEBPACK_IMPORTED_MODULE_0__.TextStyle {
  constructor(options = {}) {
    super(options);
    this._cssOverrides = [];
    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
    this.tagStyles = options.tagStyles ?? {};
  }
  /** List of style overrides that will be applied to the HTML text. */
  set cssOverrides(value) {
    this._cssOverrides = value instanceof Array ? value : [value];
    this.update();
  }
  get cssOverrides() {
    return this._cssOverrides;
  }
  _generateKey() {
    this._styleKey = (0,_text_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_1__.generateTextStyleKey)(this) + this._cssOverrides.join("-");
    return this._styleKey;
  }
  update() {
    this._cssStyle = null;
    super.update();
  }
  /**
   * Creates a new HTMLTextStyle object with the same values as this one.
   * @returns New cloned HTMLTextStyle object
   */
  clone() {
    return new HTMLTextStyle({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth,
      cssOverrides: this.cssOverrides
    });
  }
  get cssStyle() {
    if (!this._cssStyle) {
      this._cssStyle = (0,_utils_textStyleToCSS_mjs__WEBPACK_IMPORTED_MODULE_2__.textStyleToCSS)(this);
    }
    return this._cssStyle;
  }
  /**
   * Add a style override, this can be any CSS property
   * it will override any built-in style. This is the
   * property and the value as a string (e.g., `color: red`).
   * This will override any other internal style.
   * @param {string} value - CSS style(s) to add.
   * @example
   * style.addOverride('background-color: red');
   */
  addOverride(...value) {
    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));
    if (toAdd.length > 0) {
      this.cssOverrides.push(...toAdd);
      this.update();
    }
  }
  /**
   * Remove any overrides that match the value.
   * @param {string} value - CSS style to remove.
   * @example
   * style.removeOverride('background-color: red');
   */
  removeOverride(...value) {
    const toRemove = value.filter((v) => this.cssOverrides.includes(v));
    if (toRemove.length > 0) {
      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));
      this.update();
    }
  }
  set fill(value) {
    if (typeof value !== "string" && typeof value !== "number") {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__.warn)("[HTMLTextStyle] only color fill is not supported by HTMLText");
    }
    super.fill = value;
  }
  set stroke(value) {
    if (value && typeof value !== "string" && typeof value !== "number") {
      (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_3__.warn)("[HTMLTextStyle] only color stroke is not supported by HTMLText");
    }
    super.stroke = value;
  }
}


//# sourceMappingURL=HTMLTextStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTMLTextSystem: () => (/* binding */ HTMLTextSystem)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/CanvasPool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rendering/renderers/types.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/types.mjs");
/* harmony import */ var _utils_browser_isSafari_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils/browser/isSafari.mjs */ "./node_modules/pixi.js/lib/utils/browser/isSafari.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _text_utils_getPo2TextureFromSource_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../text/utils/getPo2TextureFromSource.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs");
/* harmony import */ var _HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HTMLTextRenderData.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs");
/* harmony import */ var _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./HTMLTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs");
/* harmony import */ var _utils_extractFontFamilies_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/extractFontFamilies.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs");
/* harmony import */ var _utils_getFontCss_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/getFontCss.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs");
/* harmony import */ var _utils_getSVGUrl_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/getSVGUrl.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs");
/* harmony import */ var _utils_getTemporaryCanvasFromImage_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/getTemporaryCanvasFromImage.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs");
/* harmony import */ var _utils_loadSVGImage_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/loadSVGImage.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs");
/* harmony import */ var _utils_measureHtmlText_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/measureHtmlText.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs");

















"use strict";
class HTMLTextSystem {
  constructor(renderer) {
    this._activeTextures = {};
    this._renderer = renderer;
    this._createCanvas = renderer.type === _rendering_renderers_types_mjs__WEBPACK_IMPORTED_MODULE_0__.RendererType.WEBGPU;
  }
  getTexture(options) {
    return this._buildTexturePromise(
      options.text,
      options.resolution,
      options.style
    );
  }
  getManagedTexture(text, resolution, style, textKey) {
    if (this._activeTextures[textKey]) {
      this._increaseReferenceCount(textKey);
      return this._activeTextures[textKey].promise;
    }
    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {
      this._activeTextures[textKey].texture = texture;
      return texture;
    });
    this._activeTextures[textKey] = {
      texture: null,
      promise,
      usageCount: 1
    };
    return promise;
  }
  async _buildTexturePromise(text, resolution, style) {
    const htmlTextData = _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.BigPool.get(_HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_2__.HTMLTextRenderData);
    const fontFamilies = (0,_utils_extractFontFamilies_mjs__WEBPACK_IMPORTED_MODULE_3__.extractFontFamilies)(text, style);
    const fontCSS = await (0,_utils_getFontCss_mjs__WEBPACK_IMPORTED_MODULE_4__.getFontCss)(
      fontFamilies,
      style,
      _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_5__.HTMLTextStyle.defaultTextStyle
    );
    const measured = (0,_utils_measureHtmlText_mjs__WEBPACK_IMPORTED_MODULE_6__.measureHtmlText)(text, style, fontCSS, htmlTextData);
    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
    const image = htmlTextData.image;
    const uvSafeOffset = 2;
    image.width = (width | 0) + uvSafeOffset;
    image.height = (height | 0) + uvSafeOffset;
    const svgURL = (0,_utils_getSVGUrl_mjs__WEBPACK_IMPORTED_MODULE_7__.getSVGUrl)(text, style, resolution, fontCSS, htmlTextData);
    await (0,_utils_loadSVGImage_mjs__WEBPACK_IMPORTED_MODULE_8__.loadSVGImage)(image, svgURL, (0,_utils_browser_isSafari_mjs__WEBPACK_IMPORTED_MODULE_9__.isSafari)() && fontFamilies.length > 0);
    const resource = image;
    let canvasAndContext;
    if (this._createCanvas) {
      canvasAndContext = (0,_utils_getTemporaryCanvasFromImage_mjs__WEBPACK_IMPORTED_MODULE_10__.getTemporaryCanvasFromImage)(image, resolution);
    }
    const texture = (0,_text_utils_getPo2TextureFromSource_mjs__WEBPACK_IMPORTED_MODULE_11__.getPo2TextureFromSource)(
      canvasAndContext ? canvasAndContext.canvas : resource,
      image.width - uvSafeOffset,
      image.height - uvSafeOffset,
      resolution
    );
    if (this._createCanvas) {
      this._renderer.texture.initSource(texture.source);
      _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_12__.CanvasPool.returnCanvasAndContext(canvasAndContext);
    }
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.BigPool.return(htmlTextData);
    return texture;
  }
  _increaseReferenceCount(textKey) {
    this._activeTextures[textKey].usageCount++;
  }
  decreaseReferenceCount(textKey) {
    const activeTexture = this._activeTextures[textKey];
    if (!activeTexture)
      return;
    activeTexture.usageCount--;
    if (activeTexture.usageCount === 0) {
      if (activeTexture.texture) {
        this._cleanUp(activeTexture);
      } else {
        activeTexture.promise.then((texture) => {
          activeTexture.texture = texture;
          this._cleanUp(activeTexture);
        }).catch(() => {
          (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_13__.warn)("HTMLTextSystem: Failed to clean texture");
        });
      }
      this._activeTextures[textKey] = null;
    }
  }
  _cleanUp(activeTexture) {
    _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_14__.TexturePool.returnTexture(activeTexture.texture);
    activeTexture.texture.source.resource = null;
    activeTexture.texture.source.uploadMethodId = "unknown";
  }
  getReferenceCount(textKey) {
    return this._activeTextures[textKey].usageCount;
  }
  destroy() {
    this._activeTextures = null;
  }
}
/** @ignore */
HTMLTextSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_15__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_15__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_15__.ExtensionType.CanvasSystem
  ],
  name: "htmlText"
};
HTMLTextSystem.defaultFontOptions = {
  fontFamily: "Arial",
  fontStyle: "normal",
  fontWeight: "normal"
};


//# sourceMappingURL=HTMLTextSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractFontFamilies: () => (/* binding */ extractFontFamilies)
/* harmony export */ });

function extractFontFamilies(text, style) {
  const fontFamily = style.fontFamily;
  const fontFamilies = [];
  const dedupe = {};
  const regex = /font-family:([^;"\s]+)/g;
  const matches = text.match(regex);
  function addFontFamily(fontFamily2) {
    if (!dedupe[fontFamily2]) {
      fontFamilies.push(fontFamily2);
      dedupe[fontFamily2] = true;
    }
  }
  if (Array.isArray(fontFamily)) {
    for (let i = 0; i < fontFamily.length; i++) {
      addFontFamily(fontFamily[i]);
    }
  } else {
    addFontFamily(fontFamily);
  }
  if (matches) {
    matches.forEach((match) => {
      const fontFamily2 = match.split(":")[1].trim();
      addFontFamily(fontFamily2);
    });
  }
  for (const i in style.tagStyles) {
    const fontFamily2 = style.tagStyles[i].fontFamily;
    addFontFamily(fontFamily2);
  }
  return fontFamilies;
}


//# sourceMappingURL=extractFontFamilies.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FontStylePromiseCache: () => (/* binding */ FontStylePromiseCache),
/* harmony export */   getFontCss: () => (/* binding */ getFontCss)
/* harmony export */ });
/* harmony import */ var _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../assets/cache/Cache.mjs */ "./node_modules/pixi.js/lib/assets/cache/Cache.mjs");
/* harmony import */ var _loadFontCSS_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadFontCSS.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs");



"use strict";
const FontStylePromiseCache = /* @__PURE__ */ new Map();
async function getFontCss(fontFamilies, style, defaultOptions) {
  const fontPromises = fontFamilies.filter((fontFamily) => _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {
    if (!FontStylePromiseCache.has(fontFamily)) {
      const { url } = _assets_cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache.get(`${fontFamily}-and-url`);
      if (i === 0) {
        FontStylePromiseCache.set(fontFamily, (0,_loadFontCSS_mjs__WEBPACK_IMPORTED_MODULE_1__.loadFontCSS)({
          fontWeight: style.fontWeight,
          fontStyle: style.fontStyle,
          fontFamily
        }, url));
      } else {
        FontStylePromiseCache.set(fontFamily, (0,_loadFontCSS_mjs__WEBPACK_IMPORTED_MODULE_1__.loadFontCSS)({
          fontWeight: defaultOptions.fontWeight,
          fontStyle: defaultOptions.fontStyle,
          fontFamily
        }, url));
      }
    }
    return FontStylePromiseCache.get(fontFamily);
  });
  return (await Promise.all(fontPromises)).join("\n");
}


//# sourceMappingURL=getFontCss.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSVGUrl: () => (/* binding */ getSVGUrl)
/* harmony export */ });

function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
  const { domElement, styleElement, svgRoot } = htmlTextData;
  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
  styleElement.textContent = fontCSS;
  const { width, height } = htmlTextData.image;
  svgRoot.setAttribute("width", width.toString());
  svgRoot.setAttribute("height", height.toString());
  return new XMLSerializer().serializeToString(svgRoot);
}


//# sourceMappingURL=getSVGUrl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTemporaryCanvasFromImage: () => (/* binding */ getTemporaryCanvasFromImage)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/CanvasPool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");


"use strict";
function getTemporaryCanvasFromImage(image, resolution) {
  const canvasAndContext = _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_0__.CanvasPool.getOptimalCanvasAndContext(
    image.width,
    image.height,
    resolution
  );
  const { context } = canvasAndContext;
  context.clearRect(0, 0, image.width, image.height);
  context.drawImage(image, 0, 0);
  return canvasAndContext;
}


//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadFontAsBase64: () => (/* binding */ loadFontAsBase64)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
async function loadFontAsBase64(url) {
  const response = await _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const reader = new FileReader();
  const dataSrc = await new Promise((resolve, reject) => {
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
  return dataSrc;
}


//# sourceMappingURL=loadFontAsBase64.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadFontCSS: () => (/* binding */ loadFontCSS)
/* harmony export */ });
/* harmony import */ var _loadFontAsBase64_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadFontAsBase64.mjs */ "./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs");


"use strict";
async function loadFontCSS(style, url) {
  const dataSrc = await (0,_loadFontAsBase64_mjs__WEBPACK_IMPORTED_MODULE_0__.loadFontAsBase64)(url);
  return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
}


//# sourceMappingURL=loadFontCSS.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadSVGImage: () => (/* binding */ loadSVGImage)
/* harmony export */ });

function loadSVGImage(image, url, delay) {
  return new Promise(async (resolve) => {
    if (delay) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    image.onload = () => {
      resolve();
    };
    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
    image.crossOrigin = "anonymous";
  });
}


//# sourceMappingURL=loadSVGImage.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   measureHtmlText: () => (/* binding */ measureHtmlText)
/* harmony export */ });
/* harmony import */ var _HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../HTMLTextRenderData.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs");


"use strict";
let tempHTMLTextRenderData;
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new _HTMLTextRenderData_mjs__WEBPACK_IMPORTED_MODULE_0__.HTMLTextRenderData()));
  const { domElement, styleElement, svgRoot } = htmlTextRenderData;
  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
  if (fontStyleCSS) {
    styleElement.textContent = fontStyleCSS;
  }
  document.body.appendChild(svgRoot);
  const contentBounds = domElement.getBoundingClientRect();
  svgRoot.remove();
  const doublePadding = style.padding * 2;
  return {
    width: contentBounds.width - doublePadding,
    height: contentBounds.height - doublePadding
  };
}


//# sourceMappingURL=measureHtmlText.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   textStyleToCSS: () => (/* binding */ textStyleToCSS)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");


"use strict";
function textStyleToCSS(style) {
  const stroke = style._stroke;
  const fill = style._fill;
  const cssStyleString = [
    `color: ${_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(fill.color).toHex()}`,
    `font-size: ${style.fontSize}px`,
    `font-family: ${style.fontFamily}`,
    `font-weight: ${style.fontWeight}`,
    `font-style: ${style.fontStyle}`,
    `font-variant: ${style.fontVariant}`,
    `letter-spacing: ${style.letterSpacing}px`,
    `text-align: ${style.align}`,
    `padding: ${style.padding}px`,
    `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
    ...style.wordWrap ? [
      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
      `max-width: ${style.wordWrapWidth}px`
    ] : [],
    ...stroke ? [strokeToCSS(stroke)] : [],
    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
    ...style.cssOverrides
  ].join(";");
  const cssStyles = [`div { ${cssStyleString} }`];
  tagStyleToCSS(style.tagStyles, cssStyles);
  return cssStyles.join(" ");
}
function dropShadowToCSS(dropShadowStyle) {
  const color = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
  const position = `${x}px ${y}px`;
  if (dropShadowStyle.blur > 0) {
    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
  }
  return `text-shadow: ${position} ${color}`;
}
function strokeToCSS(stroke) {
  return [
    `-webkit-text-stroke-width: ${stroke.width}px`,
    `-webkit-text-stroke-color: ${_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(stroke.color).toHex()}`,
    `text-stroke-width: ${stroke.width}px`,
    `text-stroke-color: ${_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(stroke.color).toHex()}`,
    "paint-order: stroke"
  ].join(";");
}
const templates = {
  fontSize: `font-size: {{VALUE}}px`,
  fontFamily: `font-family: {{VALUE}}`,
  fontWeight: `font-weight: {{VALUE}}`,
  fontStyle: `font-style: {{VALUE}}`,
  fontVariant: `font-variant: {{VALUE}}`,
  letterSpacing: `letter-spacing: {{VALUE}}px`,
  align: `text-align: {{VALUE}}`,
  padding: `padding: {{VALUE}}px`,
  whiteSpace: `white-space: {{VALUE}}`,
  lineHeight: `line-height: {{VALUE}}px`,
  wordWrapWidth: `max-width: {{VALUE}}px`
};
const transform = {
  fill: (value) => `color: ${_color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(value).toHex()}`,
  breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
  stroke: strokeToCSS,
  dropShadow: dropShadowToCSS
};
function tagStyleToCSS(tagStyles, out) {
  for (const i in tagStyles) {
    const tagStyle = tagStyles[i];
    const cssTagStyle = [];
    for (const j in tagStyle) {
      if (transform[j]) {
        cssTagStyle.push(transform[j](tagStyle[j]));
      } else if (templates[j]) {
        cssTagStyle.push(templates[j].replace("{{VALUE}}", tagStyle[j]));
      }
    }
    out.push(`${i} { ${cssTagStyle.join(";")} }`);
  }
}


//# sourceMappingURL=textStyleToCSS.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/AbstractText.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/AbstractText.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractText: () => (/* binding */ AbstractText),
/* harmony export */   ensureTextOptions: () => (/* binding */ ensureTextOptions)
/* harmony export */ });
/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../maths/point/ObservablePoint.mjs */ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/ViewContainer.mjs */ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs");




"use strict";
class AbstractText extends _view_ViewContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewContainer {
  constructor(options, styleClass) {
    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;
    super({
      ...rest
    });
    this.batched = true;
    this._resolution = null;
    this._autoResolution = true;
    this._didTextUpdate = true;
    this._styleClass = styleClass;
    this.text = text ?? "";
    this.style = style;
    this.resolution = resolution ?? null;
    this.allowChildren = false;
    this._anchor = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor)
      this.anchor = anchor;
    this.roundPixels = roundPixels ?? false;
    if (width !== void 0)
      this.width = width;
    if (height !== void 0)
      this.height = height;
  }
  /**
   * The anchor sets the origin point of the text.
   * The default is `(0,0)`, this means the text's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Text } from 'pixi.js';
   *
   * const text = new Text('hello world');
   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /** Set the copy for the text object. To split a line you can use '\n'. */
  set text(value) {
    value = value.toString();
    if (this._text === value)
      return;
    this._text = value;
    this.onViewUpdate();
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(value) {
    this._autoResolution = value === null;
    this._resolution = value;
    this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * Set the style of the text.
   *
   * Set up an event listener to listen for changes on the style object and mark the text as dirty.
   *
   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
   * @type {
   * text.TextStyle |
   * Partial<text.TextStyle> |
   * text.TextStyleOptions |
   * text.HTMLTextStyle |
   * Partial<text.HTMLTextStyle> |
   * text.HTMLTextStyleOptions
   * }
   */
  set style(style) {
    style || (style = {});
    this._style?.off("update", this.onViewUpdate, this);
    if (style instanceof this._styleClass) {
      this._style = style;
    } else {
      this._style = new this._styleClass(style);
    }
    this._style.on("update", this.onViewUpdate, this);
    this.onViewUpdate();
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(value) {
    this._setWidth(value, this.bounds.width);
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(value) {
    this._setHeight(value, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Text.
   */
  getSize(out) {
    out || (out = {});
    out.width = Math.abs(this.scale.x) * this.bounds.width;
    out.height = Math.abs(this.scale.y) * this.bounds.height;
    return out;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(value, height) {
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    } else {
      height ?? (height = value);
    }
    value !== void 0 && this._setWidth(value, this.bounds.width);
    height !== void 0 && this._setHeight(height, this.bounds.height);
  }
  /**
   * Checks if the text contains the given point.
   * @param point - The point to check
   */
  containsPoint(point) {
    const width = this.bounds.width;
    const height = this.bounds.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x <= x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y <= y1 + height)
        return true;
    }
    return false;
  }
  onViewUpdate() {
    if (!this.didViewUpdate)
      this._didTextUpdate = true;
    super.onViewUpdate();
  }
  _getKey() {
    return `${this.text}:${this._style.styleKey}:${this._resolution}`;
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   * @param {boolean} [options.style=false] - Should it destroy the style of the text
   */
  destroy(options = false) {
    super.destroy(options);
    this.owner = null;
    this._bounds = null;
    this._anchor = null;
    if (typeof options === "boolean" ? options : options?.style) {
      this._style.destroy(options);
    }
    this._style = null;
    this._text = null;
  }
}
function ensureTextOptions(args, name) {
  let options = args[0] ?? {};
  if (typeof options === "string" || args[1]) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.v8_0_0, `use new ${name}({ text: "hi!", style }) instead`);
    options = {
      text: options,
      style: args[1]
    };
  }
  return options;
}


//# sourceMappingURL=AbstractText.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/Text.mjs":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/Text.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Text: () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var _AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractText.mjs */ "./node_modules/pixi.js/lib/scene/text/AbstractText.mjs");
/* harmony import */ var _canvas_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas/CanvasTextMetrics.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs");
/* harmony import */ var _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");




"use strict";
class Text extends _AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractText {
  constructor(...args) {
    const options = (0,_AbstractText_mjs__WEBPACK_IMPORTED_MODULE_0__.ensureTextOptions)(args, "Text");
    super(options, _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.TextStyle);
    this.renderPipeId = "text";
  }
  /** @private */
  updateBounds() {
    const bounds = this._bounds;
    const anchor = this._anchor;
    const canvasMeasurement = _canvas_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_2__.CanvasTextMetrics.measureText(
      this._text,
      this._style
    );
    const { width, height } = canvasMeasurement;
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
}


//# sourceMappingURL=Text.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextStyle: () => (/* binding */ TextStyle)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../graphics/shared/fill/FillGradient.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs");
/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../graphics/shared/fill/FillPattern.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs");
/* harmony import */ var _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graphics/shared/GraphicsContext.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs");
/* harmony import */ var _graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graphics/shared/utils/convertFillInputToFillStyle.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs");
/* harmony import */ var _utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/generateTextStyleKey.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs");









"use strict";
const _TextStyle = class _TextStyle extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(style = {}) {
    super();
    convertV7Tov8Style(style);
    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };
    for (const key in fullStyle) {
      const thisKey = key;
      this[thisKey] = fullStyle[key];
    }
    this.update();
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   * @member {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(value) {
    this._align = value;
    this.update();
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(value) {
    this._breakWords = value;
    this.update();
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(value) {
    if (value !== null && typeof value === "object") {
      this._dropShadow = this._createProxy({ ..._TextStyle.defaultDropShadow, ...value });
    } else {
      this._dropShadow = value ? this._createProxy({ ..._TextStyle.defaultDropShadow }) : null;
    }
    this.update();
  }
  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(value) {
    this._fontFamily = value;
    this.update();
  }
  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(value) {
    if (typeof value === "string") {
      this._fontSize = parseInt(value, 10);
    } else {
      this._fontSize = value;
    }
    this.update();
  }
  /**
   * The font style.
   * @member {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(value) {
    this._fontStyle = value.toLowerCase();
    this.update();
  }
  /**
   * The font variant.
   * @member {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(value) {
    this._fontVariant = value;
    this.update();
  }
  /**
   * The font weight.
   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(value) {
    this._fontWeight = value;
    this.update();
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(value) {
    this._leading = value;
    this.update();
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    this._letterSpacing = value;
    this.update();
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(value) {
    this._lineHeight = value;
    this.update();
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
    this.update();
  }
  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
  get trim() {
    return this._trim;
  }
  set trim(value) {
    this._trim = value;
    this.update();
  }
  /**
   * The baseline of the text that is rendered.
   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(value) {
    this._textBaseline = value;
    this.update();
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @member {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(value) {
    this._whiteSpace = value;
    this.update();
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(value) {
    this._wordWrap = value;
    this.update();
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(value) {
    this._wordWrapWidth = value;
    this.update();
  }
  /**
   * The fill style that will be used to color the text.
   * This can be:
   * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
   * - A hex number like 0xff0000 for red
   * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
   * - A FillGradient for gradient fills
   * - A FillPattern for pattern/texture fills
   *
   * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
   * while gradients at any other angle are spread across the entire text body as a whole.
   * @example
   * // Vertical gradient applied per line
   * const verticalGradient = new FillGradient(0, 0, 0, 1)
   *     .addColorStop(0, 0xff0000)
   *     .addColorStop(1, 0x0000ff);
   *
   * const text = new Text({
   *     text: 'Line 1\nLine 2',
   *     style: { fill: verticalGradient }
   * });
   *
   * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
   * @type {string|number|FillStyle|FillGradient|FillPattern}
   */
  get fill() {
    return this._originalFill;
  }
  set fill(value) {
    if (value === this._originalFill)
      return;
    this._originalFill = value;
    if (this._isFillStyle(value)) {
      this._originalFill = this._createProxy({ ..._graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultFillStyle, ...value }, () => {
        this._fill = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.toFillStyle)(
          { ...this._originalFill },
          _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultFillStyle
        );
      });
    }
    this._fill = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.toFillStyle)(
      value === 0 ? "black" : value,
      _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultFillStyle
    );
    this.update();
  }
  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
  get stroke() {
    return this._originalStroke;
  }
  set stroke(value) {
    if (value === this._originalStroke)
      return;
    this._originalStroke = value;
    if (this._isFillStyle(value)) {
      this._originalStroke = this._createProxy({ ..._graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultStrokeStyle, ...value }, () => {
        this._stroke = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.toStrokeStyle)(
          { ...this._originalStroke },
          _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultStrokeStyle
        );
      });
    }
    this._stroke = (0,_graphics_shared_utils_convertFillInputToFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.toStrokeStyle)(value, _graphics_shared_GraphicsContext_mjs__WEBPACK_IMPORTED_MODULE_1__.GraphicsContext.defaultStrokeStyle);
    this.update();
  }
  _generateKey() {
    this._styleKey = (0,_utils_generateTextStyleKey_mjs__WEBPACK_IMPORTED_MODULE_3__.generateTextStyleKey)(this);
    return this._styleKey;
  }
  update() {
    this._styleKey = null;
    this.emit("update", this);
  }
  /** Resets all properties to the default values */
  reset() {
    const defaultStyle = _TextStyle.defaultTextStyle;
    for (const key in defaultStyle) {
      this[key] = defaultStyle[key];
    }
  }
  get styleKey() {
    return this._styleKey || this._generateKey();
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */
  clone() {
    return new _TextStyle({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      leading: this.leading,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      textBaseline: this.textBaseline,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth
    });
  }
  /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
   */
  destroy(options = false) {
    this.removeAllListeners();
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      if (this._fill?.texture) {
        this._fill.texture.destroy(destroyTextureSource);
      }
      if (this._originalFill?.texture) {
        this._originalFill.texture.destroy(destroyTextureSource);
      }
      if (this._stroke?.texture) {
        this._stroke.texture.destroy(destroyTextureSource);
      }
      if (this._originalStroke?.texture) {
        this._originalStroke.texture.destroy(destroyTextureSource);
      }
    }
    this._fill = null;
    this._stroke = null;
    this.dropShadow = null;
    this._originalStroke = null;
    this._originalFill = null;
  }
  _createProxy(value, cb) {
    return new Proxy(value, {
      set: (target, property, newValue) => {
        target[property] = newValue;
        cb?.(property, newValue);
        this.update();
        return true;
      }
    });
  }
  _isFillStyle(value) {
    return (value ?? null) !== null && !(_color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__.Color.isColorLike(value) || value instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__.FillGradient || value instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__.FillPattern);
  }
};
/** The default drop shadow settings */
_TextStyle.defaultDropShadow = {
  /** Set alpha for the drop shadow */
  alpha: 1,
  /** Set a angle of the drop shadow */
  angle: Math.PI / 6,
  /** Set a shadow blur radius */
  blur: 0,
  /** A fill style to be used on the  e.g., 'red', '#00FF00' */
  color: "black",
  /** Set a distance of the drop shadow */
  distance: 5
};
/** The default text style settings */
_TextStyle.defaultTextStyle = {
  /**
   * See {@link TextStyle.align}
   * @type {'left'|'center'|'right'|'justify'}
   */
  align: "left",
  /** See {@link TextStyle.breakWords} */
  breakWords: false,
  /** See {@link TextStyle.dropShadow} */
  dropShadow: null,
  /**
   * See {@link TextStyle.fill}
   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
   */
  fill: "black",
  /**
   * See {@link TextStyle.fontFamily}
   * @type {string|string[]}
   */
  fontFamily: "Arial",
  /**
   * See {@link TextStyle.fontSize}
   * @type {number|string}
   */
  fontSize: 26,
  /**
   * See {@link TextStyle.fontStyle}
   * @type {'normal'|'italic'|'oblique'}
   */
  fontStyle: "normal",
  /**
   * See {@link TextStyle.fontVariant}
   * @type {'normal'|'small-caps'}
   */
  fontVariant: "normal",
  /**
   * See {@link TextStyle.fontWeight}
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  fontWeight: "normal",
  /** See {@link TextStyle.leading} */
  leading: 0,
  /** See {@link TextStyle.letterSpacing} */
  letterSpacing: 0,
  /** See {@link TextStyle.lineHeight} */
  lineHeight: 0,
  /** See {@link TextStyle.padding} */
  padding: 0,
  /**
   * See {@link TextStyle.stroke}
   * @type {string|number}
   */
  stroke: null,
  /**
   * See {@link TextStyle.textBaseline}
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  textBaseline: "alphabetic",
  /** See {@link TextStyle.trim} */
  trim: false,
  /**
   * See {@link TextStyle.whiteSpace}
   * @type {'normal'|'pre'|'pre-line'}
   */
  whiteSpace: "pre",
  /** See {@link TextStyle.wordWrap} */
  wordWrap: false,
  /** See {@link TextStyle.wordWrapWidth} */
  wordWrapWidth: 100
};
let TextStyle = _TextStyle;
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
    const defaults = TextStyle.defaultDropShadow;
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
      angle: oldStyle.dropShadowAngle ?? defaults.angle,
      blur: oldStyle.dropShadowBlur ?? defaults.blur,
      color: oldStyle.dropShadowColor ?? defaults.color,
      distance: oldStyle.dropShadowDistance ?? defaults.distance
    };
  }
  if (oldStyle.strokeThickness !== void 0) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__.v8_0_0, "strokeThickness is now a part of stroke");
    const color = oldStyle.stroke;
    let obj = {};
    if (_color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__.Color.isColorLike(color)) {
      obj.color = color;
    } else if (color instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__.FillGradient || color instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_6__.FillPattern) {
      obj.fill = color;
    } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
      obj = color;
    } else {
      throw new Error("Invalid stroke value.");
    }
    style.stroke = {
      ...obj,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fillGradientStops)) {
    (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__.deprecation)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_7__.v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    let fontSize;
    if (style.fontSize == null) {
      style.fontSize = TextStyle.defaultTextStyle.fontSize;
    } else if (typeof style.fontSize === "string") {
      fontSize = parseInt(style.fontSize, 10);
    } else {
      fontSize = style.fontSize;
    }
    const gradientFill = new _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_5__.FillGradient({
      start: { x: 0, y: 0 },
      end: { x: 0, y: (fontSize || 0) * 1.7 }
    });
    const fills = oldStyle.fillGradientStops.map((color) => _color_Color_mjs__WEBPACK_IMPORTED_MODULE_4__.Color.shared.setValue(color).toNumber());
    fills.forEach((number, index) => {
      const ratio = index / (fills.length - 1);
      gradientFill.addColorStop(ratio, number);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}


//# sourceMappingURL=TextStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasTextMetrics: () => (/* binding */ CanvasTextMetrics)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/fontStringFromTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs");



"use strict";
const contextSettings = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: true
};
const _CanvasTextMetrics = class _CanvasTextMetrics {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getCanvasRenderingContext2D().prototype;
      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */
  static measureText(text = " ", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {
    const textKey = `${text}:${style.styleKey}`;
    if (_CanvasTextMetrics._measurementCache[textKey])
      return _CanvasTextMetrics._measurementCache[textKey];
    const font = (0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.fontStringFromTextStyle)(style);
    const fontProperties = _CanvasTextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context = _CanvasTextMetrics.__context;
    context.font = font;
    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    const strokeWidth = style._stroke?.width || 0;
    let width = maxLineWidth + strokeWidth;
    if (style.dropShadow) {
      width += style.dropShadow.distance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize;
    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadow.distance;
    }
    const measurements = new _CanvasTextMetrics(
      text,
      style,
      width,
      height,
      lines,
      lineWidths,
      lineHeight + style.leading,
      maxLineWidth,
      fontProperties
    );
    return measurements;
  }
  static _measureText(text, letterSpacing, context) {
    let useExperimentalLetterSpacing = false;
    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {
      if (_CanvasTextMetrics.experimentalLetterSpacing) {
        context.letterSpacing = `${letterSpacing}px`;
        context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context.letterSpacing = "0px";
        context.textLetterSpacing = "0px";
      }
    }
    const metrics = context.measureText(text);
    let metricWidth = metrics.width;
    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
    if (metricWidth > 0) {
      if (useExperimentalLetterSpacing) {
        metricWidth -= letterSpacing;
        boundsWidth -= letterSpacing;
      } else {
        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
        metricWidth += val;
        boundsWidth += val;
      }
    }
    return Math.max(metricWidth, boundsWidth);
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {
    const context = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);
    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _CanvasTextMetrics._tokenize(text);
    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i];
      if (_CanvasTextMetrics._isNewline(token)) {
        if (!collapseNewlines) {
          lines += _CanvasTextMetrics._addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _CanvasTextMetrics._addLine(line);
          line = "";
          width = 0;
        }
        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _CanvasTextMetrics.wordWrapSplit(token);
          for (let j = 0; j < characters.length; j++) {
            let char = characters[j];
            let lastChar = char;
            let k = 1;
            while (characters[j + k]) {
              const nextChar = characters[j + k];
              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k++;
            }
            j += k - 1;
            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);
            if (characterWidth + width > wordWrapWidth) {
              lines += _CanvasTextMetrics._addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _CanvasTextMetrics._addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i === tokens.length - 1;
          lines += _CanvasTextMetrics._addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _CanvasTextMetrics._addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _CanvasTextMetrics._addLine(line, false);
    return lines;
  }
  /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static _addLine(line, newLine = true) {
    line = _CanvasTextMetrics._trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static _getFromCache(key, letterSpacing, cache, context) {
    let width = cache[key];
    if (typeof width !== "number") {
      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
      cache[key] = width;
    }
    return width;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static _collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static _collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static _trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i = text.length - 1; i >= 0; i--) {
      const char = text[i];
      if (!_CanvasTextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static _isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static _tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const nextChar = text[i + 1];
      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(token) {
    return _CanvasTextMetrics.graphemeSegmenter(token);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(font) {
    if (_CanvasTextMetrics._fonts[font]) {
      return _CanvasTextMetrics._fonts[font];
    }
    const context = _CanvasTextMetrics._context;
    context.font = font;
    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);
    const properties = {
      ascent: metrics.actualBoundingBoxAscent,
      descent: metrics.actualBoundingBoxDescent,
      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
    };
    _CanvasTextMetrics._fonts[font] = properties;
    return properties;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(font = "") {
    if (font) {
      delete _CanvasTextMetrics._fonts[font];
    } else {
      _CanvasTextMetrics._fonts = {};
    }
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!_CanvasTextMetrics.__canvas) {
      let canvas;
      try {
        const c = new OffscreenCanvas(0, 0);
        const context = c.getContext("2d", contextSettings);
        if (context?.measureText) {
          _CanvasTextMetrics.__canvas = c;
          return c;
        }
        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().createCanvas();
      } catch (_cx) {
        canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().createCanvas();
      }
      canvas.width = canvas.height = 10;
      _CanvasTextMetrics.__canvas = canvas;
    }
    return _CanvasTextMetrics.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    if (!_CanvasTextMetrics.__context) {
      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _CanvasTextMetrics.__context;
  }
};
/**
 * String used for calculate font metrics.
 * These characters are all tall to help calculate the height required for text.
 */
_CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
/** Baseline symbol for calculate font metrics. */
_CanvasTextMetrics.BASELINE_SYMBOL = "M";
/** Baseline multiplier for calculate font metrics. */
_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
/** Height multiplier for setting height of canvas to calculate font metrics. */
_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
/**
 * A Unicode "character", or "grapheme cluster", can be composed of multiple Unicode code points,
 * such as letters with diacritical marks (e.g. `'\u0065\u0301'`, letter e with acute)
 * or emojis with modifiers (e.g. `'\uD83E\uDDD1\u200D\uD83D\uDCBB'`, technologist).
 * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,
 * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.
 * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),
 * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}
 * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be
 * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.
 */
_CanvasTextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter === "function") {
    const segmenter = new Intl.Segmenter();
    return (s) => [...segmenter.segment(s)].map((x) => x.segment);
  }
  return (s) => [...s];
})();
/**
 * New rendering behavior for letter-spacing which uses Chrome's new native API. This will
 * lead to more accurate letter-spacing results because it does not try to manually draw
 * each character. However, this Chrome API is experimental and may not serve all cases yet.
 * @see TextMetrics.experimentalLetterSpacingSupported
 */
_CanvasTextMetrics.experimentalLetterSpacing = false;
/** Cache of {@see TextMetrics.FontMetrics} objects. */
_CanvasTextMetrics._fonts = {};
/** Cache of new line chars. */
_CanvasTextMetrics._newlines = [
  10,
  // line feed
  13
  // carriage return
];
/** Cache of breaking spaces. */
_CanvasTextMetrics._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
_CanvasTextMetrics._measurementCache = {};
let CanvasTextMetrics = _CanvasTextMetrics;


//# sourceMappingURL=CanvasTextMetrics.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasTextPipe: () => (/* binding */ CanvasTextPipe)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/pool/PoolGroup.mjs */ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs");
/* harmony import */ var _sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../sprite/BatchableSprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs");
/* harmony import */ var _utils_updateTextBounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/updateTextBounds.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs");





"use strict";
class CanvasTextPipe {
  constructor(renderer) {
    this._gpuText = /* @__PURE__ */ Object.create(null);
    this._destroyRenderableBound = this.destroyRenderable.bind(this);
    this._renderer = renderer;
    this._renderer.runners.resolutionChange.add(this);
    this._renderer.renderableGC.addManagedHash(this, "_gpuText");
  }
  resolutionChange() {
    for (const i in this._gpuText) {
      const gpuText = this._gpuText[i];
      if (!gpuText)
        continue;
      const text = gpuText.batchableSprite.renderable;
      if (text._autoResolution) {
        text._resolution = this._renderer.resolution;
        text.onViewUpdate();
      }
    }
  }
  validateRenderable(text) {
    const gpuText = this._getGpuText(text);
    const newKey = text._getKey();
    if (gpuText.currentKey !== newKey) {
      return true;
    }
    return false;
  }
  addRenderable(text, instructionSet) {
    const gpuText = this._getGpuText(text);
    const batchableSprite = gpuText.batchableSprite;
    if (text._didTextUpdate) {
      this._updateText(text);
    }
    this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
  }
  updateRenderable(text) {
    const gpuText = this._getGpuText(text);
    const batchableSprite = gpuText.batchableSprite;
    if (text._didTextUpdate) {
      this._updateText(text);
    }
    batchableSprite._batcher.updateElement(batchableSprite);
  }
  destroyRenderable(text) {
    text.off("destroyed", this._destroyRenderableBound);
    this._destroyRenderableById(text.uid);
  }
  _destroyRenderableById(textUid) {
    const gpuText = this._gpuText[textUid];
    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
    _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.return(gpuText.batchableSprite);
    this._gpuText[textUid] = null;
  }
  _updateText(text) {
    const newKey = text._getKey();
    const gpuText = this._getGpuText(text);
    const batchableSprite = gpuText.batchableSprite;
    if (gpuText.currentKey !== newKey) {
      this._updateGpuText(text);
    }
    text._didTextUpdate = false;
    (0,_utils_updateTextBounds_mjs__WEBPACK_IMPORTED_MODULE_1__.updateTextBounds)(batchableSprite, text);
  }
  _updateGpuText(text) {
    const gpuText = this._getGpuText(text);
    const batchableSprite = gpuText.batchableSprite;
    if (gpuText.texture) {
      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
    }
    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);
    gpuText.currentKey = text._getKey();
    batchableSprite.texture = gpuText.texture;
  }
  _getGpuText(text) {
    return this._gpuText[text.uid] || this.initGpuText(text);
  }
  initGpuText(text) {
    const gpuTextData = {
      texture: null,
      currentKey: "--",
      batchableSprite: _utils_pool_PoolGroup_mjs__WEBPACK_IMPORTED_MODULE_0__.BigPool.get(_sprite_BatchableSprite_mjs__WEBPACK_IMPORTED_MODULE_2__.BatchableSprite)
    };
    gpuTextData.batchableSprite.renderable = text;
    gpuTextData.batchableSprite.transform = text.groupTransform;
    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;
    this._gpuText[text.uid] = gpuTextData;
    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
    this._updateText(text);
    text.on("destroyed", this._destroyRenderableBound);
    return gpuTextData;
  }
  destroy() {
    for (const i in this._gpuText) {
      this._destroyRenderableById(i);
    }
    this._gpuText = null;
    this._renderer = null;
  }
}
/** @ignore */
CanvasTextPipe.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGLPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.WebGPUPipes,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_3__.ExtensionType.CanvasPipes
  ],
  name: "text"
};


//# sourceMappingURL=CanvasTextPipe.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasTextSystem: () => (/* binding */ CanvasTextSystem)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../maths/misc/pow2.mjs */ "./node_modules/pixi.js/lib/maths/misc/pow2.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/CanvasPool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _utils_canvas_getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../utils/canvas/getCanvasBoundingBox.mjs */ "./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs");
/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/logging/deprecation.mjs */ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs");
/* harmony import */ var _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");
/* harmony import */ var _utils_getPo2TextureFromSource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getPo2TextureFromSource.mjs */ "./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs");
/* harmony import */ var _CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasTextMetrics.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs");
/* harmony import */ var _utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/fontStringFromTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs");
/* harmony import */ var _utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/getCanvasFillStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs");













"use strict";
class CanvasTextSystem {
  constructor(_renderer) {
    this._activeTextures = {};
    this._renderer = _renderer;
  }
  getTextureSize(text, resolution, style) {
    const measured = _CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_0__.CanvasTextMetrics.measureText(text || " ", style);
    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
    width = Math.ceil(width - 1e-6);
    height = Math.ceil(height - 1e-6);
    width = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(width);
    height = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(height);
    return { width, height };
  }
  getTexture(options, resolution, style, _textKey) {
    if (typeof options === "string") {
      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
      options = {
        text: options,
        style,
        resolution
      };
    }
    if (!(options.style instanceof _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.TextStyle)) {
      options.style = new _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.TextStyle(options.style);
    }
    const { texture, canvasAndContext } = this.createTextureAndCanvas(
      options
    );
    this._renderer.texture.initSource(texture._source);
    _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_4__.CanvasPool.returnCanvasAndContext(canvasAndContext);
    return texture;
  }
  createTextureAndCanvas(options) {
    const { text, style } = options;
    const resolution = options.resolution ?? this._renderer.resolution;
    const measured = _CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_0__.CanvasTextMetrics.measureText(text || " ", style);
    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
    const canvasAndContext = _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_4__.CanvasPool.getOptimalCanvasAndContext(width, height);
    const { canvas } = canvasAndContext;
    this.renderTextToCanvas(text, style, resolution, canvasAndContext);
    const texture = (0,_utils_getPo2TextureFromSource_mjs__WEBPACK_IMPORTED_MODULE_5__.getPo2TextureFromSource)(canvas, width, height, resolution);
    if (style.trim) {
      const trimmed = (0,_utils_canvas_getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_6__.getCanvasBoundingBox)(canvas, resolution);
      texture.frame.copyFrom(trimmed);
      texture.updateUvs();
    }
    return { texture, canvasAndContext };
  }
  getManagedTexture(text) {
    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
    const textKey = text._getKey();
    if (this._activeTextures[textKey]) {
      this._increaseReferenceCount(textKey);
      return this._activeTextures[textKey].texture;
    }
    const { texture, canvasAndContext } = this.createTextureAndCanvas(text);
    this._activeTextures[textKey] = {
      canvasAndContext,
      texture,
      usageCount: 1
    };
    return texture;
  }
  _increaseReferenceCount(textKey) {
    this._activeTextures[textKey].usageCount++;
  }
  /**
   * Returns a texture that was created wit the above `getTexture` function.
   * Handy if you are done with a texture and want to return it to the pool.
   * @param texture - The texture to be returned.
   */
  returnTexture(texture) {
    const source = texture.source;
    source.resource = null;
    source.uploadMethodId = "unknown";
    source.alphaMode = "no-premultiply-alpha";
    _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_7__.TexturePool.returnTexture(texture);
  }
  decreaseReferenceCount(textKey) {
    const activeTexture = this._activeTextures[textKey];
    activeTexture.usageCount--;
    if (activeTexture.usageCount === 0) {
      _rendering_renderers_shared_texture_CanvasPool_mjs__WEBPACK_IMPORTED_MODULE_4__.CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
      this.returnTexture(activeTexture.texture);
      this._activeTextures[textKey] = null;
    }
  }
  getReferenceCount(textKey) {
    return this._activeTextures[textKey].usageCount;
  }
  /**
   * Renders text to its canvas, and updates its texture.
   *
   * By default this is used internally to ensure the texture is correct before rendering,
   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
   * and then shared across multiple Sprites.
   * @param text
   * @param style
   * @param resolution
   * @param canvasAndContext
   */
  renderTextToCanvas(text, style, resolution, canvasAndContext) {
    const { canvas, context } = canvasAndContext;
    const font = (0,_utils_fontStringFromTextStyle_mjs__WEBPACK_IMPORTED_MODULE_8__.fontStringFromTextStyle)(style);
    const measured = _CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_0__.CanvasTextMetrics.measureText(text || " ", style);
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    const height = canvas.height;
    context.resetTransform();
    context.scale(resolution, resolution);
    context.textBaseline = style.textBaseline;
    if (style._stroke?.width) {
      const strokeStyle = style._stroke;
      context.lineWidth = strokeStyle.width;
      context.miterLimit = strokeStyle.miterLimit;
      context.lineJoin = strokeStyle.join;
      context.lineCap = strokeStyle.cap;
    }
    context.font = font;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i = 0; i < passesCount; ++i) {
      const isShadowPass = style.dropShadow && i === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * resolution;
      if (isShadowPass) {
        context.fillStyle = "black";
        context.strokeStyle = "black";
        const shadowOptions = style.dropShadow;
        const dropShadowColor = shadowOptions.color;
        const dropShadowAlpha = shadowOptions.alpha;
        context.shadowColor = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_9__.Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
        const dropShadowBlur = shadowOptions.blur * resolution;
        const dropShadowDistance = shadowOptions.distance * resolution;
        context.shadowBlur = dropShadowBlur;
        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context.fillStyle = style._fill ? (0,_utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_10__.getCanvasFillStyle)(style._fill, context, measured) : null;
        if (style._stroke?.width) {
          const padding = style._stroke.width * style._stroke.alignment;
          context.strokeStyle = (0,_utils_getCanvasFillStyle_mjs__WEBPACK_IMPORTED_MODULE_10__.getCanvasFillStyle)(style._stroke, context, measured, padding);
        }
        context.shadowColor = "black";
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      const strokeWidth = style._stroke?.width ?? 0;
      for (let i2 = 0; i2 < lines.length; i2++) {
        linePositionX = strokeWidth / 2;
        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i2];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
        }
        if (style._stroke?.width) {
          this._drawLetterSpacing(
            lines[i2],
            style,
            canvasAndContext,
            linePositionX + style.padding,
            linePositionY + style.padding - dsOffsetText,
            true
          );
        }
        if (style._fill !== void 0) {
          this._drawLetterSpacing(
            lines[i2],
            style,
            canvasAndContext,
            linePositionX + style.padding,
            linePositionY + style.padding - dsOffsetText
          );
        }
      }
    }
  }
  /**
   * Render the text with letter-spacing.
   * @param text - The text to draw
   * @param style
   * @param canvasAndContext
   * @param x - Horizontal position to draw the text
   * @param y - Vertical position to draw the text
   * @param isStroke - Is this drawing for the outside stroke of the
   *  text? If not, it's for the inside fill
   */
  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {
    const { context } = canvasAndContext;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_0__.CanvasTextMetrics.experimentalLetterSpacingSupported) {
      if (_CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_0__.CanvasTextMetrics.experimentalLetterSpacing) {
        context.letterSpacing = `${letterSpacing}px`;
        context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context.letterSpacing = "0px";
        context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        context.strokeText(text, x, y);
      } else {
        context.fillText(text, x, y);
      }
      return;
    }
    let currentPosition = x;
    const stringArray = _CanvasTextMetrics_mjs__WEBPACK_IMPORTED_MODULE_0__.CanvasTextMetrics.graphemeSegmenter(text);
    let previousWidth = context.measureText(text).width;
    let currentWidth = 0;
    for (let i = 0; i < stringArray.length; ++i) {
      const currentChar = stringArray[i];
      if (isStroke) {
        context.strokeText(currentChar, currentPosition, y);
      } else {
        context.fillText(currentChar, currentPosition, y);
      }
      let textStr = "";
      for (let j = i + 1; j < stringArray.length; ++j) {
        textStr += stringArray[j];
      }
      currentWidth = context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  destroy() {
    this._activeTextures = null;
  }
}
/** @ignore */
CanvasTextSystem.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__.ExtensionType.WebGPUSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_11__.ExtensionType.CanvasSystem
  ],
  name: "canvasText"
};


//# sourceMappingURL=CanvasTextSystem.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fontStringFromTextStyle: () => (/* binding */ fontStringFromTextStyle)
/* harmony export */ });

const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i = fontFamilies.length - 1; i >= 0; i--) {
    let fontFamily = fontFamilies[i].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}


//# sourceMappingURL=fontStringFromTextStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCanvasFillStyle: () => (/* binding */ getCanvasFillStyle)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../utils/logging/warn.mjs */ "./node_modules/pixi.js/lib/utils/logging/warn.mjs");
/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../graphics/shared/fill/FillGradient.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs");
/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../graphics/shared/fill/FillPattern.mjs */ "./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs");







"use strict";
const PRECISION = 1e5;
function getCanvasFillStyle(fillStyle, context, textMetrics, padding = 0) {
  if (fillStyle.texture === _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE && !fillStyle.fill) {
    return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
  } else if (!fillStyle.fill) {
    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix = fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix.shared);
    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
    pattern.setTransform(tempMatrix);
    return pattern;
  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__.FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix = fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix.shared);
    tempMatrix.scale(
      fillPattern.texture.frame.width,
      fillPattern.texture.frame.height
    );
    pattern.setTransform(tempMatrix);
    return pattern;
  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__.FillGradient) {
    const fillGradient = fillStyle.fill;
    const isLinear = fillGradient.type === "linear";
    const isLocal = fillGradient.textureSpace === "local";
    let width = 1;
    let height = 1;
    if (isLocal && textMetrics) {
      width = textMetrics.width + padding;
      height = textMetrics.height + padding;
    }
    let gradient;
    let isNearlyVertical = false;
    if (isLinear) {
      const { start, end } = fillGradient;
      gradient = context.createLinearGradient(
        start.x * width,
        start.y * height,
        end.x * width,
        end.y * height
      );
      isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
    } else {
      const { center, innerRadius, outerCenter, outerRadius } = fillGradient;
      gradient = context.createRadialGradient(
        center.x * width,
        center.y * height,
        innerRadius * width,
        outerCenter.x * width,
        outerCenter.y * height,
        outerRadius * width
      );
    }
    if (isNearlyVertical && isLocal && textMetrics) {
      const ratio = textMetrics.lineHeight / height;
      for (let i = 0; i < textMetrics.lines.length; i++) {
        const start = (i * textMetrics.lineHeight + padding / 2) / height;
        fillGradient.colorStops.forEach((stop) => {
          const globalStop = start + stop.offset * ratio;
          gradient.addColorStop(
            // fix to 5 decimal places to avoid floating point precision issues
            Math.floor(globalStop * PRECISION) / PRECISION,
            _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Color.shared.setValue(stop.color).toHex()
          );
        });
      }
    } else {
      fillGradient.colorStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__.Color.shared.setValue(stop.color).toHex());
      });
    }
    return gradient;
  }
  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__.warn)("FillStyle not recognised", fillStyle);
  return "red";
}


//# sourceMappingURL=getCanvasFillStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SdfShader: () => (/* binding */ SdfShader)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../rendering/batcher/gl/utils/maxRecommendedTextures.mjs */ "./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs");
/* harmony import */ var _rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../rendering/high-shader/compileHighShaderToProgram.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/colorBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs");
/* harmony import */ var _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs */ "./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs");
/* harmony import */ var _rendering_renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/Shader.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs");
/* harmony import */ var _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/shared/shader/UniformGroup.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs");
/* harmony import */ var _shader_bits_localUniformMSDFBit_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shader-bits/localUniformMSDFBit.mjs */ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs");
/* harmony import */ var _shader_bits_mSDFBit_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shader-bits/mSDFBit.mjs */ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs");












"use strict";
let gpuProgram;
let glProgram;
class SdfShader extends _rendering_renderers_shared_shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__.Shader {
  constructor() {
    const uniforms = new _rendering_renderers_shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_1__.UniformGroup({
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uTransformMatrix: { value: new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__.Matrix(), type: "mat3x3<f32>" },
      uDistance: { value: 4, type: "f32" },
      uRound: { value: 0, type: "f32" }
    });
    const maxTextures = (0,_rendering_batcher_gl_utils_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_3__.getMaxTexturesPerBatch)();
    gpuProgram ?? (gpuProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.compileHighShaderGpuProgram)({
      name: "sdf-shader",
      bits: [
        _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_5__.colorBit,
        (0,_rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_6__.generateTextureBatchBit)(maxTextures),
        _shader_bits_localUniformMSDFBit_mjs__WEBPACK_IMPORTED_MODULE_7__.localUniformMSDFBit,
        _shader_bits_mSDFBit_mjs__WEBPACK_IMPORTED_MODULE_8__.mSDFBit,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_9__.roundPixelsBit
      ]
    }));
    glProgram ?? (glProgram = (0,_rendering_high_shader_compileHighShaderToProgram_mjs__WEBPACK_IMPORTED_MODULE_4__.compileHighShaderGlProgram)({
      name: "sdf-shader",
      bits: [
        _rendering_high_shader_shader_bits_colorBit_mjs__WEBPACK_IMPORTED_MODULE_5__.colorBitGl,
        (0,_rendering_high_shader_shader_bits_generateTextureBatchBit_mjs__WEBPACK_IMPORTED_MODULE_6__.generateTextureBatchBitGl)(maxTextures),
        _shader_bits_localUniformMSDFBit_mjs__WEBPACK_IMPORTED_MODULE_7__.localUniformMSDFBitGl,
        _shader_bits_mSDFBit_mjs__WEBPACK_IMPORTED_MODULE_8__.mSDFBitGl,
        _rendering_high_shader_shader_bits_roundPixelsBit_mjs__WEBPACK_IMPORTED_MODULE_9__.roundPixelsBitGl
      ]
    }));
    super({
      glProgram,
      gpuProgram,
      resources: {
        localUniforms: uniforms,
        batchSamplers: (0,_rendering_renderers_gl_shader_getBatchSamplersUniformGroup_mjs__WEBPACK_IMPORTED_MODULE_10__.getBatchSamplersUniformGroup)(maxTextures)
      }
    });
  }
}


//# sourceMappingURL=SdfShader.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   localUniformMSDFBit: () => (/* binding */ localUniformMSDFBit),
/* harmony export */   localUniformMSDFBitGl: () => (/* binding */ localUniformMSDFBitGl)
/* harmony export */ });

const localUniformMSDFBit = {
  name: "local-uniform-msdf-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
    ),
    end: (
      /* wgsl */
      `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
    ),
    main: (
      /* wgsl */
      ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
    )
  }
};
const localUniformMSDFBitGl = {
  name: "local-uniform-msdf-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
    ),
    end: (
      /* glsl */
      `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
            uniform float uDistance;
         `
    ),
    main: (
      /* glsl */
      ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
    )
  }
};


//# sourceMappingURL=localUniformMSDFBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mSDFBit: () => (/* binding */ mSDFBit),
/* harmony export */   mSDFBitGl: () => (/* binding */ mSDFBitGl)
/* harmony export */ });

const mSDFBit = {
  name: "msdf-bit",
  fragment: {
    header: (
      /* wgsl */
      `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
    )
  }
};
const mSDFBitGl = {
  name: "msdf-bit",
  fragment: {
    header: (
      /* glsl */
      `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
    )
  }
};


//# sourceMappingURL=mSDFBit.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ensureTextStyle: () => (/* binding */ ensureTextStyle)
/* harmony export */ });
/* harmony import */ var _text_html_HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../text-html/HTMLTextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs");
/* harmony import */ var _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../TextStyle.mjs */ "./node_modules/pixi.js/lib/scene/text/TextStyle.mjs");



"use strict";
function ensureTextStyle(renderMode, style) {
  if (style instanceof _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_0__.TextStyle || style instanceof _text_html_HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.HTMLTextStyle) {
    return style;
  }
  return renderMode === "html" ? new _text_html_HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.HTMLTextStyle(style) : new _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_0__.TextStyle(style);
}


//# sourceMappingURL=ensureTextStyle.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateTextStyleKey: () => (/* binding */ generateTextStyleKey)
/* harmony export */ });
/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../color/Color.mjs */ "./node_modules/pixi.js/lib/color/Color.mjs");


"use strict";
const valuesToIterateForKeys = [
  "align",
  "breakWords",
  "cssOverrides",
  "fontVariant",
  "fontWeight",
  "leading",
  "letterSpacing",
  "lineHeight",
  "padding",
  "textBaseline",
  "trim",
  "whiteSpace",
  "wordWrap",
  "wordWrapWidth",
  "fontFamily",
  "fontStyle",
  "fontSize"
];
function generateTextStyleKey(style) {
  const key = [];
  let index = 0;
  for (let i = 0; i < valuesToIterateForKeys.length; i++) {
    const prop = `_${valuesToIterateForKeys[i]}`;
    key[index++] = style[prop];
  }
  index = addFillStyleKey(style._fill, key, index);
  index = addStokeStyleKey(style._stroke, key, index);
  index = addDropShadowKey(style.dropShadow, key, index);
  return key.join("-");
}
function addFillStyleKey(fillStyle, key, index) {
  if (!fillStyle)
    return index;
  key[index++] = fillStyle.color;
  key[index++] = fillStyle.alpha;
  key[index++] = fillStyle.fill?.styleKey;
  return index;
}
function addStokeStyleKey(strokeStyle, key, index) {
  if (!strokeStyle)
    return index;
  index = addFillStyleKey(strokeStyle, key, index);
  key[index++] = strokeStyle.width;
  key[index++] = strokeStyle.alignment;
  key[index++] = strokeStyle.cap;
  key[index++] = strokeStyle.join;
  key[index++] = strokeStyle.miterLimit;
  return index;
}
function addDropShadowKey(dropShadow, key, index) {
  if (!dropShadow)
    return index;
  key[index++] = dropShadow.alpha;
  key[index++] = dropShadow.angle;
  key[index++] = dropShadow.blur;
  key[index++] = dropShadow.distance;
  key[index++] = _color_Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(dropShadow.color).toNumber();
  return index;
}


//# sourceMappingURL=generateTextStyleKey.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPo2TextureFromSource: () => (/* binding */ getPo2TextureFromSource)
/* harmony export */ });
/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../rendering/renderers/shared/texture/TexturePool.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs");
/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");



"use strict";
const tempBounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__.Bounds();
function getPo2TextureFromSource(image, width, height, resolution) {
  const bounds = tempBounds;
  bounds.minX = 0;
  bounds.minY = 0;
  bounds.maxX = image.width / resolution | 0;
  bounds.maxY = image.height / resolution | 0;
  const texture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__.TexturePool.getOptimalTexture(
    bounds.width,
    bounds.height,
    resolution,
    false
  );
  texture.source.uploadMethodId = "image";
  texture.source.resource = image;
  texture.source.alphaMode = "premultiply-alpha-on-upload";
  texture.frame.width = width / resolution;
  texture.frame.height = height / resolution;
  texture.source.emit("update", texture.source);
  texture.updateUvs();
  return texture;
}


//# sourceMappingURL=getPo2TextureFromSource.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateTextBounds: () => (/* binding */ updateTextBounds)
/* harmony export */ });
/* harmony import */ var _utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/data/updateQuadBounds.mjs */ "./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs");


"use strict";
function updateTextBounds(batchableSprite, text) {
  const { texture, bounds } = batchableSprite;
  (0,_utils_data_updateQuadBounds_mjs__WEBPACK_IMPORTED_MODULE_0__.updateQuadBounds)(bounds, text._anchor, texture);
  const padding = text._style.padding;
  bounds.minX -= padding;
  bounds.minY -= padding;
  bounds.maxX -= padding;
  bounds.maxY -= padding;
}


//# sourceMappingURL=updateTextBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ViewContainer: () => (/* binding */ ViewContainer)
/* harmony export */ });
/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../container/bounds/Bounds.mjs */ "./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs");
/* harmony import */ var _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Container.mjs */ "./node_modules/pixi.js/lib/scene/container/Container.mjs");



"use strict";
class ViewContainer extends _container_Container_mjs__WEBPACK_IMPORTED_MODULE_0__.Container {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(options) {
    super(options);
    /** @private */
    this.canBundle = true;
    /** @private */
    this.allowChildren = false;
    /** @private */
    this._roundPixels = 0;
    /** @private */
    this._lastUsed = -1;
    this._bounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds(0, 1, 0, 0);
    this._boundsDirty = true;
  }
  /**
   * The local bounds of the view.
   * @type {rendering.Bounds}
   */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    this.updateBounds();
    this._boundsDirty = false;
    return this._bounds;
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @type {boolean}
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(value) {
    this._roundPixels = value ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(point) {
    const bounds = this.bounds;
    const { x, y } = point;
    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;
  }
  /** @private */
  onViewUpdate() {
    this._didViewChangeTick++;
    this._boundsDirty = true;
    if (this.didViewUpdate)
      return;
    this.didViewUpdate = true;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.onChildViewUpdate(this);
    }
  }
  destroy(options) {
    super.destroy(options);
    this._bounds = null;
  }
  collectRenderablesSimple(instructionSet, renderer, currentLayer) {
    const { renderPipes, renderableGC } = renderer;
    renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);
    const rp = renderPipes;
    rp[this.renderPipeId].addRenderable(this, instructionSet);
    renderableGC.addRenderable(this);
    this.didViewUpdate = false;
    const children = this.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      children[i].collectRenderables(instructionSet, renderer, currentLayer);
    }
  }
}


//# sourceMappingURL=ViewContainer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Spritesheet: () => (/* binding */ Spritesheet)
/* harmony export */ });
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");



"use strict";
const _Spritesheet = class _Spritesheet {
  /**
   * @param texture - Reference to the source BaseTexture object.
   * @param {object} data - Spritesheet image data.
   */
  constructor(texture, data) {
    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */
    this.linkedSheets = [];
    this._texture = texture instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture ? texture : null;
    this.textureSource = texture.source;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const metaResolution = parseFloat(data.meta.scale);
    if (metaResolution) {
      this.resolution = metaResolution;
      texture.source.resolution = this.resolution;
    } else {
      this.resolution = texture.source._resolution;
    }
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i = this._frameKeys[frameIndex];
      const data = this._frames[i];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(
          0,
          0,
          Math.floor(sourceSize.w) / this.resolution,
          Math.floor(sourceSize.h) / this.resolution
        );
        if (data.rotated) {
          frame = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(
            Math.floor(rect.x) / this.resolution,
            Math.floor(rect.y) / this.resolution,
            Math.floor(rect.h) / this.resolution,
            Math.floor(rect.w) / this.resolution
          );
        } else {
          frame = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(
            Math.floor(rect.x) / this.resolution,
            Math.floor(rect.y) / this.resolution,
            Math.floor(rect.w) / this.resolution,
            Math.floor(rect.h) / this.resolution
          );
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(
            Math.floor(data.spriteSourceSize.x) / this.resolution,
            Math.floor(data.spriteSourceSize.y) / this.resolution,
            Math.floor(rect.w) / this.resolution,
            Math.floor(rect.h) / this.resolution
          );
        }
        this.textures[i] = new _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture({
          source: this.textureSource,
          frame,
          orig,
          trim,
          rotate: data.rotated ? 2 : 0,
          defaultAnchor: data.anchor,
          defaultBorders: data.borders,
          label: i.toString()
        });
      }
      frameIndex++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i = 0; i < animations[animName].length; i++) {
        const frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(destroyBase = false) {
    for (const i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.textureSource.destroy();
    }
    this._texture = null;
    this.textureSource = null;
    this.linkedSheets = [];
  }
};
/** The maximum number of Textures to build per process. */
_Spritesheet.BATCH_SIZE = 1e3;
let Spritesheet = _Spritesheet;


//# sourceMappingURL=Spritesheet.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/spritesheet/init.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/spritesheet/init.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _spritesheetAsset_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spritesheetAsset.mjs */ "./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs");



"use strict";
_extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_0__.extensions.add(_spritesheetAsset_mjs__WEBPACK_IMPORTED_MODULE_1__.spritesheetAsset);
//# sourceMappingURL=init.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   spritesheetAsset: () => (/* binding */ spritesheetAsset)
/* harmony export */ });
/* harmony import */ var _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../assets/loader/parsers/LoaderParser.mjs */ "./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../assets/resolver/Resolver.mjs */ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs");
/* harmony import */ var _assets_utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../assets/utils/copySearchParams.mjs */ "./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs");
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rendering/renderers/shared/texture/Texture.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs");
/* harmony import */ var _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/path.mjs */ "./node_modules/pixi.js/lib/utils/path.mjs");
/* harmony import */ var _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Spritesheet.mjs */ "./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs");








"use strict";
const validImages = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__.path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (asset) => asset instanceof _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_2__.Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(_assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_3__.Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.LoadParser,
      priority: _assets_loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_4__.LoaderParserPriority.Normal,
      name: "spritesheetLoader"
    },
    async testParse(asset, options) {
      return _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      const {
        texture: imageTexture,
        // if user need to use preloaded texture
        imageFilename,
        // if user need to use custom filename (not from jsonFile.meta.image)
        textureOptions
        // if user need to set texture options on texture
      } = options?.data ?? {};
      let basePath = _utils_path_mjs__WEBPACK_IMPORTED_MODULE_0__.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let texture;
      if (imageTexture instanceof _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_5__.Texture) {
        texture = imageTexture;
      } else {
        const imagePath = (0,_assets_utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_6__.copySearchParams)(basePath + (imageFilename ?? asset.meta.image), options.src);
        const assets = await loader.load([{ src: imagePath, data: textureOptions }]);
        texture = assets[imagePath];
      }
      const spritesheet = new _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_2__.Spritesheet(
        texture.source,
        asset
      );
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if (options.data?.ignoreMultiPack) {
            continue;
          }
          itemUrl = (0,_assets_utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_6__.copySearchParams)(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              textureOptions,
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    async unload(spritesheet, _resolvedAsset, loader) {
      await loader.unload(spritesheet.textureSource._sourceOrigin);
      spritesheet.destroy(false);
    }
  }
};


//# sourceMappingURL=spritesheetAsset.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/ticker/Ticker.mjs":
/*!****************************************************!*\
  !*** ./node_modules/pixi.js/lib/ticker/Ticker.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ticker: () => (/* binding */ Ticker)
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/pixi.js/lib/ticker/const.mjs");
/* harmony import */ var _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TickerListener.mjs */ "./node_modules/pixi.js/lib/ticker/TickerListener.mjs");



"use strict";
const _Ticker = class _Ticker {
  constructor() {
    /**
     * Whether or not this ticker should invoke the method
     * {@link ticker.Ticker#start|start} automatically when a listener is added.
     */
    this.autoStart = false;
    /**
     * Scalar time value from last frame to this frame.
     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}
     * and is scaled with {@link ticker.Ticker#speed|speed}.
     * **Note:** The cap may be exceeded by scaling.
     */
    this.deltaTime = 1;
    /**
     * The last time {@link ticker.Ticker#update|update} was invoked.
     * This value is also reset internally outside of invoking
     * update, but only when a new animation frame is requested.
     * If the platform supports DOMHighResTimeStamp,
     * this value will have a precision of 1 s.
     */
    this.lastTime = -1;
    /**
     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.
     * @example
     * // Scales ticker.deltaTime to what would be
     * // the equivalent of approximately 120 FPS
     * ticker.speed = 2;
     */
    this.speed = 1;
    /**
     * Whether or not this ticker has been started.
     * `true` if {@link ticker.Ticker#start|start} has been called.
     * `false` if {@link ticker.Ticker#stop|Stop} has been called.
     * While `false`, this value may change to `true` in the
     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`
     * and a listener is added.
     */
    this.started = false;
    /** Internal current frame request ID */
    this._requestId = null;
    /**
     * Internal value managed by minFPS property setter and getter.
     * This is the maximum allowed milliseconds between updates.
     */
    this._maxElapsedMS = 100;
    /**
     * Internal value managed by minFPS property setter and getter.
     * This is the minimum allowed milliseconds between updates.
     */
    this._minElapsedMS = 0;
    /** If enabled, deleting is disabled.*/
    this._protected = false;
    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */
    this._lastFrame = -1;
    this._head = new _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_0__.TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  /**
   * Conditionally cancels a pending animation frame.
   * @private
   */
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  add(fn, context, priority = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_0__.TickerListener(fn, context, priority));
  }
  /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  addOnce(fn, context, priority = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_0__.TickerListener(fn, context, priority, true));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */
  remove(fn, context) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  /**
   * Triggers an update. An update entails setting the
   * current {@link ticker.Ticker#elapsedMS|elapsedMS},
   * the current {@link ticker.Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link ticker.Ticker#speed|speed}, which is specific
   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
   * @member {number}
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link ticker.Ticker#update|update}.
   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  /**
   * The system ticker instance used by {@link BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @member {ticker.Ticker}
   * @readonly
   * @static
   */
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
/**
 * Target frames per millisecond.
 * @static
 */
_Ticker.targetFPMS = 0.06;
let Ticker = _Ticker;


//# sourceMappingURL=Ticker.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/ticker/TickerListener.mjs":
/*!************************************************************!*\
  !*** ./node_modules/pixi.js/lib/ticker/TickerListener.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TickerListener: () => (/* binding */ TickerListener)
/* harmony export */ });

class TickerListener {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(fn, context = null, priority = 0, once = false) {
    /** The next item in chain. */
    this.next = null;
    /** The previous item in chain. */
    this.previous = null;
    /** `true` if this listener has been destroyed already. */
    this._destroyed = false;
    this._fn = fn;
    this._context = context;
    this.priority = priority;
    this._once = once;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(fn, context = null) {
    return this._fn === fn && this._context === context;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(ticker) {
    if (this._fn) {
      if (this._context) {
        this._fn.call(this._context, ticker);
      } else {
        this._fn(ticker);
      }
    }
    const redirect = this.next;
    if (this._once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(hard = false) {
    this._destroyed = true;
    this._fn = null;
    this._context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}


//# sourceMappingURL=TickerListener.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/ticker/const.mjs":
/*!***************************************************!*\
  !*** ./node_modules/pixi.js/lib/ticker/const.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UPDATE_PRIORITY: () => (/* binding */ UPDATE_PRIORITY)
/* harmony export */ });

var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   detectVideoAlphaMode: () => (/* binding */ detectVideoAlphaMode)
/* harmony export */ });

let promise;
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}


//# sourceMappingURL=detectVideoAlphaMode.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isMobile.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isMobile.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isMobile: () => (/* binding */ isMobile)
/* harmony export */ });
/* harmony import */ var ismobilejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ismobilejs */ "./node_modules/ismobilejs/esm/index.js");


"use strict";
const isMobileCall = ismobilejs__WEBPACK_IMPORTED_MODULE_0__["default"]["default"] ?? ismobilejs__WEBPACK_IMPORTED_MODULE_0__["default"];
const isMobile = isMobileCall(globalThis.navigator);


//# sourceMappingURL=isMobile.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isSafari.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isSafari.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isSafari: () => (/* binding */ isSafari)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
function isSafari() {
  const { userAgent } = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}


//# sourceMappingURL=isSafari.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isWebGLSupported: () => (/* binding */ isWebGLSupported)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _rendering_renderers_shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rendering/renderers/shared/system/AbstractRenderer.mjs */ "./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs");



"use strict";
let _isWebGLSupported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (_isWebGLSupported !== void 0)
    return _isWebGLSupported;
  _isWebGLSupported = (() => {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? _rendering_renderers_shared_system_AbstractRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().getWebGLRenderingContext()) {
        return false;
      }
      const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_1__.DOMAdapter.get().createCanvas();
      let gl = canvas.getContext("webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        if (loseContext) {
          loseContext.loseContext();
        }
      }
      gl = null;
      return success;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGLSupported;
}


//# sourceMappingURL=isWebGLSupported.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isWebGPUSupported: () => (/* binding */ isWebGPUSupported)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
let _isWebGPUSupported;
async function isWebGPUSupported(options = {}) {
  if (_isWebGPUSupported !== void 0)
    return _isWebGPUSupported;
  _isWebGPUSupported = await (async () => {
    const gpu = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getNavigator().gpu;
    if (!gpu) {
      return false;
    }
    try {
      const adapter = await gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGPUSupported;
}


//# sourceMappingURL=isWebGPUSupported.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   unsafeEvalSupported: () => (/* binding */ unsafeEvalSupported)
/* harmony export */ });

let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (_e) {
    unsafeEval = false;
  }
  return unsafeEval;
}


//# sourceMappingURL=unsafeEvalSupported.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCanvasBoundingBox: () => (/* binding */ getCanvasBoundingBox)
/* harmony export */ });
/* harmony import */ var _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../maths/shapes/Rectangle.mjs */ "./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs");


"use strict";
function checkRow(data, width, y) {
  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x, top, bottom) {
  const stride = 4 * width;
  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas, resolution = 1) {
  const { width, height } = canvas;
  const context = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new _maths_shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_0__.Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
}


//# sourceMappingURL=getCanvasBoundingBox.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/const.mjs":
/*!**************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/const.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATA_URI: () => (/* binding */ DATA_URI),
/* harmony export */   EventEmitter: () => (/* reexport safe */ eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");


"use strict";
const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
const VERSION = "8.9.2";


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ViewableBuffer: () => (/* binding */ ViewableBuffer)
/* harmony export */ });

class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
    this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    if (!this._float64Array) {
      this._float64Array = new Float64Array(this.rawBinaryData);
    }
    return this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    if (!this._bigUint64Array) {
      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
    }
    return this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(type) {
    return this[`${type}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this.uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}


//# sourceMappingURL=ViewableBuffer.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/clean.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/clean.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cleanArray: () => (/* binding */ cleanArray),
/* harmony export */   cleanHash: () => (/* binding */ cleanHash)
/* harmony export */ });

function cleanHash(hash) {
  let clean = false;
  for (const i in hash) {
    if (hash[i] == void 0) {
      clean = true;
      break;
    }
  }
  if (!clean)
    return hash;
  const cleanHash2 = /* @__PURE__ */ Object.create(null);
  for (const i in hash) {
    const value = hash[i];
    if (value) {
      cleanHash2[i] = value;
    }
  }
  return cleanHash2;
}
function cleanArray(arr) {
  let offset = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] == void 0) {
      offset++;
    } else {
      arr[i - offset] = arr[i];
    }
  }
  arr.length -= offset;
  return arr;
}


//# sourceMappingURL=clean.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/removeItems.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/removeItems.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeItems: () => (/* binding */ removeItems)
/* harmony export */ });

function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}


//# sourceMappingURL=removeItems.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/uid.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/uid.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resetUids: () => (/* binding */ resetUids),
/* harmony export */   uid: () => (/* binding */ uid)
/* harmony export */ });

const uidCache = {
  default: -1
};
function uid(name = "default") {
  if (uidCache[name] === void 0) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}
function resetUids() {
  for (const key in uidCache) {
    delete uidCache[key];
  }
}


//# sourceMappingURL=uid.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateQuadBounds: () => (/* binding */ updateQuadBounds)
/* harmony export */ });

function updateQuadBounds(bounds, anchor, texture) {
  const { width, height } = texture.orig;
  const trim = texture.trim;
  if (trim) {
    const sourceWidth = trim.width;
    const sourceHeight = trim.height;
    bounds.minX = trim.x - anchor._x * width;
    bounds.maxX = bounds.minX + sourceWidth;
    bounds.minY = trim.y - anchor._y * height;
    bounds.maxY = bounds.minY + sourceHeight;
  } else {
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
}


//# sourceMappingURL=updateQuadBounds.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/global/globalHooks.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/global/globalHooks.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApplicationInitHook: () => (/* binding */ ApplicationInitHook),
/* harmony export */   RendererInitHook: () => (/* binding */ RendererInitHook)
/* harmony export */ });
/* harmony import */ var _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extensions/Extensions.mjs */ "./node_modules/pixi.js/lib/extensions/Extensions.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/pixi.js/lib/utils/const.mjs");



"use strict";
class ApplicationInitHook {
  static init() {
    globalThis.__PIXI_APP_INIT__?.(this, _const_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION);
  }
  static destroy() {
  }
}
/** @ignore */
ApplicationInitHook.extension = _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.Application;
class RendererInitHook {
  constructor(renderer) {
    this._renderer = renderer;
  }
  init() {
    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, _const_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION);
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
RendererInitHook.extension = {
  type: [
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGLSystem,
    _extensions_Extensions_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};


//# sourceMappingURL=globalHooks.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/deprecation.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deprecation: () => (/* binding */ deprecation),
/* harmony export */   v8_0_0: () => (/* binding */ v8_0_0),
/* harmony export */   v8_3_4: () => (/* binding */ v8_3_4)
/* harmony export */ });

const warnings = {};
const v8_0_0 = "8.0.0";
const v8_3_4 = "8.3.4";
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        `${message}
Deprecated since v${version}`
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}


//# sourceMappingURL=deprecation.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logDebugTexture: () => (/* binding */ logDebugTexture)
/* harmony export */ });

async function logDebugTexture(texture, renderer, size = 200) {
  const base64 = await renderer.extract.base64(texture);
  await renderer.encoder.commandFinished;
  const width = size;
  console.log(`logging texture ${texture.source.width}px ${texture.source.height}px`);
  const style = [
    "font-size: 1px;",
    `padding: ${width}px ${300}px;`,
    `background: url(${base64}) no-repeat;`,
    "background-size: contain;"
  ].join(" ");
  console.log("%c ", style);
}


//# sourceMappingURL=logDebugTexture.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/logScene.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/logScene.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logRenderGroupScene: () => (/* binding */ logRenderGroupScene),
/* harmony export */   logScene: () => (/* binding */ logScene)
/* harmony export */ });
/* harmony import */ var _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../scene/sprite/Sprite.mjs */ "./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs");


"use strict";
const colors = [
  "#000080",
  // Navy Blue
  "#228B22",
  // Forest Green
  "#8B0000",
  // Dark Red
  "#4169E1",
  // Royal Blue
  "#008080",
  // Teal
  "#800000",
  // Maroon
  "#9400D3",
  // Dark Violet
  "#FF8C00",
  // Dark Orange
  "#556B2F",
  // Olive Green
  "#8B008B"
  // Dark Magenta
];
let colorTick = 0;
function logScene(container, depth = 0, data = { color: "#000000" }) {
  if (container.renderGroup) {
    data.color = colors[colorTick++];
  }
  let spaces = "";
  for (let i = 0; i < depth; i++) {
    spaces += "    ";
  }
  let label = container.label;
  if (!label && container instanceof _scene_sprite_Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__.Sprite) {
    label = `sprite:${container.texture.label}`;
  }
  let output = `%c ${spaces}|- ${label} (worldX:${container.worldTransform.tx}, relativeRenderX:${container.relativeGroupTransform.tx}, renderX:${container.groupTransform.tx}, localX:${container.x})`;
  if (container.renderGroup) {
    output += " (RenderGroup)";
  }
  if (container.filters) {
    output += "(*filters)";
  }
  console.log(output, `color:${data.color}; font-weight:bold;`);
  depth++;
  for (let i = 0; i < container.children.length; i++) {
    const child = container.children[i];
    logScene(child, depth, { ...data });
  }
}
function logRenderGroupScene(renderGroup, depth = 0, data = { index: 0, color: "#000000" }) {
  let spaces = "";
  for (let i = 0; i < depth; i++) {
    spaces += "    ";
  }
  const output = `%c ${spaces}- ${data.index}: ${renderGroup.root.label} worldX:${renderGroup.worldTransform.tx}`;
  console.log(output, `color:${data.color}; font-weight:bold;`);
  depth++;
  for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {
    const child = renderGroup.renderGroupChildren[i];
    logRenderGroupScene(child, depth, { ...data, index: i });
  }
}


//# sourceMappingURL=logScene.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/logging/warn.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/logging/warn.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });

let warnCount = 0;
const maxWarnings = 500;
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}


//# sourceMappingURL=warn.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/misc/NOOP.mjs":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/misc/NOOP.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOOP: () => (/* binding */ NOOP)
/* harmony export */ });

const NOOP = () => {
};


//# sourceMappingURL=NOOP.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/misc/Transform.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/misc/Transform.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../maths/matrix/Matrix.mjs */ "./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs");
/* harmony import */ var _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../maths/point/ObservablePoint.mjs */ "./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs");



"use strict";
class Transform {
  /**
   * @param options - Options for the transform.
   * @param options.matrix - The matrix to use.
   * @param options.observer - The observer to use.
   */
  constructor({ matrix, observer } = {}) {
    this.dirty = true;
    this._matrix = matrix ?? new _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.observer = observer;
    this.position = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    this.scale = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 1, 1);
    this.pivot = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    this.skew = new _maths_point_ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
  }
  /**
   * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot
   * properties into a single matrix.
   * @readonly
   */
  get matrix() {
    const lt = this._matrix;
    if (!this.dirty)
      return lt;
    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;
    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
    this.dirty = false;
    return lt;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   * @private
   */
  _onUpdate(point) {
    this.dirty = true;
    if (point === this.skew) {
      this.updateSkew();
    }
    this.observer?._onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this.dirty = true;
  }
  toString() {
    return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this.dirty = true;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this._onUpdate(this.skew);
    }
  }
}


//# sourceMappingURL=Transform.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getResolutionOfUrl: () => (/* binding */ getResolutionOfUrl)
/* harmony export */ });
/* harmony import */ var _assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../assets/resolver/Resolver.mjs */ "./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs");


"use strict";
function getResolutionOfUrl(url, defaultValue = 1) {
  const resolution = _assets_resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_0__.Resolver.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue;
}


//# sourceMappingURL=getResolutionOfUrl.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/path.mjs":
/*!*************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/path.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   path: () => (/* binding */ path)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");


"use strict";
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code = path2.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i)}`;
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */
  isBlobUrl(path2) {
    return path2.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */
  hasProtocol(path2) {
    return /^[^/:]+:/.test(this.toPosix(path2));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    const matchFile = /^file:\/\/\//.exec(path2);
    if (matchFile) {
      return matchFile[0];
    }
    const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
    if (matchProtocol) {
      return matchProtocol[0];
    }
    return "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */
  toAbsolute(url, customBaseUrl, customRootUrl) {
    assertPath(url);
    if (this.isDataUrl(url) || this.isBlobUrl(url))
      return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    url = this.toPosix(url);
    if (url.startsWith("/")) {
      return path.join(rootUrl, url.slice(1));
    }
    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
    return absolutePath;
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */
  normalize(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    if (this.isDataUrl(path2) || this.isBlobUrl(path2))
      return path2;
    path2 = this.toPosix(path2);
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol + path2;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i - 1] ?? "";
          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; i >= 1; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/"))
      root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      if (index !== -1) {
        root = path2.slice(0, index);
      } else
        root = path2;
      if (!root.endsWith("/"))
        root += "/";
    }
    return root;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */
  basename(path2, ext) {
    assertPath(path2);
    if (ext)
      assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i = path2.length - 1; i >= 0; --i) {
      if (path2.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    const protocol = "";
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    if (protocol)
      ret.dir = protocol + ret.dir;
    return ret;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};


//# sourceMappingURL=path.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/pool/Pool.mjs":
/*!******************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/pool/Pool.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pool: () => (/* binding */ Pool)
/* harmony export */ });

class Pool {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(ClassType, initialSize) {
    this._pool = [];
    this._count = 0;
    this._index = 0;
    this._classType = ClassType;
    if (initialSize) {
      this.prepopulate(initialSize);
    }
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(total) {
    for (let i = 0; i < total; i++) {
      this._pool[this._index++] = new this._classType();
    }
    this._count += total;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(data) {
    let item;
    if (this._index > 0) {
      item = this._pool[--this._index];
    } else {
      item = new this._classType();
    }
    item.init?.(data);
    return item;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(item) {
    item.reset?.();
    this._pool[this._index++] = item;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   * @member {number}
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   * @member {number}
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   * @member {number}
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool - mainly used for debugging! */
  clear() {
    this._pool.length = 0;
    this._index = 0;
  }
}


//# sourceMappingURL=Pool.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BigPool: () => (/* binding */ BigPool),
/* harmony export */   PoolGroupClass: () => (/* binding */ PoolGroupClass)
/* harmony export */ });
/* harmony import */ var _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pool.mjs */ "./node_modules/pixi.js/lib/utils/pool/Pool.mjs");


"use strict";
class PoolGroupClass {
  constructor() {
    /**
     * A map to store the pools by their class type.
     * @private
     */
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(Class, total) {
    const classPool = this.getPool(Class);
    classPool.prepopulate(total);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(Class, data) {
    const pool = this.getPool(Class);
    return pool.get(data);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(item) {
    const pool = this.getPool(item.constructor);
    pool.return(item);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(ClassType) {
    if (!this._poolsByClass.has(ClassType)) {
      this._poolsByClass.set(ClassType, new _Pool_mjs__WEBPACK_IMPORTED_MODULE_0__.Pool(ClassType));
    }
    return this._poolsByClass.get(ClassType);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const stats = {};
    this._poolsByClass.forEach((pool) => {
      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
      stats[name] = {
        free: pool.totalFree,
        used: pool.totalUsed,
        size: pool.totalSize
      };
    });
    return stats;
  }
}
const BigPool = new PoolGroupClass();


//# sourceMappingURL=PoolGroup.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/utils/sayHello.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/pixi.js/lib/utils/sayHello.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sayHello: () => (/* binding */ sayHello)
/* harmony export */ });
/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../environment/adapter.mjs */ "./node_modules/pixi.js/lib/environment/adapter.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/pixi.js/lib/utils/const.mjs");



"use strict";
let saidHello = false;
function sayHello(type) {
  if (saidHello) {
    return;
  }
  if (_environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${_const_mjs__WEBPACK_IMPORTED_MODULE_1__.VERSION} (${type}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${_const_mjs__WEBPACK_IMPORTED_MODULE_1__.VERSION} - ${type} - http://www.pixijs.com/`);
  }
  saidHello = true;
}


//# sourceMappingURL=sayHello.mjs.map


/***/ }),

/***/ "./src/ChooseCharacter.ts":
/*!********************************!*\
  !*** ./src/ChooseCharacter.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChooseCharacter: () => (/* binding */ ChooseCharacter)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ChooseCharacter {
    constructor(app, functionMethod, graphicsManager) {
        this.app = app;
        this.graphicsManager = graphicsManager;
        this.skinChoices = this.graphicsManager.createContainer();
        this.functionMethod = functionMethod;
    }
    loadCharacterChoosing() {
        return __awaiter(this, void 0, void 0, function* () {
            this.btnBack1 = this.graphicsManager.createSprite("skinBase");
            this.btnBack1.x = this.app.screen.width / 2 - this.btnBack1.width * 2;
            this.btnBack2 = this.graphicsManager.createSprite("skinBase");
            this.btnBack2.x = this.app.screen.width / 2 - this.btnBack2.width / 2;
            this.btnBack3 = this.graphicsManager.createSprite("skinBase");
            this.btnBack3.x = this.app.screen.width / 2 + this.btnBack3.width;
            this.functionMethod.addChildrenToContainer(this.skinChoices, [
                this.btnBack1,
                this.btnBack2,
                this.btnBack3,
            ]);
            this.skinChoices.x = 0;
            this.skinChoices.y = this.app.screen.height / 2 - this.btnBack1.height / 2;
            this.loadBirds();
        });
    }
    loadBirds() {
        return __awaiter(this, void 0, void 0, function* () {
            this.skin1 = yield this.graphicsManager.createSkinAnimation(1, this.btnBack1);
            this.skin2 = yield this.graphicsManager.createSkinAnimation(2, this.btnBack2);
            this.skin3 = yield this.graphicsManager.createSkinAnimation(3, this.btnBack3);
            this.functionMethod.addChildrenToContainer(this.skinChoices, [
                this.skin1,
                this.skin2,
                this.skin3,
            ]);
            this.functionMethod.chosenSkin([this.btnBack1, this.btnBack2, this.btnBack3], [this.skin1, this.skin2, this.skin3], this.skinChoices);
            yield this.functionMethod.startAnimation([this.btnBack1, this.btnBack2, this.btnBack3], [this.skin1, this.skin2, this.skin3]);
            yield this.functionMethod.stopAnimation([this.btnBack1, this.btnBack2, this.btnBack3], [this.skin1, this.skin2, this.skin3]);
        });
    }
}


/***/ }),

/***/ "./src/GraphicsManager.ts":
/*!********************************!*\
  !*** ./src/GraphicsManager.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphicsManager: () => (/* binding */ GraphicsManager)
/* harmony export */ });
/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.mjs");
/* harmony import */ var _helperMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helperMethods */ "./src/helperMethods.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class GraphicsManager extends _helperMethods__WEBPACK_IMPORTED_MODULE_1__.helperMethods {
    constructor(app) {
        super();
        this.textures = new Map();
        this.registeredAssets = new Set();
        this.app = app;
        this.createTextures();
    }
    createTextures() {
        //create background of the chooseSkin buttons
        const skinBase = this.createRoundedBackground("rgb(255, 255, 255)", 0, 0, 150, 150, 10, 0.8);
        skinBase.stroke({ width: 5, color: "#F79370", alpha: 1 });
        const skinBaseTexture = this.app.renderer.generateTexture(skinBase);
        // const skinBaseSprite = new PIXI.Sprite(skinBaseTexture);
        this.textures.set("skinBase", skinBaseTexture);
        //create start button texture
        const startBtnBase = this.createRoundedBackground("rgb(255, 255, 255)", 0, 0, 150, 70, 10, 0.8);
        startBtnBase.stroke({ width: 5, color: "rgb(21, 234, 39)", alpha: 1 });
        const startBtnBaseTexture = this.app.renderer.generateTexture(startBtnBase);
        this.textures.set("startBtnBase", startBtnBaseTexture);
    }
    //get the texture from the map
    getTexture(name) {
        return this.textures.get(name);
    }
    //create sprite from texture
    createSprite(name) {
        let texture = this.getTexture(name);
        if (!texture)
            throw new Error(`Texture '${name}' not found`);
        const newSprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Sprite(texture);
        newSprite.eventMode = "static";
        newSprite.cursor = "pointer";
        return newSprite;
    }
    //create PIXI container
    createContainer() {
        return new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Container();
    }
    //create PIXI Background with Graphics
    createRoundedBackground(fill, x, y, w, h, radius, alpha = 1) {
        const rBack = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Graphics();
        rBack.fill(fill);
        rBack.roundRect(x, y, w, h, radius);
        rBack.fill();
        rBack.alpha = alpha;
        return rBack;
    }
    //create PIXI Background with Sprite
    createBackground(tint, alpha, width, height, x, y) {
        const background = pixi_js__WEBPACK_IMPORTED_MODULE_0__.Sprite.from(pixi_js__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE);
        background.tint = tint;
        background.alpha = alpha;
        background.width = width;
        background.height = height;
        background.x = x;
        background.y = y;
        return background;
    }
    //create PIXI Text
    createText(text, fontSize, fill) {
        return new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Text({
            text: text,
            style: {
                fontFamily: "'Lucida Handwriting', cursive",
                fontSize: fontSize,
                fontWeight: "bold",
                fill: fill,
                align: "center",
            },
        });
    }
    createSkinAnimation(order, 
    // frame1: string,
    // frame2: string,
    adjust) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.registeredAssets.has("birdAtlas")) {
                pixi_js__WEBPACK_IMPORTED_MODULE_0__.Assets.add({ alias: "birdAtlas", src: "texture.json" });
                this.registeredAssets.add("birdAtlas");
            }
            yield pixi_js__WEBPACK_IMPORTED_MODULE_0__.Assets.load("birdAtlas");
            const atlas = pixi_js__WEBPACK_IMPORTED_MODULE_0__.Assets.get("birdAtlas");
            const textures = atlas.textures;
            const birdFrames = [
                textures[`skin${order}-up.png`],
                textures[`skin${order}-down.png`],
            ];
            const bird = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.AnimatedSprite(birdFrames);
            bird.animationSpeed = 0.15;
            bird.loop = true;
            bird.alpha = 0.5;
            bird.anchor.set(0.5, 0.5);
            bird.width = 100;
            bird.height = 100;
            bird.x = adjust.x + adjust.width / 2;
            bird.y = adjust.y + adjust.height / 2;
            this.grayAnimation(bird);
            return bird;
        });
    }
}


/***/ }),

/***/ "./src/StartGame.ts":
/*!**************************!*\
  !*** ./src/StartGame.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StartGame: () => (/* binding */ StartGame)
/* harmony export */ });
/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.mjs");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class StartGame {
    constructor(app, functionMethods, graphicsManager, chosenAnimation) {
        this.startContainer = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Container();
        this.app = app;
        this.graphicsManager = graphicsManager;
        this.functionMethods = functionMethods;
        this.chosenAnimation = chosenAnimation;
    }
    createStartBtn() {
        return __awaiter(this, void 0, void 0, function* () {
            this.startBtnBack = yield this.graphicsManager.createSprite("startBtnBase");
            this.startText = yield this.graphicsManager.createText("START", 25, "#000000");
            this.functionMethods.hoverScale([this.startBtnBack, this.startText], this.app.screen);
            this.functionMethods.centerElement(this.app.screen, this.startText);
            this.functionMethods.centerElement(this.app.screen, this.startBtnBack);
            this.functionMethods.addChildrenToContainer(this.startContainer, [
                this.startBtnBack,
                this.startText,
            ]);
        });
    }
}


/***/ }),

/***/ "./src/functionMethods.ts":
/*!********************************!*\
  !*** ./src/functionMethods.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   functionMethods: () => (/* binding */ functionMethods)
/* harmony export */ });
/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.mjs");
/* harmony import */ var _helperMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helperMethods */ "./src/helperMethods.ts");
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class functionMethods extends _helperMethods__WEBPACK_IMPORTED_MODULE_1__.helperMethods {
    constructor(app, loadStartBtn) {
        super();
        this.mainContainer = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Container();
        this.blurFilter = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.BlurFilter({ strength: 8 });
        this.ticker = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Ticker();
        this.app = app;
        this.loadStartBtn = loadStartBtn;
    }
    //loading the main Background
    loadBackground() {
        return __awaiter(this, void 0, void 0, function* () {
            const cityTexture = yield pixi_js__WEBPACK_IMPORTED_MODULE_0__.Assets.load("smallSizeCityBackground.webp");
            this.citySprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Sprite(cityTexture);
            this.evenHeight(this.citySprite, this.app.screen);
            this.evenWidth(this.citySprite, this.app.screen);
            this.addPixelBackground();
            this.citySprite.anchor.set(0);
        });
    }
    // //choosing skin
    chosenSkin(elements, animations, child) {
        for (let i = 0; i < elements.length; i++) {
            elements[i].onpointerdown = () => {
                this.removeChild(this.mainContainer, child);
                animations[i].y = this.app.screen.height / 2 / 2;
                animations[i].x = this.app.screen.width / 2;
                this.loadStartBtn(animations[i]);
                return animations[i];
            };
        }
    }
    addPixelBackground() {
        this.citySprite.filters = [this.blurFilter];
    }
    removePixelBackground() {
        this.ticker.add(() => {
            if (this.blurFilter.strength > 0) {
                this.blurFilter.strength -= 0.1;
                console.log("blur is decreasing");
            }
            else {
                this.citySprite.filters = [];
                this.ticker.stop();
            }
        });
        this.ticker.start();
    }
    //click Start button
    clickStartBtn(element, animation, child) {
        element.onpointerdown = () => {
            this.removePixelBackground(), this.removeChild(this.mainContainer, child);
            gsap__WEBPACK_IMPORTED_MODULE_2__["default"].to(animation, {
                x: this.app.screen.width + animation.width,
                duration: 2,
                ease: "power1.inOut",
                onComplete: () => {
                    animation.width = animation.width / 2;
                    animation.height = animation.height / 2;
                    gsap__WEBPACK_IMPORTED_MODULE_2__["default"].fromTo(animation, { x: 0 }, { x: animation.width * 2, duration: 0.5 });
                },
            });
        };
    }
}


/***/ }),

/***/ "./src/helperMethods.ts":
/*!******************************!*\
  !*** ./src/helperMethods.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   helperMethods: () => (/* binding */ helperMethods)
/* harmony export */ });
/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.mjs");

class helperMethods {
    constructor() { }
    //add children to container
    addChildrenToContainer(container, elements) {
        elements.forEach((element) => {
            container.addChild(element);
        });
    }
    //remove child from container
    removeChild(parent, child) {
        parent.removeChild(child);
    }
    //make height even
    evenHeight(element, reference) {
        element.height = reference.height;
    }
    //make width even
    evenWidth(element, reference) {
        element.width = reference.width;
    }
    centerElement(parent, child) {
        child.x = parent.width / 2 - child.width / 2;
        child.y = parent.height / 2 - child.height / 2;
    }
    startAnimation(main, animated) {
        for (let i = 0; i < main.length; i++) {
            main[i].onpointerover = () => {
                animated[i].play();
                animated[i].alpha = 1;
                animated[i].height = animated[i].height + 10;
                animated[i].width = animated[i].width + 10;
                this.colorAnimation(animated[i]);
            };
        }
    }
    stopAnimation(main, animated) {
        for (let i = 0; i < main.length; i++) {
            main[i].onpointerout = () => {
                animated[i].gotoAndStop(0);
                animated[i].alpha = 0.5;
                animated[i].width = 100;
                animated[i].height = 100;
                this.grayAnimation(animated[i]);
            };
        }
    }
    grayAnimation(element) {
        const grayFilter = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.ColorMatrixFilter();
        grayFilter.desaturate();
        element.filters = [grayFilter];
    }
    colorAnimation(element) {
        element.filters = [];
    }
    hoverScale(elements, parent) {
        elements[0].onpointerover = () => {
            elements[0].scale = 1.2;
            elements[1].scale = 1.2;
            this.centerElement(parent, elements[0]);
            this.centerElement(parent, elements[1]);
        };
        elements[0].onpointerout = () => {
            elements[0].scale = 1;
            elements[1].scale = 1;
            this.centerElement(parent, elements[0]);
            this.centerElement(parent, elements[1]);
        };
    }
    isReallyTouchDevice() {
        return ((navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
            window.matchMedia("(pointer: coarse)").matches);
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "airplanegame:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkairplanegame"] = self["webpackChunkairplanegame"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.mjs");
/* harmony import */ var _functionMethods__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functionMethods */ "./src/functionMethods.ts");
/* harmony import */ var _GraphicsManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GraphicsManager */ "./src/GraphicsManager.ts");
/* harmony import */ var _ChooseCharacter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ChooseCharacter */ "./src/ChooseCharacter.ts");
/* harmony import */ var _StartGame__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StartGame */ "./src/StartGame.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





class PixiApp {
    constructor() {
        this.app = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Application();
        this.registeredAssets = new Set();
        this.init();
    }
    //initialization of the Application
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.app = new pixi_js__WEBPACK_IMPORTED_MODULE_0__.Application();
            yield this.app.init({ resizeTo: window });
            document.body.appendChild(this.app.canvas);
            this.functionMethod = new _functionMethods__WEBPACK_IMPORTED_MODULE_1__.functionMethods(this.app, this.loadStartBtn.bind(this));
            this.graphicsManager = new _GraphicsManager__WEBPACK_IMPORTED_MODULE_2__.GraphicsManager(this.app);
            this.chooseCharacter = new _ChooseCharacter__WEBPACK_IMPORTED_MODULE_3__.ChooseCharacter(this.app, this.functionMethod, this.graphicsManager);
            this.startGame = new _StartGame__WEBPACK_IMPORTED_MODULE_4__.StartGame(this.app, this.functionMethod, this.graphicsManager, this.chooseCharacter.chosenAnimation);
            yield this.loadAssets();
        });
    }
    loadAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.app.stage.addChild(this.functionMethod.mainContainer);
            yield this.functionMethod.loadBackground();
            yield this.chooseCharacter.loadCharacterChoosing();
            yield this.functionMethod.addChildrenToContainer(this.functionMethod.mainContainer, [this.functionMethod.citySprite, this.chooseCharacter.skinChoices]);
        });
    }
    loadStartBtn(animation) {
        return __awaiter(this, void 0, void 0, function* () {
            this.chooseCharacter.chosenAnimation = animation;
            yield this.startGame.createStartBtn();
            this.functionMethod.addChildrenToContainer(this.functionMethod.mainContainer, [this.startGame.startContainer, this.chooseCharacter.chosenAnimation]);
            this.functionMethod.clickStartBtn(this.startGame.startBtnBack, this.chooseCharacter.chosenAnimation, this.startGame.startContainer);
        });
    }
}
new PixiApp();

})();

/******/ })()
;